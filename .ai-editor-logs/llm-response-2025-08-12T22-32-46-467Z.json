{
  "timestamp": "2025-08-12T22:32:46.468Z",
  "prompt": "\n# AI Code Generation Request\n\n## User Request\n```text\nFix google oauth callback and github\n```\n\n## Project Context\n  - src/\n    - src/auth/\n      - src/auth/auth-google.controller.ts\n      - src/auth/auth.controller.ts\n      - src/auth/auth.guard.ts\n      - src/auth/auth.module.ts\n      - src/auth/auth.service.ts\n      - src/auth/auth.strategy.ts\n      - src/auth/decorators/\n        - src/auth/decorators/current-user.decorator.ts\n        - src/auth/decorators/roles.decorator.ts\n      - src/auth/dto/\n        - src/auth/dto/auth.dto.ts\n        - src/auth/dto/email-verification-response.dto.ts\n        - src/auth/dto/github-profile.dto.ts\n        - src/auth/dto/google-profile.dto.ts\n        - src/auth/dto/google-token.dto.ts\n        - src/auth/dto/verify-email.dto.ts\n      - src/auth/enums/\n        - src/auth/enums/user-role.enum.ts\n      - src/auth/guards/\n        - src/auth/guards/github.guard.ts\n        - src/auth/guards/google.guard.ts\n        - src/auth/guards/roles.guard.ts\n      - src/auth/interfaces/\n        - src/auth/interfaces/auth-request.interface.ts\n        - src/auth/interfaces/github-profile.interface.ts\n        - src/auth/interfaces/jwt-payload.interface.ts\n      - src/auth/oauth.service.ts\n      - src/auth/strategies/\n        - src/auth/strategies/github.strategy.ts\n        - src/auth/strategies/google.strategy.ts\n\n### Relevant Files (for analysis)\n```files\n// File: src/auth/auth-google.controller.ts\nimport {\n  Controller,\n  Post,\n  Body,\n  Res,\n  UseGuards,\n  Get,\n  Req,\n  BadRequestException,\n  Query,\n  NotFoundException,\n} from '@nestjs/common';\nimport {\n  ApiTags,\n  ApiOperation,\n  ApiResponse,\n  ApiBearerAuth,\n  ApiQuery,\n  ApiBody,\n} from '@nestjs/swagger';\nimport { JwtService } from '@nestjs/jwt';\nimport { PrismaService } from '../prisma/prisma.service';\nimport { MailService } from '../mail/mail.service';\nimport { AuthService } from './auth.service';\nimport { RegisterDto, LoginDto, CreateJwtUserDto } from './dto/auth.dto';\nimport { VerifyEmailDto } from './dto/verify-email.dto';\n\nimport { GoogleAuthGuard } from './guards/google.guard';\nimport { JwtAuthGuard } from './auth.guard';\nimport { Response, Request } from 'express';\n\n@ApiTags('Auth')\n@Controller('api/auth-google')\nexport class AuthController {\n  constructor(\n    private readonly authService: AuthService,\n    private readonly prisma: PrismaService,\n    private readonly mailService: MailService,\n  ) {}\n  /*@Get('google')\n  @UseGuards(GoogleAuthGuard)\n  @ApiOperation({ summary: 'Initiate Google OAuth2 login' })\n  @ApiResponse({ status: 302, description: 'Redirects to Google login' })\n  async googleAuth() {\n    // Initiates the Google OAuth2 login flow\n  }\n\n  @Get('google/callback')\n  @UseGuards(GoogleAuthGuard)\n  @ApiOperation({ summary: 'Handle Google OAuth2 callback and issue JWT token' })\n  @ApiResponse({ status: 200, description: 'Google login successful with JWT issued' })\n  @ApiResponse({ status: 401, description: 'Unauthorized or failed login attempt' })\n  async googleAuthRedirect(@Req() req: Request, @Res() res: Response) {\n    const user = req.user;\n\n    const payload = {\n      sub: user.id,\n      email: user.email,\n      role: user.role,\n    };\n\n    const accessToken  = await this.authService.generateToken(payload);\n    res.cookie('accessToken', accessToken, {\n      httpOnly: true,\n      secure: process.env.NODE_ENV === 'production',\n      sameSite: 'lax',\n    });\n\n\n    return res.json({\n      message: 'Google login successful',\n      token,\n      user,\n    });\n  }*/\n}\n\n\n// File: src/auth/auth.controller.ts\n// File: /media/eddie/Data/projects/nestJS/nest-modules/full-stack/src/auth/auth.controller.ts\n\nimport {\n  Controller,\n  Post,\n  Body,\n  Res,\n  UseGuards,\n  Get,\n  Req,\n  BadRequestException,\n  Query,\n  NotFoundException,\n  Redirect,\n} from '@nestjs/common';\nimport {\n  ApiTags,\n  ApiOperation,\n  ApiResponse,\n  ApiBearerAuth,\n  ApiQuery,\n  ApiBody,\n} from '@nestjs/swagger';\nimport { JwtService } from '@nestjs/jwt';\nimport { PrismaService } from '../prisma/prisma.service';\nimport { MailService } from '../mail/mail.service';\nimport { AuthService } from './auth.service';\nimport { RegisterDto, LoginDto, CreateJwtUserDto } from './dto/auth.dto';\nimport { VerifyEmailDto } from './dto/verify-email.dto';\nimport { AuthRequest } from './interfaces/auth-request.interface';\nimport { GoogleAuthGuard } from './guards/google.guard';\nimport { GitHubAuthGuard } from './guards/github.guard';\nimport { JwtAuthGuard } from './auth.guard';\nimport { Response, Request } from 'express';\nimport { GitHubProfileDto, GitHubTokenDto } from './dto/github-profile.dto';\nimport { GoogleProfileDto } from './dto/google-profile.dto';\nimport { GoogleTokenDto } from './dto/google-token.dto';\nimport { UserRole } from './enums/user-role.enum';\nimport { Role } from '@prisma/client';\n\n\n/**\n * AuthController handles authentication-related endpoints, including user registration,\n * login, logout, email verification, and OAuth2 authentication with Google and GitHub.\n *\n * @ApiTags Auth\n * @Controller api/auth\n */\n@ApiTags('Auth')\n@Controller('api/auth')\nexport class AuthController {\n  constructor(\n    private readonly authService: AuthService,\n    private readonly prisma: PrismaService,\n    private readonly mailService: MailService,\n  ) {}\n\n  /**\n   * Handles the OAuth2 callback from Google or GitHub, validating the profile,\n   * generating a JWT token, and returning the access token and user information.\n   *\n   * @private\n   * @async\n   * @function handleOAuthCallback\n   * @param {('google' | 'github')} provider - The OAuth2 provider (either 'google' or 'github').\n   * @param {AuthRequest} req - The request object containing user profile and tokens.\n   * @returns {Promise<{ accessToken: string; user: any }>} - A promise that resolves to an object\n   * containing the access token and user information.  The user object type is 'any' because the\n   * specific profile type will depend on the OAuth2 provider.\n   */\n  private async handleOAuthCallback(\n    provider: 'google' | 'github',\n    req: AuthRequest,\n  ): Promise<{ accessToken: string; user: any, profile?: GoogleProfileDto | GitHubProfileDto, tokens: GoogleTokenDto | GitHubTokenDto }> {\n    const { profile, tokens } = req.user as {\n      profile: GoogleProfileDto | GitHubProfileDto;\n      tokens: GoogleTokenDto | GitHubTokenDto;\n     // provider: 'google' | 'github';\n    };\n\n    const user  = await this.authService.validateOAuthProfile(\n      provider,\n      profile,\n      tokens,\n    );\n\n    const payload: CreateJwtUserDto = {\n      id: user.id,\n      sub: user.id,\n      email: user.email,\n      role: user.role ?? Role.USER,\n      image: user.image ?? undefined,\n      name: user.name ?? '',\n      phone_number: user.phone_number ?? '',\n      provider,\n     // tokens,\n      \n    };\n\n    const accessToken = await this.authService.generateToken(payload);\n  \n    return { accessToken, user, profile, tokens };\n  }\n\n  /**\n   * Logs in a user and sets a JWT cookie.\n   *\n   * @Post login\n   * @ApiOperation summary Log in a user and set JWT cookie\n   * @ApiResponse status 200 - User logged in successfully\n   * @ApiResponse status 401 - Invalid credentials\n   * @async\n   * @function login\n   * @param {LoginDto} dto - The login credentials data transfer object.\n   * @param {Response} res - The Express response object for setting cookies.\n   * @returns {Promise<any>} - A promise that resolves to the user information.  The user object type is 'any' because the\n   * specific shape may depend on the authentication strategy.\n   */\n  @Post('login')\n  @ApiOperation({ summary: 'Log in a user and set JWT cookie' })\n  @ApiResponse({ status: 200, description: 'User logged in successfully' })\n  @ApiResponse({ status: 401, description: 'Invalid credentials' })\n  async login(\n    @Body() dto: LoginDto,\n    @Res({ passthrough: true }) res: Response,\n  ) {\n    const user = await this.authService.login(dto);\n    res.cookie('accessToken', user.accessToken, {\n      httpOnly: true,\n      secure: process.env.NODE_ENV === 'production',\n      sameSite: 'lax',\n    });\n    return user;\n  }\n\n  /**\n   * Logs out a user by clearing the JWT cookie.\n   *\n   * @Post logout\n   * @ApiOperation summary Log out user (clear cookie)\n   * @ApiResponse status 200 - Logged out successfully\n   * @async\n   * @function logout\n   * @param {Response} res - The Express response object for clearing cookies.\n   * @returns {Promise<{ message: string }>} - A promise that resolves to a success message.\n   */\n  @Post('logout')\n  @ApiOperation({ summary: 'Log out user (clear cookie)' })\n  @ApiResponse({ status: 200, description: 'Logged out successfully' })\n  async logout(@Res({ passthrough: true }) res: Response) {\n    res.clearCookie('accessToken');\n    return { message: 'Logged out successfully' };\n  }\n\n  /**\n   * Initiates the GitHub OAuth2 login flow.\n   *\n   * @Get github\n   * @UseGuards GitHubAuthGuard\n   * @ApiOperation summary Initiate GitHub OAuth2 login\n   * @ApiResponse status 302 - Redirects to GitHub login\n   * @async\n   * @function githubAuth\n   */\n  @Get('github')\n  @UseGuards(GitHubAuthGuard)\n  @ApiOperation({ summary: 'Initiate GitHub OAuth2 login' })\n  @ApiResponse({ status: 302, description: 'Redirects to GitHub login' })\n  async githubAuth() {\n    // OAuth2 login flow initiated by Passport\n  }\n\n  /**\n   * Handles the GitHub OAuth2 callback, issues a JWT token, and redirects the user.\n   *\n   * @Get github/callback\n   * @UseGuards GitHubAuthGuard\n   * @ApiOperation summary Handle GitHub OAuth2 callback and issue JWT token\n   * @ApiResponse status 200 - GitHub login successful with JWT issued\n   * @ApiResponse status 401 - Unauthorized or failed login attempt\n   * @async\n   * @function githubAuthRedirect\n   * @param {AuthRequest} req - The request object containing user information from GitHub.\n   * @param {Response} res - The Express response object for setting cookies and redirecting.\n   * @returns {Promise<any>} - A promise that resolves after redirecting the user.\n   */\n  @Get('github/callback')\n  @UseGuards(GitHubAuthGuard)\n  @ApiOperation({\n    summary: 'Handle GitHub OAuth2 callback and issue JWT token',\n  })\n  @ApiResponse({\n    status: 200,\n    description: 'GitHub login successful with JWT issued',\n  })\n  @ApiResponse({\n    status: 401,\n    description: 'Unauthorized or failed login attempt',\n  })\n  async githubAuthRedirect(@Req() req: AuthRequest, @Res() res: Response) {\n    try {\n      const { accessToken, user, profile, tokens } = await this.handleOAuthCallback(\n        'github',\n        req,\n      );\n\n      res.cookie('accessToken', accessToken, {\n        httpOnly: true,\n        secure: process.env.NODE_ENV === 'production',\n        sameSite: 'lax',\n      });\n\n      return res.redirect(\n        `${process.env.FRONTEND_URL}/login?action=success&accessToken=${accessToken}&userId=${user.id}&userEmail=${user.email}&userName=${user.name}&userImage=${user.image}&userRole=${user.role}&username=${user.username}`,\n      );\n    } catch (error) {\n      console.error('OAuth redirect error:', error);\n      return res.redirect('/login?error=OAuth%20Login%20Failed');\n    }\n  }\n\n  /**\n   * Initiates the Google OAuth2 login flow.\n   *\n   * @Get google\n   * @UseGuards GoogleAuthGuard\n   * @ApiOperation summary Initiate Google OAuth2 login\n   * @ApiResponse status 302 - Redirects to Google login\n   * @async\n   * @function googleAuth\n   */\n  @Get('google')\n  @UseGuards(GoogleAuthGuard)\n  @ApiOperation({ summary: 'Initiate Google OAuth2 login' })\n  @ApiResponse({ status: 302, description: 'Redirects to Google login' })\n  async googleAuth() {\n    // OAuth2 login flow initiated by Passport\n  }\n\n  /**\n   * Handles the Google OAuth2 callback, issues a JWT token, and redirects the user.\n   *\n   * @Get google/callback\n   * @UseGuards GoogleAuthGuard\n   * @ApiOperation summary Handle Google OAuth2 callback and issue JWT token\n   * @ApiResponse status 200 - Google login successful with JWT issued\n   * @ApiResponse status 401 - Unauthorized or failed login attempt\n   * @async\n   * @function googleAuthRedirect\n   * @param {AuthRequest} req - The request object containing user information from Google.\n   * @param {Response} res - The Express response object for setting cookies and redirecting.\n   * @returns {Promise<any>} - A promise that resolves after redirecting the user.\n   */\n  @Get('google/callback')\n  @UseGuards(GoogleAuthGuard)\n  @ApiOperation({\n    summary: 'Handle Google OAuth2 callback and issue JWT token',\n  })\n  @ApiResponse({\n    status: 200,\n    description: 'Google login successful with JWT issued',\n  })\n  @ApiResponse({\n    status: 401,\n    description: 'Unauthorized or failed login attempt',\n  })\n  async googleAuthRedirect(@Req() req: AuthRequest, @Res() res: Response) {\n    try {\n      const { accessToken, user } = await this.handleOAuthCallback(\n        'google',\n        req,\n      );\n\n      res.cookie('accessToken', accessToken, {\n        httpOnly: true,\n        secure: process.env.NODE_ENV === 'production',\n        sameSite: 'lax',\n      });\n      //localStorage.setItem('accessToken', accessToken);\n      ///localStorage.setItem('user', JSON.stringify(user));\n      return res.redirect(\n        `${process.env.FRONTEND_URL}/login?action=success&accessToken=${accessToken}&userId=${user.id}&userEmail=${user.email}&userName=${user.name}&userImage=${user.image}&userRole=${user.role}`,\n      );\n    } catch (error) {\n      console.error('OAuth redirect error:', error);\n      return res.redirect('/login?error=OAuth%20Login%20Failed');\n    }\n  }\n\n  /**\n   * Registers a new user.\n   *\n   * @Post register\n   * @ApiOperation summary Register a new user\n   * @ApiResponse status 201 - User registered successfully\n   * @ApiResponse status 400 - Validation failed or user already exists\n   * @async\n   * @function register\n   * @param {RegisterDto} dto - The registration data transfer object.\n   * @returns {Promise<void>} - A promise that resolves when registration is complete.\n   */\n  @Post('register')\n  @ApiOperation({ summary: 'Register a new user' })\n  @ApiResponse({ status: 201, description: 'User registered successfully' })\n  @ApiResponse({\n    status: 400,\n    description: 'Validation failed or user already exists',\n  })\n  async register(@Body() dto: RegisterDto): Promise<void> {\n    await this.authService.register(dto);\n  }\n\n  /**\n   * Resends the email verification link to the user.\n   *\n   * @Post resend-verification\n   * @ApiOperation summary Resend email verification link\n   * @ApiBody schema containing the user's email address.\n   * @async\n   * @function resendVerification\n   * @param {string} email - The email address of the user.\n   * @returns {Promise<any>} - A promise that resolves with the result of resending verification.  The result type is 'any'\n   * because the structure of the response from the mail service can vary.\n   */\n  @Post('resend-verification')\n  @ApiOperation({ summary: 'Resend email verification link' })\n  @ApiBody({\n    schema: {\n      properties: { email: { type: 'string', example: 'user@example.com' } },\n    },\n  })\n  async resendVerification(@Body('email') email: string) {\n    return this.authService.resendVerification(email);\n  }\n\n  /**\n   * Verifies the user's email address using the provided token.\n   *\n   * @Get verify-email\n   * @ApiOperation summary Verify user email address\n   * @ApiResponse status 200 - Email verified successfully\n   * @ApiResponse status 400 - Invalid or expired token\n   * @async\n   * @function verifyEmail\n   * @param {VerifyEmailDto} query - The query parameters containing the verification token.\n   * @returns {Promise<any>} - A promise that resolves with the result of email verification.  The result type is 'any' because\n   * the response format can depend on the implementation of the verification service.\n   */\n  @Get('verify-email')\n  @ApiOperation({ summary: 'Verify user email address' })\n  @ApiResponse({ status: 200, description: 'Email verified successfully' })\n  @ApiResponse({ status: 400, description: 'Invalid or expired token' })\n  async verifyEmail(@Query() query: VerifyEmailDto) {\n    return this.authService.verifyEmail(query.token);\n  }\n\n  /**\n   * Gets the profile of the currently authenticated user.\n   *\n   * @Get me\n   * @UseGuards JwtAuthGuard\n   * @ApiBearerAuth\n   * @ApiOperation summary Get current authenticated user\n   * @ApiResponse status 200 - User profile returned\n   * @ApiResponse status 401 - Unauthorized\n   * @async\n   * @function getProfile\n   * @param {Request} req - The request object containing the user information.\n   * @returns {Promise<any>} - A promise that resolves with the user profile.  The user profile type is 'any' because the shape\n   * can vary based on the data stored about the user.\n   */\n  @UseGuards(JwtAuthGuard)\n  @Get('me')\n  @ApiBearerAuth()\n  @ApiOperation({ summary: 'Get current authenticated user' })\n  @ApiResponse({ status: 200, description: 'User profile returned' })\n  @ApiResponse({ status: 401, description: 'Unauthorized' })\n  async getProfile(@Req() req: Request) {\n    const meR = req['user'];\n    if(meR.email){\n       const getAccount = this.prisma.user.findUnique({\n      where: { email: meR?.email },\n      include: {\n        Account: true,\n      },\n    });\n    if(getAccount){\n     \n    return getAccount;\n    } else {\n      return meR;\n    }\n    \n    }\n   \n  }\n}\n\n\n// File: src/auth/auth.guard.ts\nimport { ExecutionContext, Injectable } from '@nestjs/common';\nimport { AuthGuard } from '@nestjs/passport';\n\n@Injectable()\nexport class JwtAuthGuard extends AuthGuard('jwt') {\n  canActivate(context: ExecutionContext) {\n    return super.canActivate(context);\n  }\n\n  handleRequest(err, user, info) {\n    if (err || !user) {\n      return null;\n    }\n    return user;\n  }\n}\n\n\n// File: src/auth/auth.module.ts\nimport { Module } from '@nestjs/common';\nimport { JwtModule } from '@nestjs/jwt';\nimport { ConfigModule, ConfigService } from '@nestjs/config';\nimport { AuthService } from './auth.service';\nimport { AuthController } from './auth.controller';\nimport { JwtStrategy } from './auth.strategy';\nimport { JwtAuthGuard } from './auth.guard';\nimport { GoogleStrategy } from './strategies/google.strategy';\nimport { GoogleAuthGuard } from './guards/google.guard';\nimport { GitHubStrategy } from './strategies/github.strategy';\nimport { GitHubAuthGuard } from './guards/github.guard';\nimport { PrismaService } from '../prisma/prisma.service';\nimport { MailService } from '../mail/mail.service';\nimport { OAuthService } from './oauth.service';\n\n@Module({\n  imports: [\n    ConfigModule.forRoot({ isGlobal: true }),\n    JwtModule.registerAsync({\n      imports: [ConfigModule],\n      inject: [ConfigService],\n      useFactory: async (configService: ConfigService) => ({\n        secret: configService.get<string>('JWT_SECRET'),\n        signOptions: { expiresIn: '1d' },\n      }),\n    }),\n  ],\n  controllers: [AuthController],\n  providers: [\n    AuthService,\n    JwtStrategy,\n    GoogleStrategy,\n    GoogleAuthGuard,\n    GitHubStrategy,\n    GitHubAuthGuard,\n    JwtAuthGuard,\n    PrismaService,\n    MailService,\n    OAuthService,\n  ],\n  exports: [AuthService],\n})\nexport class AuthModule {}\n\n\n// File: src/auth/auth.service.ts\n// File: /media/eddie/Data/projects/nestJS/nest-modules/full-stack/src/auth/auth.service.ts\n\nimport {\n  BadRequestException,\n  Injectable,\n  UnauthorizedException,\n  InternalServerErrorException,\n  Logger,\n  NotFoundException,\n} from '@nestjs/common';\nimport * as bcrypt from 'bcrypt';\nimport { JwtService } from '@nestjs/jwt';\nimport { Role } from '@prisma/client';\n\nimport { PrismaService } from '../prisma/prisma.service';\nimport { MailService } from '../mail/mail.service';\n\nimport { RegisterDto, LoginDto } from './dto/auth.dto';\nimport { UserRole } from './enums/user-role.enum';\n\nimport { GoogleProfileDto } from './dto/google-profile.dto';\nimport { GoogleTokenDto } from './dto/google-token.dto';\nimport { GitHubProfileDto, GitHubTokenDto } from './dto/github-profile.dto';\n\nimport { JwtPayload } from './interfaces/jwt-payload.interface';\nimport { OAuthService } from './oauth.service';\nimport { CreateJwtUserDto } from './dto/auth.dto';\n\n/**\n * AuthService handles user authentication and authorization logic.\n * It provides methods for user registration, login, email verification,\n * and integration with OAuth providers like Google and GitHub.\n */\n@Injectable()\nexport class AuthService {\n  /**\n   * Constructor for AuthService.\n   * @param prisma - PrismaService for database interactions.\n   * @param jwtService - JwtService for generating and verifying JWT tokens.\n   * @param mailService - MailService for sending emails.\n   * @param oauthService - OAuthService for handling OAuth authentication.\n   */\n  constructor(\n    private readonly prisma: PrismaService,\n    private readonly jwtService: JwtService,\n    private readonly mailService: MailService,\n    private readonly oauthService: OAuthService,\n  ) {}\n\n  /**\n   * Generates an email verification token for a given user ID.\n   * @param userId - The ID of the user to generate the token for.\n   * @returns The generated JWT token.\n   * @private\n   */\n  private generateEmailVerificationToken(userId: string) {\n    return this.jwtService.sign(\n      { sub: userId },\n      {\n        secret: process.env.JWT_VERIFICATION_SECRET,\n        expiresIn: process.env.JWT_VERIFICATION_EXPIRES_IN || '1d',\n      },\n    );\n  }\n\n  /**\n   * Logs in a user with the provided credentials.\n   * @param dto - The LoginDto containing the user's email and password.\n   * @returns A promise that resolves to an object containing the access token and user data.\n   * @throws UnauthorizedException if the credentials are invalid.\n   */\n  async login(dto: LoginDto): Promise<{ accessToken: string; user: any }> {\n    const user = await this.prisma.user.findUnique({\n      where: { email: dto.email },\n      include: { password: true },\n    });\n\n    if (!user || !user.password) {\n      throw new UnauthorizedException('Invalid credentials');\n    }\n\n    const isPasswordValid = await bcrypt.compare(\n      dto.password,\n      user.password.hash,\n    );\n    if (!isPasswordValid) {\n      throw new UnauthorizedException('Invalid credentials');\n    }\n    const payload: CreateJwtUserDto = {\n      id: user.id,\n      sub: user.id,\n      email: user.email,\n      role: user.role ?? Role.USER,\n      image: user.image ?? undefined,\n      name: user.name ?? '',\n      phone_number: user.phone_number ?? '',\n    };\n\n    const accessToken = await this.generateToken(payload);\n    return { accessToken, user: payload };\n  }\n\n  /**\n   * Registers a new user.\n   * @param dto - The RegisterDto containing the user's registration information.\n   * @returns A promise that resolves to an object containing a success message.\n   * @throws InternalServerErrorException if user creation fails.\n   */\n  async register(dto: RegisterDto) {\n    const hash = await bcrypt.hash(dto.password, 10);\n    const createUser = {\n      email: dto.email,\n      name: dto.name,\n      phone_number: dto.phone_number || undefined,\n      role: Role.USER,\n    };\n    const user = await this.prisma.user.create({\n      data: {\n        ...createUser,\n        password: {\n          create: { hash },\n        },\n      },\n    });\n\n    if (!user) {\n      Logger.error('User creation failed: No user returned from database');\n      throw new InternalServerErrorException('User could not be created');\n    }\n    const token = this.generateEmailVerificationToken(user.id);\n    const verifyUrl = `${process.env.BASE_URL}/api/auth/verify-email?token=${token}`;\n\n    await this.mailService.sendVerificationEmail(\n      user.email,\n      user.name ?? 'User',\n      verifyUrl,\n    );\n    // TODO: Log registration event (e.g., using Winston or custom logger)\n    // TODO: Audit log entry to track new account creation\n    // TODO: Add metrics or monitoring hook (e.g., Prometheus counter)\n    // TODO: Optionally trigger admin notification on new registration\n    // TODO: Send account verification email if emailVerified is required\n    return { message: 'Verification email sent.' };\n  }\n\n  /**\n   * Verifies a user's email address using a verification token.\n   * @param token - The email verification token.\n   * @returns A promise that resolves to an object containing a success message.\n   * @throws BadRequestException if the token is invalid or expired.\n   */\n  async verifyEmail(token: string) {\n    try {\n      const payload = this.jwtService.verify(token, {\n        secret: process.env.JWT_VERIFICATION_SECRET,\n      });\n\n      await this.prisma.user.update({\n        where: { id: payload.sub },\n        data: { emailVerified: new Date() },\n      });\n\n      return { message: 'Email verified successfully.' };\n    } catch (err) {\n      throw new BadRequestException('Invalid or expired token.');\n    }\n  }\n\n  /**\n   * Resends the email verification email to a user.\n   * @param email - The email address of the user.\n   * @returns A promise that resolves to an object containing a success message.\n   * @throws NotFoundException if the user is not found.\n   */\n  async resendVerification(email: string) {\n    const user = await this.prisma.user.findUnique({ where: { email } });\n\n    if (!user) throw new NotFoundException('User not found.');\n    if (user.emailVerified) return { message: 'Email already verified.' };\n\n    const token = this.generateEmailVerificationToken(user.id);\n    const verifyUrl = `${process.env.BASE_URL}/api/auth/verify-email?token=${token}`;\n\n    await this.mailService.sendVerificationEmail(\n      user.email,\n      user.name ?? 'User',\n      verifyUrl,\n    );\n\n    return { message: 'Verification email sent.' };\n  }\n\n  /**\n   * Validates a user by ID and returns their information.\n   * @param userId - The ID of the user to validate.\n   * @returns A promise that resolves to the user's information.\n   */\n  async validateUser(userId: string) {\n    return this.prisma.user.findUnique({\n      where: { id: userId },\n      select: {\n        id: true,\n        email: true,\n        name: true,\n        role: true,\n        phone_number: true,\n        createdAt: true,\n        image: true,\n      },\n    });\n  }\n\n  /**\n   * Validates an OAuth profile from a given provider (Google or GitHub).\n   * @param provider - The OAuth provider ('google' or 'github').\n   * @param profile - The user's profile data from the provider.\n   * @param tokens - The access and refresh tokens from the provider.\n   * @returns A promise that resolves to the validated user data.\n   */\n  async validateOAuthProfile(\n    provider: 'google' | 'github',\n    profile: GoogleProfileDto | GitHubProfileDto,\n    tokens: GoogleTokenDto | GitHubTokenDto,\n  ) {\n    return await this.oauthService.validate(provider, profile, tokens);\n  }\n\n  /**\n   * Generates a JWT token for a given user payload.\n   * @param payload - The user payload to include in the token.\n   * @returns A promise that resolves to the generated JWT token.\n   */\n  async generateToken(payload: CreateJwtUserDto): Promise<string> {\n    return this.jwtService.signAsync(payload);\n  }\n}\n\n\n// File: src/auth/auth.strategy.ts\nimport { Injectable } from '@nestjs/common';\nimport { PassportStrategy } from '@nestjs/passport';\nimport { ExtractJwt, Strategy } from 'passport-jwt';\nimport { ConfigService } from '@nestjs/config';\nimport { Request } from 'express';\nimport { AuthService } from './auth.service';\n\n@Injectable()\nexport class JwtStrategy extends PassportStrategy(Strategy) {\n  constructor(\n    config: ConfigService,\n    private readonly authService: AuthService,\n  ) {\n    super({\n      jwtFromRequest: ExtractJwt.fromExtractors([\n        JwtStrategy.extractFromCookieOrHeader,\n      ]),\n      ignoreExpiration: false,\n      secretOrKey: config.get<string>('JWT_SECRET'),\n      passReqToCallback: true,\n    });\n  }\n\n  /**\n   * Extract JWT from cookies or Authorization header if present (optional).\n   */\n  private static extractFromCookieOrHeader(req: any): string | null {\n    // HTTP Cookies\n    if (req?.cookies?.accessToken) {\n      return req.cookies.accessToken;\n    }\n\n    // WebSocket Cookies\n    const cookieHeader = req?.handshake?.headers?.cookie;\n    if (cookieHeader) {\n      const cookies = Object.fromEntries(\n        cookieHeader.split(';').map((cookie) => {\n          const [key, value] = cookie.trim().split('=');\n          return [key, decodeURIComponent(value)];\n        }),\n      );\n      if (cookies['accessToken']) {\n        return cookies['accessToken'];\n      }\n    }\n\n    // Optional Bearer header (HTTP only)\n    const authHeader = req?.headers?.authorization;\n    if (authHeader?.startsWith('Bearer ')) {\n      return authHeader.split(' ')[1];\n    }\n\n    return null;\n  }\n\n  async validate(req: Request, payload: any) {\n    const user = await this.authService.validateUser(payload.sub);\n    return user ?? null;\n  }\n}\n\n\n// File: src/auth/oauth.service.ts\nimport { Injectable } from '@nestjs/common';\nimport { Role } from '@prisma/client';\n\nimport { PrismaService } from '../prisma/prisma.service';\n\nimport { GoogleProfileDto } from './dto/google-profile.dto';\nimport { GoogleTokenDto } from './dto/google-token.dto';\nimport { GitHubProfileDto, GitHubTokenDto } from './dto/github-profile.dto';\nimport { CreateJwtUserDto } from './dto/auth.dto';\ntype Provider = 'google' | 'github';\n\ninterface OAuthProfile {\n  id: string;\n  email: string;\n  name?: string;\n  image?: string;\n  login?: string;\n}\n\ninterface OAuthTokens {\n  accessToken: string;\n  refreshToken?: string;\n  idToken?: string;\n  expiresAt?: number;\n  scope?: string;\n  tokenType?: string;\n}\n\n@Injectable()\nexport class OAuthService {\n  constructor(private readonly prisma: PrismaService) {}\n\n  async validate(\n    provider: Provider,\n    profile: GoogleProfileDto | GitHubProfileDto,\n    tokens: GoogleTokenDto | GitHubTokenDto,\n  ) {\n    const normalized = this.normalizeProfile(provider, profile);\n    return this.handleOAuthLogin(provider, normalized, tokens);\n  }\n\n  private normalizeProfile(\n    provider: Provider,\n    profile: GoogleProfileDto | GitHubProfileDto,\n  ): OAuthProfile {\n    if (provider === 'google') {\n      const google = profile as GoogleProfileDto;\n      const email = google.emails?.[0]?.value;\n      const image = google.photos?.[0]?.value;\n      const name =\n        `${google.name?.givenName ?? ''} ${google.name?.familyName ?? ''}`.trim();\n\n      if (!email)\n        throw new Error(\n          'Google profile does not contain a valid email address.',\n        );\n\n      return {\n        id: google.id,\n        email,\n        name,\n        image,\n      };\n    }\n\n    const github = profile as GitHubProfileDto;\n    console.log(github, 'github normalizeProfile');\n    if (!github.email)\n      throw new Error('GitHub profile does not contain a valid email address.');\n\n    return {\n      id: github.id,\n      email: github.email,\n      name: github.name,\n      image: github.avatar_url,\n      login: github.login,\n    };\n  }\n\n  private async handleOAuthLogin(\n    provider: Provider,\n    profile: OAuthProfile,\n    tokens: OAuthTokens,\n  ) {\n    const { id: providerAccountId, email, name, image, login } = profile;\n    console.log(profile, 'profile handleOAuthLogin');\n    let user = await this.prisma.user.findUnique({ where: { email }, include: {\n       // Account: true,\n      } });\n\n    if (!user) {\n      user = await this.prisma.user.create({\n        data: {\n          email,\n          name: name || undefined,\n          image: image || undefined,\n          emailVerified: new Date(),\n          role: Role.USER,\n        },\n      });\n    } else if (!user.image && image) {\n      user = await this.prisma.user.update({\n        where: { id: user.id },\n        data: { image, username: login },\n      });\n    } else if (!user.username && login) {\n      user = await this.prisma.user.update({\n        where: { id: user.id },\n        data: { username: login },\n      });\n    }\n    \n    await this.prisma.account.upsert({\n      where: {\n        provider_providerAccountId: {\n          provider,\n          providerAccountId,\n        },\n      },\n      update: {\n        access_token: tokens.accessToken,\n        refresh_token: tokens.refreshToken,\n        id_token: tokens.idToken,\n        expires_at: tokens.expiresAt,\n        scope: tokens.scope,\n        token_type: tokens.tokenType,\n      },\n      create: {\n        provider,\n        providerAccountId,\n        type: 'oauth',\n        access_token: tokens.accessToken,\n        refresh_token: tokens.refreshToken,\n        id_token: tokens.idToken,\n        expires_at: tokens.expiresAt,\n        scope: tokens.scope,\n        token_type: tokens.tokenType,\n        createdBy: { connect: { id: user.id } },\n      },\n    });\n   // const u = user as CreateJwtUserDto;\n    \n    return user;\n  }\n}\n\n\n// File: src/auth/decorators/current-user.decorator.ts\nimport { createParamDecorator, ExecutionContext } from '@nestjs/common';\nimport { AuthRequest } from '../interfaces/auth-request.interface';\n\nexport const CurrentUser = createParamDecorator(\n  (_: unknown, ctx: ExecutionContext) => {\n    const request = ctx.switchToHttp().getRequest<AuthRequest>();\n    return request.user;\n  },\n);\n\n\n// File: src/auth/decorators/roles.decorator.ts\nimport { applyDecorators, SetMetadata } from '@nestjs/common';\nimport {\n  ApiBearerAuth,\n  ApiForbiddenResponse,\n  ApiUnauthorizedResponse,\n} from '@nestjs/swagger';\n\nexport const ROLES_KEY = 'roles';\nexport const Roles = (...roles: string[]) =>\n  applyDecorators(\n    SetMetadata(ROLES_KEY, roles),\n    ApiBearerAuth(), // for bearer token\n    ApiUnauthorizedResponse({ description: 'Unauthorized' }),\n    ApiForbiddenResponse({ description: 'Forbidden - insufficient role' }),\n  );\n\n\n// File: src/auth/dto/auth.dto.ts\n// src/auth/dto/auth.dto.ts\nimport { Role } from '@prisma/client';\nimport { ApiProperty } from '@nestjs/swagger';\nimport {\n  IsEmail,\n  IsNotEmpty,\n  MinLength,\n  IsOptional,\n  IsString,\n  IsEnum,\n} from 'class-validator';\n\nexport class RegisterDto {\n  @ApiProperty({ example: 'user@example.com' })\n  @IsEmail()\n  email: string;\n\n  @ApiProperty({ example: 'StrongPassword123' })\n  @IsNotEmpty()\n  @MinLength(8)\n  password: string;\n\n  @ApiProperty({ example: 'John Doe', required: false })\n  @IsOptional()\n  name: string;\n\n  @ApiProperty({ example: '+1234567890', required: false })\n  @IsOptional()\n  phone_number?: string;\n\n  @ApiProperty({ example: 'USER', required: false })\n  @IsOptional()\n  @IsEnum(Role)\n  role?: Role;\n}\nexport class CreateJwtUserDto {\n  @ApiProperty({\n    description: 'JQT User identifier',\n    example: '21jdh-jsdhd-jasjasd',\n  })\n  @IsString()\n  id?: string;\n\n  @ApiProperty({ example: '21jdh-jsdhd-jasjasd' })\n  @IsString()\n  sub: string;\n\n  @ApiProperty({ example: 'user@example.com' })\n  @IsEmail()\n  email: string;\n\n  @ApiProperty({ example: 'John Doe', required: false })\n  @IsOptional()\n  name?: string;\n\n  @ApiProperty({ example: '+1234567890', required: false })\n  @IsOptional()\n  phone_number?: string;\n\n  @ApiProperty({ example: 'USER', required: false })\n  @IsOptional()\n  @IsEnum(Role)\n  role: Role;\n\n  @ApiProperty({ example: 'john.jpg', required: false })\n  @IsOptional()\n  image?: string;\n\n  @ApiProperty({ example: 'Google', required: false })\n  @IsOptional()\n  provider?: string;\n\n  @ApiProperty({ example: '32131dqewewqe', required: false })\n  @IsOptional()\n  tokens?: any;\n  @ApiProperty({ example: 'user01', required: false })\n  @IsOptional()\n  username?: any;\n}\nexport class LoginDto {\n  @ApiProperty({ example: 'user@example.com' })\n  @IsEmail()\n  email: string;\n\n  @ApiProperty({ example: 'StrongPassword123' })\n  @IsNotEmpty()\n  password: string;\n}\n\n\n// File: src/auth/dto/email-verification-response.dto.ts\n// src/auth/dto/email-verification-response.dto.ts\nimport { ApiProperty } from '@nestjs/swagger';\n\nexport class EmailVerificationResponseDto {\n  @ApiProperty({ example: 'Email verified successfully.' })\n  message: string;\n}\n\n\n// File: src/auth/dto/github-profile.dto.ts\n// src/auth/dto/github-profile.dto.ts\nimport {\n  IsArray,\n  IsOptional,\n  IsString,\n  IsEmail,\n  IsUrl,\n  ValidateNested,\n} from 'class-validator';\nimport { Type } from 'class-transformer';\nimport { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';\n\nexport class GitHubProfileDto {\n  @ApiProperty({ example: '12345678' })\n  @IsString()\n  id: string;\n\n  @ApiProperty({ example: 'octocat' })\n  @IsString()\n  login: string;\n\n  @ApiPropertyOptional({ example: 'The Octocat' })\n  @IsOptional()\n  @IsString()\n  name?: string;\n\n  @ApiPropertyOptional({ example: 'octocat@github.com' })\n  @IsOptional()\n  @IsString()\n  email?: string;\n\n  @ApiPropertyOptional({\n    example: 'https://avatars.githubusercontent.com/u/12345678?v=4',\n  })\n  @IsOptional()\n  @IsUrl()\n  avatar_url?: string;\n\n  @ApiPropertyOptional({ example: 'github' })\n  @IsOptional()\n  @IsString()\n  provider?: string;\n}\n\nexport class GitHubTokenDto {\n  @ApiProperty()\n  @IsString()\n  accessToken: string;\n\n  @ApiPropertyOptional()\n  @IsOptional()\n  @IsString()\n  refreshToken?: string;\n\n  @ApiPropertyOptional()\n  @IsOptional()\n  @IsString()\n  scope?: string;\n\n  @ApiPropertyOptional()\n  @IsOptional()\n  @IsString()\n  tokenType?: string;\n}\n\n\n// File: src/auth/dto/google-profile.dto.ts\n// src/auth/dto/google-profile.dto.ts\nimport {\n  IsArray,\n  IsOptional,\n  IsString,\n  IsEmail,\n  IsUrl,\n  ValidateNested,\n} from 'class-validator';\nimport { Type } from 'class-transformer';\nimport { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';\n\nclass GoogleNameDto {\n  @ApiPropertyOptional({ example: 'Doe' })\n  @IsOptional()\n  @IsString()\n  familyName?: string;\n\n  @ApiPropertyOptional({ example: 'John' })\n  @IsOptional()\n  @IsString()\n  givenName?: string;\n}\n\nclass GoogleEmailDto {\n  @ApiProperty({ example: 'john.doe@gmail.com' })\n  @IsEmail()\n  value: string;\n\n  @ApiPropertyOptional({ example: true })\n  @IsOptional()\n  verified?: boolean;\n}\n\nclass GooglePhotoDto {\n  @ApiProperty({ example: 'https://lh3.googleusercontent.com/a-/photo.jpg' })\n  @IsUrl()\n  value: string;\n}\n\nexport class GoogleProfileDto {\n  @ApiProperty({ example: '112233445566778899001' })\n  @IsString()\n  id: string;\n\n  @ApiPropertyOptional({ example: 'John Doe' })\n  @IsOptional()\n  @IsString()\n  displayName?: string;\n\n  @ApiPropertyOptional({ type: GoogleNameDto })\n  @IsOptional()\n  @ValidateNested()\n  @Type(() => GoogleNameDto)\n  name?: GoogleNameDto;\n\n  @ApiPropertyOptional({ type: [GoogleEmailDto] })\n  @IsOptional()\n  @IsArray()\n  @ValidateNested({ each: true })\n  @Type(() => GoogleEmailDto)\n  emails?: GoogleEmailDto[];\n\n  @ApiPropertyOptional({ type: [GooglePhotoDto] })\n  @IsOptional()\n  @IsArray()\n  @ValidateNested({ each: true })\n  @Type(() => GooglePhotoDto)\n  photos?: GooglePhotoDto[];\n\n  @ApiPropertyOptional({ example: 'google' })\n  @IsOptional()\n  @IsString()\n  provider?: string;\n}\n\n\n// File: src/auth/dto/google-token.dto.ts\n// src/auth/dto/google-token.dto.ts\nimport { IsOptional, IsString, IsNumber } from 'class-validator';\nimport { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';\n\nexport class GoogleTokenDto {\n  @ApiProperty({ example: 'ya29.a0AVvZVt...' })\n  @IsString()\n  accessToken: string;\n\n  @ApiPropertyOptional({ example: '1//0gJ7xyz...' })\n  @IsOptional()\n  @IsString()\n  refreshToken?: string;\n\n  @ApiPropertyOptional({ example: 'eyJhbGciOiJSUzI1NiIsInR...' })\n  @IsOptional()\n  @IsString()\n  idToken?: string;\n\n  @ApiPropertyOptional({ example: 1715881745 })\n  @IsOptional()\n  @IsNumber()\n  expiresAt?: number;\n\n  @ApiPropertyOptional({ example: 'profile email' })\n  @IsOptional()\n  @IsString()\n  scope?: string;\n\n  @ApiPropertyOptional({ example: 'Bearer' })\n  @IsOptional()\n  @IsString()\n  tokenType?: string;\n}\n\n\n// File: src/auth/dto/verify-email.dto.ts\n// src/auth/dto/verify-email.dto.ts\nimport { IsString } from 'class-validator';\nimport { ApiProperty } from '@nestjs/swagger';\n\nexport class VerifyEmailDto {\n  @ApiProperty({\n    description: 'JWT token for email verification',\n    example: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...',\n  })\n  @IsString()\n  token: string;\n}\n\n\n// File: src/auth/enums/user-role.enum.ts\nexport enum UserRole {\n  ADMIN = 'ADMIN',\n  USER = 'USER',\n  MANAGER = 'MANAGER',\n  SUPERADMIN = 'SUPERADMIN',\n  // add more as needed\n}\n\n\n// File: src/auth/guards/github.guard.ts\n// src/auth/guards/google.guard.ts\nimport { Injectable } from '@nestjs/common';\nimport { AuthGuard } from '@nestjs/passport';\nimport { ExecutionContext } from '@nestjs/common';\n\n@Injectable()\nexport class GitHubAuthGuard extends AuthGuard('github') {\n  canActivate(context: ExecutionContext) {\n    return super.canActivate(context);\n  }\n\n  handleRequest(err: any, user: any, info: any, context: any) {\n    if (err || !user) {\n      throw err || new Error('Unauthorized');\n    }\n    return user;\n  }\n}\n\n\n// File: src/auth/guards/google.guard.ts\n// src/auth/guards/google.guard.ts\nimport { Injectable } from '@nestjs/common';\nimport { AuthGuard } from '@nestjs/passport';\nimport { ExecutionContext } from '@nestjs/common';\n\n@Injectable()\nexport class GoogleAuthGuard extends AuthGuard('google') {\n  canActivate(context: ExecutionContext) {\n    return super.canActivate(context);\n  }\n\n  handleRequest(err: any, user: any, info: any, context: any) {\n    if (err || !user) {\n      throw err || new Error('Unauthorized');\n    }\n    return user;\n  }\n}\n\n\n// File: src/auth/guards/roles.guard.ts\nimport {\n  CanActivate,\n  ExecutionContext,\n  ForbiddenException,\n  Injectable,\n} from '@nestjs/common';\nimport { Reflector } from '@nestjs/core';\nimport { Role } from '@prisma/client'; // or wherever your Role enum is\n\n@Injectable()\nexport class RolesGuard implements CanActivate {\n  constructor(private reflector: Reflector) {}\n\n  canActivate(context: ExecutionContext): boolean {\n    const requiredRoles = this.reflector.getAllAndOverride<Role[]>('roles', [\n      context.getHandler(),\n      context.getClass(),\n    ]);\n\n    if (!requiredRoles || requiredRoles.length === 0) {\n      return true; // No roles required → public access\n    }\n\n    const request = context.switchToHttp().getRequest();\n    const user = request.user;\n\n    if (!user || !user.role || !requiredRoles.includes(user.role)) {\n      throw new ForbiddenException('Access denied: insufficient role');\n    }\n\n    return true;\n  }\n}\n\n\n// File: src/auth/interfaces/auth-request.interface.ts\nimport { Request } from 'express';\nimport { User } from '@prisma/client';\n\nexport interface AuthRequest extends Request {\n  user: Partial<Pick<User, 'id' | 'email' | 'name' | 'role' | 'username'>>;\n  provider?: 'github'|'google';\n  providerToken?: string;\n}\n\n\n// File: src/auth/interfaces/github-profile.interface.ts\n // Define a basic structure for the GitHub profile returned by passport-github\nexport interface GitHubProfile {\n    id: string; // GitHub user ID (string)\n    nodeId: string;\n    displayName: string;\n    username: string;\n    profileUrl: string;\n    photos: [{ value: string }]; // Array of photo URLs\n    provider: string; // 'github'\n    _raw: string; // Raw JSON response from GitHub\n    _json: any; // Parsed JSON response from GitHub\n}\n\n// User object to be stored in memory and passed around\nexport interface User {\n    id: string; // Internal user ID\n    githubId: string; // GitHub user ID (numeric string)\n    username: string;\n    email: string;\n    githubAccessToken: string; // The token we need for API calls\n    displayName: string;\n}\n\n\n// File: src/auth/interfaces/jwt-payload.interface.ts\nimport { Role } from '@prisma/client';\n\nexport interface JwtPayload {\n  sub: string; // user.id is a string\n  email: string; // user.email is a string\n  role: Role; // assign a fallback elsewhere, not in the type\n  name?: string; // optional\n  provider?: 'google' | 'github'; // optional\n}\n\n\n// File: src/auth/strategies/github.strategy.ts\n// src/auth/strategies/github.strategy.ts\nimport { PassportStrategy } from '@nestjs/passport';\nimport { Injectable } from '@nestjs/common';\nimport { Strategy, VerifyCallback } from 'passport-github2';\nimport { GitHubProfileDto, GitHubTokenDto } from '../dto/github-profile.dto';\n\n@Injectable()\nexport class GitHubStrategy extends PassportStrategy(Strategy, 'github') {\n  constructor() {\n    super({\n      clientID: process.env.GITHUB_CLIENT_ID,\n      clientSecret: process.env.GITHUB_CLIENT_SECRET,\n      callbackURL: process.env.GITHUB_CALLBACK_URL,\n      scope: ['user:email'],\n    });\n  }\n\n  async validate(\n    accessToken: string,\n    refreshToken: string,\n    profile: any,\n    done: VerifyCallback,\n  ): Promise<void> {\n    const { id, login, displayName, emails, photos, provider } = profile;\n\n    // Construct typed DTOs\n    const profileDto: GitHubProfileDto = {\n      id,\n      login,\n      name: displayName,\n      provider,\n      email: emails?.[0]?.value,\n      avatar_url: photos?.[0]?.value,\n      \n    };\n\n    const tokenDto: GitHubTokenDto = {\n      accessToken,\n      refreshToken,\n      scope: profile._scope || null,\n      tokenType: profile._tokenType || null,\n    };\n\n    done(null, { profile: profileDto, tokens: tokenDto });\n  }\n}\n\n\n// File: src/auth/strategies/google.strategy.ts\nimport { PassportStrategy } from '@nestjs/passport';\nimport { Injectable } from '@nestjs/common';\nimport { Strategy, VerifyCallback } from 'passport-google-oauth20';\nimport { GoogleProfileDto } from '../dto/google-profile.dto';\nimport { GoogleTokenDto } from '../dto/google-token.dto';\n\n@Injectable()\nexport class GoogleStrategy extends PassportStrategy(Strategy, 'google') {\n  constructor() {\n    super({\n      clientID: process.env.GOOGLE_CLIENT_ID,\n      clientSecret: process.env.GOOGLE_CLIENT_SECRET,\n      callbackURL: process.env.GOOGLE_CALLBACK_URL,\n      scope: ['email', 'profile'],\n    });\n  }\n\n  async validate(\n    accessToken: string,\n    refreshToken: string,\n    profile: any,\n    done: VerifyCallback,\n  ): Promise<void> {\n    const { id, name, emails, photos, provider } = profile;\n\n    // Construct typed DTOs\n    const profileDto: GoogleProfileDto = {\n      id,\n      displayName: profile.displayName,\n      provider,\n      name: {\n        familyName: name.familyName,\n        givenName: name.givenName,\n      },\n      emails: emails?.map((e: any) => ({ value: e.value })) || [],\n      photos: photos?.map((p: any) => ({ value: p.value })) || [],\n    };\n\n    const tokenDto: GoogleTokenDto = {\n      accessToken,\n      refreshToken,\n      idToken: profile.id_token, // in case it's included\n      expiresAt: profile._json?.exp || null,\n      scope: profile.scope || null,\n      tokenType: profile.token_type || null,\n    };\n\n    done(null, { profile: profileDto, tokens: tokenDto });\n  }\n}\n\n```\n",
  "rawLLMResponse": {
    "summary": "Standardized OAuth callback redirect URLs for Google and GitHub, ensuring consistent query parameters including username and provider, and robustly encoding URL components.",
    "thoughtProcess": "The user reported issues with Google and GitHub OAuth callbacks. Upon inspection, the redirect URLs for Google and GitHub were found to have slight inconsistencies in their query parameters (e.g., username was present for GitHub but not Google). Additionally, URL parameters were not being `encodeURIComponent`-ed, which could lead to issues with special characters. The core `handleOAuthCallback` method correctly processes the OAuth profile into a `Prisma.User` object, which already includes a `username` field (nullable). The `CreateJwtUserDto` also supports a `username` property for the JWT payload.\n\nThe fix involves:\n1.  Modifying `src/auth/auth.controller.ts`.\n2.  Ensuring both `googleAuthRedirect` and `githubAuthRedirect` append `username` and `provider` to the redirect URL query parameters.\n3.  Applying `encodeURIComponent` to all string values passed as query parameters to prevent URL parsing issues.\n4.  Refining the type of the `user` object returned by `handleOAuthCallback` to be `Prisma.User` for better type safety.",
    "changes": [
      {
        "filePath": "src/auth/auth.controller.ts",
        "action": "modify",
        "newContent": "import {\n  Controller,\n  Post,\n  Body,\n  Res,\n  UseGuards,\n  Get,\n  Req,\n  BadRequestException,\n  Query,\n  NotFoundException,\n  Redirect,\n} from '@nestjs/common';\nimport {\n  ApiTags,\n  ApiOperation,\n  ApiResponse,\n  ApiBearerAuth,\n  ApiQuery,\n  ApiBody,\n} from '@nestjs/swagger';\nimport { JwtService } from '@nestjs/jwt';\nimport { PrismaService } from '../prisma/prisma.service';\nimport { MailService } from '../mail/mail.service';\nimport { AuthService } from './auth.service';\nimport { RegisterDto, LoginDto, CreateJwtUserDto } from './dto/auth.dto';\nimport { VerifyEmailDto } from './dto/verify-email.dto';\nimport { AuthRequest } from './interfaces/auth-request.interface';\nimport { GoogleAuthGuard } from './guards/google.guard';\nimport { GitHubAuthGuard } from './guards/github.guard';\nimport { JwtAuthGuard } from './auth.guard';\nimport { Response, Request } from 'express';\nimport { GitHubProfileDto, GitHubTokenDto } from './dto/github-profile.dto';\nimport { GoogleProfileDto } from './dto/google-profile.dto';\nimport { GoogleTokenDto } from './dto/google-token.dto';\nimport { UserRole } from './enums/user-role.enum';\nimport { Role, User } from '@prisma/client';\n\n\n/**\n * AuthController handles authentication-related endpoints, including user registration,\n * login, logout, email verification, and OAuth2 authentication with Google and GitHub.\n *\n * @ApiTags Auth\n * @Controller api/auth\n */\n@ApiTags('Auth')\n@Controller('api/auth')\nexport class AuthController {\n  constructor(\n    private readonly authService: AuthService,\n    private readonly prisma: PrismaService,\n    private readonly mailService: MailService,\n  ) {}\n\n  /**\n   * Handles the OAuth2 callback from Google or GitHub, validating the profile,\n   * generating a JWT token, and returning the access token and user information.\n   *\n   * @private\n   * @async\n   * @function handleOAuthCallback\n   * @param {('google' | 'github')} provider - The OAuth2 provider (either 'google' or 'github').\n   * @param {AuthRequest} req - The request object containing user profile and tokens.\n   * @returns {Promise<{ accessToken: string; user: any }>} - A promise that resolves to an object\n   * containing the access token and user information.  The user object type is 'any' because the\n   * specific profile type will depend on the OAuth2 provider.\n   */\n  private async handleOAuthCallback(\n    provider: 'google' | 'github',\n    req: AuthRequest,\n  ): Promise<{ accessToken: string; user: User, profile?: GoogleProfileDto | GitHubProfileDto, tokens: GoogleTokenDto | GitHubTokenDto } > {\n    const { profile, tokens } = req.user as {\n      profile: GoogleProfileDto | GitHubProfileDto;\n      tokens: GoogleTokenDto | GitHubTokenDto;\n     // provider: 'google' | 'github';\n    };\n\n    const user  = await this.authService.validateOAuthProfile(\n      provider,\n      profile,\n      tokens,\n    );\n\n    const payload: CreateJwtUserDto = {\n      id: user.id,\n      sub: user.id,\n      email: user.email,\n      role: user.role ?? Role.USER,\n      image: user.image ?? undefined,\n      name: user.name ?? '',\n      phone_number: user.phone_number ?? '',\n      provider,\n      username: user.username ?? undefined, // Include username in JWT payload\n     // tokens,\n      \n    };\n\n    const accessToken = await this.authService.generateToken(payload);\n  \n    return { accessToken, user, profile, tokens };\n  }\n\n  /**\n   * Logs in a user and sets a JWT cookie.\n   *\n   * @Post login\n   * @ApiOperation summary Log in a user and set JWT cookie\n   * @ApiResponse status 200 - User logged in successfully\n   * @ApiResponse status 401 - Invalid credentials\n   * @async\n   * @function login\n   * @param {LoginDto} dto - The login credentials data transfer object.\n   * @param {Response} res - The Express response object for setting cookies.\n   * @returns {Promise<any>} - A promise that resolves to the user information.  The user object type is 'any' because the\n   * specific shape may depend on the authentication strategy.\n   */\n  @Post('login')\n  @ApiOperation({ summary: 'Log in a user and set JWT cookie' })\n  @ApiResponse({ status: 200, description: 'User logged in successfully' })\n  @ApiResponse({ status: 401, description: 'Invalid credentials' })\n  async login(\n    @Body() dto: LoginDto,\n    @Res({ passthrough: true }) res: Response,\n  ) {\n    const user = await this.authService.login(dto);\n    res.cookie('accessToken', user.accessToken, {\n      httpOnly: true,\n      secure: process.env.NODE_ENV === 'production',\n      sameSite: 'lax',\n    });\n    return user;\n  }\n\n  /**\n   * Logs out a user by clearing the JWT cookie.\n   *\n   * @Post logout\n   * @ApiOperation summary Log out user (clear cookie)\n   * @ApiResponse status 200 - Logged out successfully\n   * @async\n   * @function logout\n   * @param {Response} res - The Express response object for clearing cookies.\n   * @returns {Promise<{ message: string }>} - A promise that resolves to a success message.\n   */\n  @Post('logout')\n  @ApiOperation({ summary: 'Log out user (clear cookie)' })\n  @ApiResponse({ status: 200, description: 'Logged out successfully' })\n  async logout(@Res({ passthrough: true }) res: Response) {\n    res.clearCookie('accessToken');\n    return { message: 'Logged out successfully' };\n  }\n\n  /**\n   * Initiates the GitHub OAuth2 login flow.\n   *\n   * @Get github\n   * @UseGuards GitHubAuthGuard\n   * @ApiOperation summary Initiate GitHub OAuth2 login\n   * @ApiResponse status 302 - Redirects to GitHub login\n   * @async\n   * @function githubAuth\n   */\n  @Get('github')\n  @UseGuards(GitHubAuthGuard)\n  @ApiOperation({ summary: 'Initiate GitHub OAuth2 login' })\n  @ApiResponse({ status: 302, description: 'Redirects to GitHub login' })\n  async githubAuth() {\n    // OAuth2 login flow initiated by Passport\n  }\n\n  /**\n   * Handles the GitHub OAuth2 callback, issues a JWT token, and redirects the user.\n   *\n   * @Get github/callback\n   * @UseGuards GitHubAuthGuard\n   * @ApiOperation summary Handle GitHub OAuth2 callback and issue JWT token\n   * @ApiResponse status 200 - GitHub login successful with JWT issued\n   * @ApiResponse status 401 - Unauthorized or failed login attempt\n   * @async\n   * @function githubAuthRedirect\n   * @param {AuthRequest} req - The request object containing user information from GitHub.\n   * @param {Response} res - The Express response object for setting cookies and redirecting.\n   * @returns {Promise<any>} - A promise that resolves after redirecting the user.\n   */\n  @Get('github/callback')\n  @UseGuards(GitHubAuthGuard)\n  @ApiOperation({\n    summary: 'Handle GitHub OAuth2 callback and issue JWT token',\n  })\n  @ApiResponse({\n    status: 200,\n    description: 'GitHub login successful with JWT issued',\n  })\n  @ApiResponse({\n    status: 401,\n    description: 'Unauthorized or failed login attempt',\n  })\n  async githubAuthRedirect(@Req() req: AuthRequest, @Res() res: Response) {\n    try {\n      const { accessToken, user, profile, tokens } = await this.handleOAuthCallback(\n        'github',\n        req,\n      );\n\n      res.cookie('accessToken', accessToken, {\n        httpOnly: true,\n        secure: process.env.NODE_ENV === 'production',\n        sameSite: 'lax',\n      });\n\n      return res.redirect(\n        `${process.env.FRONTEND_URL}/login?action=success&accessToken=${accessToken}&userId=${user.id}&userEmail=${user.email}&userName=${encodeURIComponent(user.name || '')}&userImage=${encodeURIComponent(user.image || '')}&userRole=${user.role}&username=${encodeURIComponent(user.username || '')}&provider=github`,\n      );\n    } catch (error) {\n      console.error('OAuth redirect error:', error);\n      return res.redirect('/login?error=OAuth%20Login%20Failed');\n    }\n  }\n\n  /**\n   * Initiates the Google OAuth2 login flow.\n   *\n   * @Get google\n   * @UseGuards GoogleAuthGuard\n   * @ApiOperation summary Initiate Google OAuth2 login\n   * @ApiResponse status 302 - Redirects to Google login\n   * @async\n   * @function googleAuth\n   */\n  @Get('google')\n  @UseGuards(GoogleAuthGuard)\n  @ApiOperation({ summary: 'Initiate Google OAuth2 login' })\n  @ApiResponse({ status: 302, description: 'Redirects to Google login' })\n  async googleAuth() {\n    // OAuth2 login flow initiated by Passport\n  }\n\n  /**\n   * Handles the Google OAuth2 callback, issues a JWT token, and redirects the user.\n   *\n   * @Get google/callback\n   * @UseGuards GoogleAuthGuard\n   * @ApiOperation summary Handle Google OAuth2 callback and issue JWT token\n   * @ApiResponse status 200 - Google login successful with JWT issued\n   * @ApiResponse status 401 - Unauthorized or failed login attempt\n   * @async\n   * @function googleAuthRedirect\n   * @param {AuthRequest} req - The request object containing user information from Google.\n   * @param {Response} res - The Express response object for setting cookies and redirecting.\n   * @returns {Promise<any>} - A promise that resolves after redirecting the user.\n   */\n  @Get('google/callback')\n  @UseGuards(GoogleAuthGuard)\n  @ApiOperation({\n    summary: 'Handle Google OAuth2 callback and issue JWT token',\n  })\n  @ApiResponse({\n    status: 200,\n    description: 'Google login successful with JWT issued',\n  })\n  @ApiResponse({\n    status: 401,\n    description: 'Unauthorized or failed login attempt',\n  })\n  async googleAuthRedirect(@Req() req: AuthRequest, @Res() res: Response) {\n    try {\n      const { accessToken, user } = await this.handleOAuthCallback(\n        'google',\n        req,\n      );\n\n      res.cookie('accessToken', accessToken, {\n        httpOnly: true,\n        secure: process.env.NODE_ENV === 'production',\n        sameSite: 'lax',\n      });\n      //localStorage.setItem('accessToken', accessToken);\n      ///localStorage.setItem('user', JSON.stringify(user));\n      return res.redirect(\n        `${process.env.FRONTEND_URL}/login?action=success&accessToken=${accessToken}&userId=${user.id}&userEmail=${user.email}&userName=${encodeURIComponent(user.name || '')}&userImage=${encodeURIComponent(user.image || '')}&userRole=${user.role}&username=${encodeURIComponent(user.username || '')}&provider=google`,\n      );\n    } catch (error) {\n      console.error('OAuth redirect error:', error);\n      return res.redirect('/login?error=OAuth%20Login%20Failed');\n    }\n  }\n\n  /**\n   * Registers a new user.\n   *\n   * @Post register\n   * @ApiOperation summary Register a new user\n   * @ApiResponse status 201 - User registered successfully\n   * @ApiResponse status 400 - Validation failed or user already exists\n   * @async\n   * @function register\n   * @param {RegisterDto} dto - The registration data transfer object.\n   * @returns {Promise<void>} - A promise that resolves when registration is complete.\n   */\n  @Post('register')\n  @ApiOperation({ summary: 'Register a new user' })\n  @ApiResponse({ status: 201, description: 'User registered successfully' })\n  @ApiResponse({\n    status: 400,\n    description: 'Validation failed or user already exists',\n  })\n  async register(@Body() dto: RegisterDto): Promise<void> {\n    await this.authService.register(dto);\n  }\n\n  /**\n   * Resends the email verification link to the user.\n   *\n   * @Post resend-verification\n   * @ApiOperation summary Resend email verification link\n   * @ApiBody schema containing the user's email address.\n   * @async\n   * @function resendVerification\n   * @param {string} email - The email address of the user.\n   * @returns {Promise<any>} - A promise that resolves with the result of resending verification.  The result type is 'any'\n   * because the structure of the response from the mail service can vary.\n   */\n  @Post('resend-verification')\n  @ApiOperation({ summary: 'Resend email verification link' })\n  @ApiBody({\n    schema: {\n      properties: { email: { type: 'string', example: 'user@example.com' } },\n    },\n  })\n  async resendVerification(@Body('email') email: string) {\n    return this.authService.resendVerification(email);\n  }\n\n  /**\n   * Verifies the user's email address using the provided token.\n   *\n   * @Get verify-email\n   * @ApiOperation summary Verify user email address\n   * @ApiResponse status 200 - Email verified successfully\n   * @ApiResponse status 400 - Invalid or expired token\n   * @async\n   * @function verifyEmail\n   * @param {VerifyEmailDto} query - The query parameters containing the verification token.\n   * @returns {Promise<any>} - A promise that resolves with the result of email verification.  The result type is 'any' because\n   * the response format can depend on the implementation of the verification service.\n   */\n  @Get('verify-email')\n  @ApiOperation({ summary: 'Verify user email address' })\n  @ApiResponse({ status: 200, description: 'Email verified successfully' })\n  @ApiResponse({ status: 400, description: 'Invalid or expired token' })\n  async verifyEmail(@Query() query: VerifyEmailDto) {\n    return this.authService.verifyEmail(query.token);\n  }\n\n  /**\n   * Gets the profile of the currently authenticated user.\n   *\n   * @Get me\n   * @UseGuards JwtAuthGuard\n   * @ApiBearerAuth\n   * @ApiOperation summary Get current authenticated user\n   * @ApiResponse status 200 - User profile returned\n   * @ApiResponse status 401 - Unauthorized\n   * @async\n   * @function getProfile\n   * @param {Request} req - The request object containing the user information.\n   * @returns {Promise<any>} - A promise that resolves with the user profile.  The user profile type is 'any' because the shape\n   * can vary based on the data stored about the user.\n   */\n  @UseGuards(JwtAuthGuard)\n  @Get('me')\n  @ApiBearerAuth()\n  @ApiOperation({ summary: 'Get current authenticated user' })\n  @ApiResponse({ status: 200, description: 'User profile returned' })\n  @ApiResponse({ status: 401, description: 'Unauthorized' })\n  async getProfile(@Req() req: Request) {\n    const meR = req['user'];\n    if(meR.email){\n       const getAccount = this.prisma.user.findUnique({\n      where: { email: meR?.email },\n      include: {\n        Account: true,\n      },\n    });\n    if(getAccount){\n     \n    return getAccount;\n    } else {\n      return meR;\n    }\n    \n    }\n   \n  }\n}\n"
      }
    ]
  }
}
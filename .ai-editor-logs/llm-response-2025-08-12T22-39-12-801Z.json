{
  "timestamp": "2025-08-12T22:39:12.801Z",
  "prompt": "\n# AI Code Generation Request\n\n## User Request\n```text\nAdd oauth authentication for the ai-editor cli\n```\n\n## Project Context\n  - ../\n    - ../ai-assistant/\n      - ../ai-assistant/ai-editor/\n        - ../ai-assistant/ai-editor/src/\n          - ../ai-assistant/ai-editor/src/constants.ts\n          - ../ai-assistant/ai-editor/src/file-operations/\n            - ../ai-assistant/ai-editor/src/file-operations/diffGenerator.ts\n            - ../ai-assistant/ai-editor/src/file-operations/fileApplier.ts\n          - ../ai-assistant/ai-editor/src/git-operations/\n            - ../ai-assistant/ai-editor/src/git-operations/gitManager.ts\n          - ../ai-assistant/ai-editor/src/index.ts\n          - ../ai-assistant/ai-editor/src/llm/\n            - ../ai-assistant/ai-editor/src/llm/contextPreparer.ts\n            - ../ai-assistant/ai-editor/src/llm/jsonRepair.ts\n            - ../ai-assistant/ai-editor/src/llm/llmOrchestrator.ts\n          - ../ai-assistant/ai-editor/src/scanner.ts\n          - ../ai-assistant/ai-editor/src/types.ts\n  - src/\n    - src/auth/\n      - src/auth/auth-google.controller.ts\n      - src/auth/auth.controller.ts\n      - src/auth/auth.guard.ts\n      - src/auth/auth.module.ts\n      - src/auth/auth.service.ts\n      - src/auth/auth.strategy.ts\n      - src/auth/decorators/\n        - src/auth/decorators/current-user.decorator.ts\n        - src/auth/decorators/roles.decorator.ts\n      - src/auth/dto/\n        - src/auth/dto/auth.dto.ts\n        - src/auth/dto/email-verification-response.dto.ts\n        - src/auth/dto/github-profile.dto.ts\n        - src/auth/dto/google-profile.dto.ts\n        - src/auth/dto/google-token.dto.ts\n        - src/auth/dto/verify-email.dto.ts\n      - src/auth/enums/\n        - src/auth/enums/user-role.enum.ts\n      - src/auth/guards/\n        - src/auth/guards/github.guard.ts\n        - src/auth/guards/google.guard.ts\n        - src/auth/guards/roles.guard.ts\n      - src/auth/interfaces/\n        - src/auth/interfaces/auth-request.interface.ts\n        - src/auth/interfaces/github-profile.interface.ts\n        - src/auth/interfaces/jwt-payload.interface.ts\n      - src/auth/oauth.service.ts\n      - src/auth/strategies/\n        - src/auth/strategies/github.strategy.ts\n        - src/auth/strategies/google.strategy.ts\n\n### Relevant Files (for analysis)\n```files\n// File: src/auth/auth-google.controller.ts\nimport {\n  Controller,\n  Post,\n  Body,\n  Res,\n  UseGuards,\n  Get,\n  Req,\n  BadRequestException,\n  Query,\n  NotFoundException,\n} from '@nestjs/common';\nimport {\n  ApiTags,\n  ApiOperation,\n  ApiResponse,\n  ApiBearerAuth,\n  ApiQuery,\n  ApiBody,\n} from '@nestjs/swagger';\nimport { JwtService } from '@nestjs/jwt';\nimport { PrismaService } from '../prisma/prisma.service';\nimport { MailService } from '../mail/mail.service';\nimport { AuthService } from './auth.service';\nimport { RegisterDto, LoginDto, CreateJwtUserDto } from './dto/auth.dto';\nimport { VerifyEmailDto } from './dto/verify-email.dto';\n\nimport { GoogleAuthGuard } from './guards/google.guard';\nimport { JwtAuthGuard } from './auth.guard';\nimport { Response, Request } from 'express';\n\n@ApiTags('Auth')\n@Controller('api/auth-google')\nexport class AuthController {\n  constructor(\n    private readonly authService: AuthService,\n    private readonly prisma: PrismaService,\n    private readonly mailService: MailService,\n  ) {}\n  /*@Get('google')\n  @UseGuards(GoogleAuthGuard)\n  @ApiOperation({ summary: 'Initiate Google OAuth2 login' })\n  @ApiResponse({ status: 302, description: 'Redirects to Google login' })\n  async googleAuth() {\n    // Initiates the Google OAuth2 login flow\n  }\n\n  @Get('google/callback')\n  @UseGuards(GoogleAuthGuard)\n  @ApiOperation({ summary: 'Handle Google OAuth2 callback and issue JWT token' })\n  @ApiResponse({ status: 200, description: 'Google login successful with JWT issued' })\n  @ApiResponse({ status: 401, description: 'Unauthorized or failed login attempt' })\n  async googleAuthRedirect(@Req() req: Request, @Res() res: Response) {\n    const user = req.user;\n\n    const payload = {\n      sub: user.id,\n      email: user.email,\n      role: user.role,\n    };\n\n    const accessToken  = await this.authService.generateToken(payload);\n    res.cookie('accessToken', accessToken, {\n      httpOnly: true,\n      secure: process.env.NODE_ENV === 'production',\n      sameSite: 'lax',\n    });\n\n\n    return res.json({\n      message: 'Google login successful',\n      token,\n      user,\n    });\n  }*/\n}\n\n\n// File: src/auth/auth.controller.ts\nimport {\n  Controller,\n  Post,\n  Body,\n  Res,\n  UseGuards,\n  Get,\n  Req,\n  BadRequestException,\n  Query,\n  NotFoundException,\n  Redirect,\n} from '@nestjs/common';\nimport {\n  ApiTags,\n  ApiOperation,\n  ApiResponse,\n  ApiBearerAuth,\n  ApiQuery,\n  ApiBody,\n} from '@nestjs/swagger';\nimport { JwtService } from '@nestjs/jwt';\nimport { PrismaService } from '../prisma/prisma.service';\nimport { MailService } from '../mail/mail.service';\nimport { AuthService } from './auth.service';\nimport { RegisterDto, LoginDto, CreateJwtUserDto } from './dto/auth.dto';\nimport { VerifyEmailDto } from './dto/verify-email.dto';\nimport { AuthRequest } from './interfaces/auth-request.interface';\nimport { GoogleAuthGuard } from './guards/google.guard';\nimport { GitHubAuthGuard } from './guards/github.guard';\nimport { JwtAuthGuard } from './auth.guard';\nimport { Response, Request } from 'express';\nimport { GitHubProfileDto, GitHubTokenDto } from './dto/github-profile.dto';\nimport { GoogleProfileDto } from './dto/google-profile.dto';\nimport { GoogleTokenDto } from './dto/google-token.dto';\nimport { UserRole } from './enums/user-role.enum';\nimport { Role, User } from '@prisma/client';\n\n\n/**\n * AuthController handles authentication-related endpoints, including user registration,\n * login, logout, email verification, and OAuth2 authentication with Google and GitHub.\n *\n * @ApiTags Auth\n * @Controller api/auth\n */\n@ApiTags('Auth')\n@Controller('api/auth')\nexport class AuthController {\n  constructor(\n    private readonly authService: AuthService,\n    private readonly prisma: PrismaService,\n    private readonly mailService: MailService,\n  ) {}\n\n  /**\n   * Handles the OAuth2 callback from Google or GitHub, validating the profile,\n   * generating a JWT token, and returning the access token and user information.\n   *\n   * @private\n   * @async\n   * @function handleOAuthCallback\n   * @param {('google' | 'github')} provider - The OAuth2 provider (either 'google' or 'github').\n   * @param {AuthRequest} req - The request object containing user profile and tokens.\n   * @returns {Promise<{ accessToken: string; user: any }>} - A promise that resolves to an object\n   * containing the access token and user information.  The user object type is 'any' because the\n   * specific profile type will depend on the OAuth2 provider.\n   */\n  private async handleOAuthCallback(\n    provider: 'google' | 'github',\n    req: AuthRequest,\n  ): Promise<{ accessToken: string; user: User, profile?: GoogleProfileDto | GitHubProfileDto, tokens: GoogleTokenDto | GitHubTokenDto } > {\n    const { profile, tokens } = req.user as {\n      profile: GoogleProfileDto | GitHubProfileDto;\n      tokens: GoogleTokenDto | GitHubTokenDto;\n     // provider: 'google' | 'github';\n    };\n\n    const user  = await this.authService.validateOAuthProfile(\n      provider,\n      profile,\n      tokens,\n    );\n\n    const payload: CreateJwtUserDto = {\n      id: user.id,\n      sub: user.id,\n      email: user.email,\n      role: user.role ?? Role.USER,\n      image: user.image ?? undefined,\n      name: user.name ?? '',\n      phone_number: user.phone_number ?? '',\n      provider,\n      username: user.username ?? undefined, // Include username in JWT payload\n     // tokens,\n      \n    };\n\n    const accessToken = await this.authService.generateToken(payload);\n  \n    return { accessToken, user, profile, tokens };\n  }\n\n  /**\n   * Logs in a user and sets a JWT cookie.\n   *\n   * @Post login\n   * @ApiOperation summary Log in a user and set JWT cookie\n   * @ApiResponse status 200 - User logged in successfully\n   * @ApiResponse status 401 - Invalid credentials\n   * @async\n   * @function login\n   * @param {LoginDto} dto - The login credentials data transfer object.\n   * @param {Response} res - The Express response object for setting cookies.\n   * @returns {Promise<any>} - A promise that resolves to the user information.  The user object type is 'any' because the\n   * specific shape may depend on the authentication strategy.\n   */\n  @Post('login')\n  @ApiOperation({ summary: 'Log in a user and set JWT cookie' })\n  @ApiResponse({ status: 200, description: 'User logged in successfully' })\n  @ApiResponse({ status: 401, description: 'Invalid credentials' })\n  async login(\n    @Body() dto: LoginDto,\n    @Res({ passthrough: true }) res: Response,\n  ) {\n    const user = await this.authService.login(dto);\n    res.cookie('accessToken', user.accessToken, {\n      httpOnly: true,\n      secure: process.env.NODE_ENV === 'production',\n      sameSite: 'lax',\n    });\n    return user;\n  }\n\n  /**\n   * Logs out a user by clearing the JWT cookie.\n   *\n   * @Post logout\n   * @ApiOperation summary Log out user (clear cookie)\n   * @ApiResponse status 200 - Logged out successfully\n   * @async\n   * @function logout\n   * @param {Response} res - The Express response object for clearing cookies.\n   * @returns {Promise<{ message: string }>} - A promise that resolves to a success message.\n   */\n  @Post('logout')\n  @ApiOperation({ summary: 'Log out user (clear cookie)' })\n  @ApiResponse({ status: 200, description: 'Logged out successfully' })\n  async logout(@Res({ passthrough: true }) res: Response) {\n    res.clearCookie('accessToken');\n    return { message: 'Logged out successfully' };\n  }\n\n  /**\n   * Initiates the GitHub OAuth2 login flow.\n   *\n   * @Get github\n   * @UseGuards GitHubAuthGuard\n   * @ApiOperation summary Initiate GitHub OAuth2 login\n   * @ApiResponse status 302 - Redirects to GitHub login\n   * @async\n   * @function githubAuth\n   */\n  @Get('github')\n  @UseGuards(GitHubAuthGuard)\n  @ApiOperation({ summary: 'Initiate GitHub OAuth2 login' })\n  @ApiResponse({ status: 302, description: 'Redirects to GitHub login' })\n  async githubAuth() {\n    // OAuth2 login flow initiated by Passport\n  }\n\n  /**\n   * Handles the GitHub OAuth2 callback, issues a JWT token, and redirects the user.\n   *\n   * @Get github/callback\n   * @UseGuards GitHubAuthGuard\n   * @ApiOperation summary Handle GitHub OAuth2 callback and issue JWT token\n   * @ApiResponse status 200 - GitHub login successful with JWT issued\n   * @ApiResponse status 401 - Unauthorized or failed login attempt\n   * @async\n   * @function githubAuthRedirect\n   * @param {AuthRequest} req - The request object containing user information from GitHub.\n   * @param {Response} res - The Express response object for setting cookies and redirecting.\n   * @returns {Promise<any>} - A promise that resolves after redirecting the user.\n   */\n  @Get('github/callback')\n  @UseGuards(GitHubAuthGuard)\n  @ApiOperation({\n    summary: 'Handle GitHub OAuth2 callback and issue JWT token',\n  })\n  @ApiResponse({\n    status: 200,\n    description: 'GitHub login successful with JWT issued',\n  })\n  @ApiResponse({\n    status: 401,\n    description: 'Unauthorized or failed login attempt',\n  })\n  async githubAuthRedirect(@Req() req: AuthRequest, @Res() res: Response) {\n    try {\n      const { accessToken, user, profile, tokens } = await this.handleOAuthCallback(\n        'github',\n        req,\n      );\n\n      res.cookie('accessToken', accessToken, {\n        httpOnly: true,\n        secure: process.env.NODE_ENV === 'production',\n        sameSite: 'lax',\n      });\n\n      return res.redirect(\n        `${process.env.FRONTEND_URL}/login?action=success&accessToken=${accessToken}&userId=${user.id}&userEmail=${user.email}&userName=${encodeURIComponent(user.name || '')}&userImage=${encodeURIComponent(user.image || '')}&userRole=${user.role}&username=${encodeURIComponent(user.username || '')}&provider=github`,\n      );\n    } catch (error) {\n      console.error('OAuth redirect error:', error);\n      return res.redirect('/login?error=OAuth%20Login%20Failed');\n    }\n  }\n\n  /**\n   * Initiates the Google OAuth2 login flow.\n   *\n   * @Get google\n   * @UseGuards GoogleAuthGuard\n   * @ApiOperation summary Initiate Google OAuth2 login\n   * @ApiResponse status 302 - Redirects to Google login\n   * @async\n   * @function googleAuth\n   */\n  @Get('google')\n  @UseGuards(GoogleAuthGuard)\n  @ApiOperation({ summary: 'Initiate Google OAuth2 login' })\n  @ApiResponse({ status: 302, description: 'Redirects to Google login' })\n  async googleAuth() {\n    // OAuth2 login flow initiated by Passport\n  }\n\n  /**\n   * Handles the Google OAuth2 callback, issues a JWT token, and redirects the user.\n   *\n   * @Get google/callback\n   * @UseGuards GoogleAuthGuard\n   * @ApiOperation summary Handle Google OAuth2 callback and issue JWT token\n   * @ApiResponse status 200 - Google login successful with JWT issued\n   * @ApiResponse status 401 - Unauthorized or failed login attempt\n   * @async\n   * @function googleAuthRedirect\n   * @param {AuthRequest} req - The request object containing user information from Google.\n   * @param {Response} res - The Express response object for setting cookies and redirecting.\n   * @returns {Promise<any>} - A promise that resolves after redirecting the user.\n   */\n  @Get('google/callback')\n  @UseGuards(GoogleAuthGuard)\n  @ApiOperation({\n    summary: 'Handle Google OAuth2 callback and issue JWT token',\n  })\n  @ApiResponse({\n    status: 200,\n    description: 'Google login successful with JWT issued',\n  })\n  @ApiResponse({\n    status: 401,\n    description: 'Unauthorized or failed login attempt',\n  })\n  async googleAuthRedirect(@Req() req: AuthRequest, @Res() res: Response) {\n    try {\n      const { accessToken, user } = await this.handleOAuthCallback(\n        'google',\n        req,\n      );\n\n      res.cookie('accessToken', accessToken, {\n        httpOnly: true,\n        secure: process.env.NODE_ENV === 'production',\n        sameSite: 'lax',\n      });\n      //localStorage.setItem('accessToken', accessToken);\n      ///localStorage.setItem('user', JSON.stringify(user));\n      return res.redirect(\n        `${process.env.FRONTEND_URL}/login?action=success&accessToken=${accessToken}&userId=${user.id}&userEmail=${user.email}&userName=${encodeURIComponent(user.name || '')}&userImage=${encodeURIComponent(user.image || '')}&userRole=${user.role}&username=${encodeURIComponent(user.username || '')}&provider=google`,\n      );\n    } catch (error) {\n      console.error('OAuth redirect error:', error);\n      return res.redirect('/login?error=OAuth%20Login%20Failed');\n    }\n  }\n\n  /**\n   * Registers a new user.\n   *\n   * @Post register\n   * @ApiOperation summary Register a new user\n   * @ApiResponse status 201 - User registered successfully\n   * @ApiResponse status 400 - Validation failed or user already exists\n   * @async\n   * @function register\n   * @param {RegisterDto} dto - The registration data transfer object.\n   * @returns {Promise<void>} - A promise that resolves when registration is complete.\n   */\n  @Post('register')\n  @ApiOperation({ summary: 'Register a new user' })\n  @ApiResponse({ status: 201, description: 'User registered successfully' })\n  @ApiResponse({\n    status: 400,\n    description: 'Validation failed or user already exists',\n  })\n  async register(@Body() dto: RegisterDto): Promise<void> {\n    await this.authService.register(dto);\n  }\n\n  /**\n   * Resends the email verification link to the user.\n   *\n   * @Post resend-verification\n   * @ApiOperation summary Resend email verification link\n   * @ApiBody schema containing the user's email address.\n   * @async\n   * @function resendVerification\n   * @param {string} email - The email address of the user.\n   * @returns {Promise<any>} - A promise that resolves with the result of resending verification.  The result type is 'any'\n   * because the structure of the response from the mail service can vary.\n   */\n  @Post('resend-verification')\n  @ApiOperation({ summary: 'Resend email verification link' })\n  @ApiBody({\n    schema: {\n      properties: { email: { type: 'string', example: 'user@example.com' } },\n    },\n  })\n  async resendVerification(@Body('email') email: string) {\n    return this.authService.resendVerification(email);\n  }\n\n  /**\n   * Verifies the user's email address using the provided token.\n   *\n   * @Get verify-email\n   * @ApiOperation summary Verify user email address\n   * @ApiResponse status 200 - Email verified successfully\n   * @ApiResponse status 400 - Invalid or expired token\n   * @async\n   * @function verifyEmail\n   * @param {VerifyEmailDto} query - The query parameters containing the verification token.\n   * @returns {Promise<any>} - A promise that resolves with the result of email verification.  The result type is 'any' because\n   * the response format can depend on the implementation of the verification service.\n   */\n  @Get('verify-email')\n  @ApiOperation({ summary: 'Verify user email address' })\n  @ApiResponse({ status: 200, description: 'Email verified successfully' })\n  @ApiResponse({ status: 400, description: 'Invalid or expired token' })\n  async verifyEmail(@Query() query: VerifyEmailDto) {\n    return this.authService.verifyEmail(query.token);\n  }\n\n  /**\n   * Gets the profile of the currently authenticated user.\n   *\n   * @Get me\n   * @UseGuards JwtAuthGuard\n   * @ApiBearerAuth\n   * @ApiOperation summary Get current authenticated user\n   * @ApiResponse status 200 - User profile returned\n   * @ApiResponse status 401 - Unauthorized\n   * @async\n   * @function getProfile\n   * @param {Request} req - The request object containing the user information.\n   * @returns {Promise<any>} - A promise that resolves with the user profile.  The user profile type is 'any' because the shape\n   * can vary based on the data stored about the user.\n   */\n  @UseGuards(JwtAuthGuard)\n  @Get('me')\n  @ApiBearerAuth()\n  @ApiOperation({ summary: 'Get current authenticated user' })\n  @ApiResponse({ status: 200, description: 'User profile returned' })\n  @ApiResponse({ status: 401, description: 'Unauthorized' })\n  async getProfile(@Req() req: Request) {\n    const meR = req['user'];\n    if(meR.email){\n       const getAccount = this.prisma.user.findUnique({\n      where: { email: meR?.email },\n      include: {\n        Account: true,\n      },\n    });\n    if(getAccount){\n     \n    return getAccount;\n    } else {\n      return meR;\n    }\n    \n    }\n   \n  }\n}\n\n\n// File: src/auth/auth.guard.ts\nimport { ExecutionContext, Injectable } from '@nestjs/common';\nimport { AuthGuard } from '@nestjs/passport';\n\n@Injectable()\nexport class JwtAuthGuard extends AuthGuard('jwt') {\n  canActivate(context: ExecutionContext) {\n    return super.canActivate(context);\n  }\n\n  handleRequest(err, user, info) {\n    if (err || !user) {\n      return null;\n    }\n    return user;\n  }\n}\n\n\n// File: src/auth/auth.module.ts\nimport { Module } from '@nestjs/common';\nimport { JwtModule } from '@nestjs/jwt';\nimport { ConfigModule, ConfigService } from '@nestjs/config';\nimport { AuthService } from './auth.service';\nimport { AuthController } from './auth.controller';\nimport { JwtStrategy } from './auth.strategy';\nimport { JwtAuthGuard } from './auth.guard';\nimport { GoogleStrategy } from './strategies/google.strategy';\nimport { GoogleAuthGuard } from './guards/google.guard';\nimport { GitHubStrategy } from './strategies/github.strategy';\nimport { GitHubAuthGuard } from './guards/github.guard';\nimport { PrismaService } from '../prisma/prisma.service';\nimport { MailService } from '../mail/mail.service';\nimport { OAuthService } from './oauth.service';\n\n@Module({\n  imports: [\n    ConfigModule.forRoot({ isGlobal: true }),\n    JwtModule.registerAsync({\n      imports: [ConfigModule],\n      inject: [ConfigService],\n      useFactory: async (configService: ConfigService) => ({\n        secret: configService.get<string>('JWT_SECRET'),\n        signOptions: { expiresIn: '1d' },\n      }),\n    }),\n  ],\n  controllers: [AuthController],\n  providers: [\n    AuthService,\n    JwtStrategy,\n    GoogleStrategy,\n    GoogleAuthGuard,\n    GitHubStrategy,\n    GitHubAuthGuard,\n    JwtAuthGuard,\n    PrismaService,\n    MailService,\n    OAuthService,\n  ],\n  exports: [AuthService],\n})\nexport class AuthModule {}\n\n\n// File: src/auth/auth.service.ts\n// File: /media/eddie/Data/projects/nestJS/nest-modules/full-stack/src/auth/auth.service.ts\n\nimport {\n  BadRequestException,\n  Injectable,\n  UnauthorizedException,\n  InternalServerErrorException,\n  Logger,\n  NotFoundException,\n} from '@nestjs/common';\nimport * as bcrypt from 'bcrypt';\nimport { JwtService } from '@nestjs/jwt';\nimport { Role } from '@prisma/client';\n\nimport { PrismaService } from '../prisma/prisma.service';\nimport { MailService } from '../mail/mail.service';\n\nimport { RegisterDto, LoginDto } from './dto/auth.dto';\nimport { UserRole } from './enums/user-role.enum';\n\nimport { GoogleProfileDto } from './dto/google-profile.dto';\nimport { GoogleTokenDto } from './dto/google-token.dto';\nimport { GitHubProfileDto, GitHubTokenDto } from './dto/github-profile.dto';\n\nimport { JwtPayload } from './interfaces/jwt-payload.interface';\nimport { OAuthService } from './oauth.service';\nimport { CreateJwtUserDto } from './dto/auth.dto';\n\n/**\n * AuthService handles user authentication and authorization logic.\n * It provides methods for user registration, login, email verification,\n * and integration with OAuth providers like Google and GitHub.\n */\n@Injectable()\nexport class AuthService {\n  /**\n   * Constructor for AuthService.\n   * @param prisma - PrismaService for database interactions.\n   * @param jwtService - JwtService for generating and verifying JWT tokens.\n   * @param mailService - MailService for sending emails.\n   * @param oauthService - OAuthService for handling OAuth authentication.\n   */\n  constructor(\n    private readonly prisma: PrismaService,\n    private readonly jwtService: JwtService,\n    private readonly mailService: MailService,\n    private readonly oauthService: OAuthService,\n  ) {}\n\n  /**\n   * Generates an email verification token for a given user ID.\n   * @param userId - The ID of the user to generate the token for.\n   * @returns The generated JWT token.\n   * @private\n   */\n  private generateEmailVerificationToken(userId: string) {\n    return this.jwtService.sign(\n      { sub: userId },\n      {\n        secret: process.env.JWT_VERIFICATION_SECRET,\n        expiresIn: process.env.JWT_VERIFICATION_EXPIRES_IN || '1d',\n      },\n    );\n  }\n\n  /**\n   * Logs in a user with the provided credentials.\n   * @param dto - The LoginDto containing the user's email and password.\n   * @returns A promise that resolves to an object containing the access token and user data.\n   * @throws UnauthorizedException if the credentials are invalid.\n   */\n  async login(dto: LoginDto): Promise<{ accessToken: string; user: any }> {\n    const user = await this.prisma.user.findUnique({\n      where: { email: dto.email },\n      include: { password: true },\n    });\n\n    if (!user || !user.password) {\n      throw new UnauthorizedException('Invalid credentials');\n    }\n\n    const isPasswordValid = await bcrypt.compare(\n      dto.password,\n      user.password.hash,\n    );\n    if (!isPasswordValid) {\n      throw new UnauthorizedException('Invalid credentials');\n    }\n    const payload: CreateJwtUserDto = {\n      id: user.id,\n      sub: user.id,\n      email: user.email,\n      role: user.role ?? Role.USER,\n      image: user.image ?? undefined,\n      name: user.name ?? '',\n      phone_number: user.phone_number ?? '',\n    };\n\n    const accessToken = await this.generateToken(payload);\n    return { accessToken, user: payload };\n  }\n\n  /**\n   * Registers a new user.\n   * @param dto - The RegisterDto containing the user's registration information.\n   * @returns A promise that resolves to an object containing a success message.\n   * @throws InternalServerErrorException if user creation fails.\n   */\n  async register(dto: RegisterDto) {\n    const hash = await bcrypt.hash(dto.password, 10);\n    const createUser = {\n      email: dto.email,\n      name: dto.name,\n      phone_number: dto.phone_number || undefined,\n      role: Role.USER,\n    };\n    const user = await this.prisma.user.create({\n      data: {\n        ...createUser,\n        password: {\n          create: { hash },\n        },\n      },\n    });\n\n    if (!user) {\n      Logger.error('User creation failed: No user returned from database');\n      throw new InternalServerErrorException('User could not be created');\n    }\n    const token = this.generateEmailVerificationToken(user.id);\n    const verifyUrl = `${process.env.BASE_URL}/api/auth/verify-email?token=${token}`;\n\n    await this.mailService.sendVerificationEmail(\n      user.email,\n      user.name ?? 'User',\n      verifyUrl,\n    );\n    // TODO: Log registration event (e.g., using Winston or custom logger)\n    // TODO: Audit log entry to track new account creation\n    // TODO: Add metrics or monitoring hook (e.g., Prometheus counter)\n    // TODO: Optionally trigger admin notification on new registration\n    // TODO: Send account verification email if emailVerified is required\n    return { message: 'Verification email sent.' };\n  }\n\n  /**\n   * Verifies a user's email address using a verification token.\n   * @param token - The email verification token.\n   * @returns A promise that resolves to an object containing a success message.\n   * @throws BadRequestException if the token is invalid or expired.\n   */\n  async verifyEmail(token: string) {\n    try {\n      const payload = this.jwtService.verify(token, {\n        secret: process.env.JWT_VERIFICATION_SECRET,\n      });\n\n      await this.prisma.user.update({\n        where: { id: payload.sub },\n        data: { emailVerified: new Date() },\n      });\n\n      return { message: 'Email verified successfully.' };\n    } catch (err) {\n      throw new BadRequestException('Invalid or expired token.');\n    }\n  }\n\n  /**\n   * Resends the email verification email to a user.\n   * @param email - The email address of the user.\n   * @returns A promise that resolves to an object containing a success message.\n   * @throws NotFoundException if the user is not found.\n   */\n  async resendVerification(email: string) {\n    const user = await this.prisma.user.findUnique({ where: { email } });\n\n    if (!user) throw new NotFoundException('User not found.');\n    if (user.emailVerified) return { message: 'Email already verified.' };\n\n    const token = this.generateEmailVerificationToken(user.id);\n    const verifyUrl = `${process.env.BASE_URL}/api/auth/verify-email?token=${token}`;\n\n    await this.mailService.sendVerificationEmail(\n      user.email,\n      user.name ?? 'User',\n      verifyUrl,\n    );\n\n    return { message: 'Verification email sent.' };\n  }\n\n  /**\n   * Validates a user by ID and returns their information.\n   * @param userId - The ID of the user to validate.\n   * @returns A promise that resolves to the user's information.\n   */\n  async validateUser(userId: string) {\n    return this.prisma.user.findUnique({\n      where: { id: userId },\n      select: {\n        id: true,\n        email: true,\n        name: true,\n        role: true,\n        phone_number: true,\n        createdAt: true,\n        image: true,\n      },\n    });\n  }\n\n  /**\n   * Validates an OAuth profile from a given provider (Google or GitHub).\n   * @param provider - The OAuth provider ('google' or 'github').\n   * @param profile - The user's profile data from the provider.\n   * @param tokens - The access and refresh tokens from the provider.\n   * @returns A promise that resolves to the validated user data.\n   */\n  async validateOAuthProfile(\n    provider: 'google' | 'github',\n    profile: GoogleProfileDto | GitHubProfileDto,\n    tokens: GoogleTokenDto | GitHubTokenDto,\n  ) {\n    return await this.oauthService.validate(provider, profile, tokens);\n  }\n\n  /**\n   * Generates a JWT token for a given user payload.\n   * @param payload - The user payload to include in the token.\n   * @returns A promise that resolves to the generated JWT token.\n   */\n  async generateToken(payload: CreateJwtUserDto): Promise<string> {\n    return this.jwtService.signAsync(payload);\n  }\n}\n\n\n// File: src/auth/auth.strategy.ts\nimport { Injectable } from '@nestjs/common';\nimport { PassportStrategy } from '@nestjs/passport';\nimport { ExtractJwt, Strategy } from 'passport-jwt';\nimport { ConfigService } from '@nestjs/config';\nimport { Request } from 'express';\nimport { AuthService } from './auth.service';\n\n@Injectable()\nexport class JwtStrategy extends PassportStrategy(Strategy) {\n  constructor(\n    config: ConfigService,\n    private readonly authService: AuthService,\n  ) {\n    super({\n      jwtFromRequest: ExtractJwt.fromExtractors([\n        JwtStrategy.extractFromCookieOrHeader,\n      ]),\n      ignoreExpiration: false,\n      secretOrKey: config.get<string>('JWT_SECRET'),\n      passReqToCallback: true,\n    });\n  }\n\n  /**\n   * Extract JWT from cookies or Authorization header if present (optional).\n   */\n  private static extractFromCookieOrHeader(req: any): string | null {\n    // HTTP Cookies\n    if (req?.cookies?.accessToken) {\n      return req.cookies.accessToken;\n    }\n\n    // WebSocket Cookies\n    const cookieHeader = req?.handshake?.headers?.cookie;\n    if (cookieHeader) {\n      const cookies = Object.fromEntries(\n        cookieHeader.split(';').map((cookie) => {\n          const [key, value] = cookie.trim().split('=');\n          return [key, decodeURIComponent(value)];\n        }),\n      );\n      if (cookies['accessToken']) {\n        return cookies['accessToken'];\n      }\n    }\n\n    // Optional Bearer header (HTTP only)\n    const authHeader = req?.headers?.authorization;\n    if (authHeader?.startsWith('Bearer ')) {\n      return authHeader.split(' ')[1];\n    }\n\n    return null;\n  }\n\n  async validate(req: Request, payload: any) {\n    const user = await this.authService.validateUser(payload.sub);\n    return user ?? null;\n  }\n}\n\n\n// File: src/auth/oauth.service.ts\nimport { Injectable } from '@nestjs/common';\nimport { Role } from '@prisma/client';\n\nimport { PrismaService } from '../prisma/prisma.service';\n\nimport { GoogleProfileDto } from './dto/google-profile.dto';\nimport { GoogleTokenDto } from './dto/google-token.dto';\nimport { GitHubProfileDto, GitHubTokenDto } from './dto/github-profile.dto';\nimport { CreateJwtUserDto } from './dto/auth.dto';\ntype Provider = 'google' | 'github';\n\ninterface OAuthProfile {\n  id: string;\n  email: string;\n  name?: string;\n  image?: string;\n  login?: string;\n}\n\ninterface OAuthTokens {\n  accessToken: string;\n  refreshToken?: string;\n  idToken?: string;\n  expiresAt?: number;\n  scope?: string;\n  tokenType?: string;\n}\n\n@Injectable()\nexport class OAuthService {\n  constructor(private readonly prisma: PrismaService) {}\n\n  async validate(\n    provider: Provider,\n    profile: GoogleProfileDto | GitHubProfileDto,\n    tokens: GoogleTokenDto | GitHubTokenDto,\n  ) {\n    const normalized = this.normalizeProfile(provider, profile);\n    return this.handleOAuthLogin(provider, normalized, tokens);\n  }\n\n  private normalizeProfile(\n    provider: Provider,\n    profile: GoogleProfileDto | GitHubProfileDto,\n  ): OAuthProfile {\n    if (provider === 'google') {\n      const google = profile as GoogleProfileDto;\n      const email = google.emails?.[0]?.value;\n      const image = google.photos?.[0]?.value;\n      const name =\n        `${google.name?.givenName ?? ''} ${google.name?.familyName ?? ''}`.trim();\n\n      if (!email)\n        throw new Error(\n          'Google profile does not contain a valid email address.',\n        );\n\n      return {\n        id: google.id,\n        email,\n        name,\n        image,\n      };\n    }\n\n    const github = profile as GitHubProfileDto;\n    console.log(github, 'github normalizeProfile');\n    if (!github.email)\n      throw new Error('GitHub profile does not contain a valid email address.');\n\n    return {\n      id: github.id,\n      email: github.email,\n      name: github.name,\n      image: github.avatar_url,\n      login: github.login,\n    };\n  }\n\n  private async handleOAuthLogin(\n    provider: Provider,\n    profile: OAuthProfile,\n    tokens: OAuthTokens,\n  ) {\n    const { id: providerAccountId, email, name, image, login } = profile;\n    console.log(profile, 'profile handleOAuthLogin');\n    let user = await this.prisma.user.findUnique({ where: { email }, include: {\n       // Account: true,\n      } });\n\n    if (!user) {\n      user = await this.prisma.user.create({\n        data: {\n          email,\n          name: name || undefined,\n          image: image || undefined,\n          emailVerified: new Date(),\n          role: Role.USER,\n        },\n      });\n    } else if (!user.image && image) {\n      user = await this.prisma.user.update({\n        where: { id: user.id },\n        data: { image, username: login },\n      });\n    } else if (!user.username && login) {\n      user = await this.prisma.user.update({\n        where: { id: user.id },\n        data: { username: login },\n      });\n    }\n    \n    await this.prisma.account.upsert({\n      where: {\n        provider_providerAccountId: {\n          provider,\n          providerAccountId,\n        },\n      },\n      update: {\n        access_token: tokens.accessToken,\n        refresh_token: tokens.refreshToken,\n        id_token: tokens.idToken,\n        expires_at: tokens.expiresAt,\n        scope: tokens.scope,\n        token_type: tokens.tokenType,\n      },\n      create: {\n        provider,\n        providerAccountId,\n        type: 'oauth',\n        access_token: tokens.accessToken,\n        refresh_token: tokens.refreshToken,\n        id_token: tokens.idToken,\n        expires_at: tokens.expiresAt,\n        scope: tokens.scope,\n        token_type: tokens.tokenType,\n        createdBy: { connect: { id: user.id } },\n      },\n    });\n   // const u = user as CreateJwtUserDto;\n    \n    return user;\n  }\n}\n\n\n// File: src/auth/decorators/current-user.decorator.ts\nimport { createParamDecorator, ExecutionContext } from '@nestjs/common';\nimport { AuthRequest } from '../interfaces/auth-request.interface';\n\nexport const CurrentUser = createParamDecorator(\n  (_: unknown, ctx: ExecutionContext) => {\n    const request = ctx.switchToHttp().getRequest<AuthRequest>();\n    return request.user;\n  },\n);\n\n\n// File: src/auth/decorators/roles.decorator.ts\nimport { applyDecorators, SetMetadata } from '@nestjs/common';\nimport {\n  ApiBearerAuth,\n  ApiForbiddenResponse,\n  ApiUnauthorizedResponse,\n} from '@nestjs/swagger';\n\nexport const ROLES_KEY = 'roles';\nexport const Roles = (...roles: string[]) =>\n  applyDecorators(\n    SetMetadata(ROLES_KEY, roles),\n    ApiBearerAuth(), // for bearer token\n    ApiUnauthorizedResponse({ description: 'Unauthorized' }),\n    ApiForbiddenResponse({ description: 'Forbidden - insufficient role' }),\n  );\n\n\n// File: src/auth/dto/auth.dto.ts\n// src/auth/dto/auth.dto.ts\nimport { Role } from '@prisma/client';\nimport { ApiProperty } from '@nestjs/swagger';\nimport {\n  IsEmail,\n  IsNotEmpty,\n  MinLength,\n  IsOptional,\n  IsString,\n  IsEnum,\n} from 'class-validator';\n\nexport class RegisterDto {\n  @ApiProperty({ example: 'user@example.com' })\n  @IsEmail()\n  email: string;\n\n  @ApiProperty({ example: 'StrongPassword123' })\n  @IsNotEmpty()\n  @MinLength(8)\n  password: string;\n\n  @ApiProperty({ example: 'John Doe', required: false })\n  @IsOptional()\n  name: string;\n\n  @ApiProperty({ example: '+1234567890', required: false })\n  @IsOptional()\n  phone_number?: string;\n\n  @ApiProperty({ example: 'USER', required: false })\n  @IsOptional()\n  @IsEnum(Role)\n  role?: Role;\n}\nexport class CreateJwtUserDto {\n  @ApiProperty({\n    description: 'JQT User identifier',\n    example: '21jdh-jsdhd-jasjasd',\n  })\n  @IsString()\n  id?: string;\n\n  @ApiProperty({ example: '21jdh-jsdhd-jasjasd' })\n  @IsString()\n  sub: string;\n\n  @ApiProperty({ example: 'user@example.com' })\n  @IsEmail()\n  email: string;\n\n  @ApiProperty({ example: 'John Doe', required: false })\n  @IsOptional()\n  name?: string;\n\n  @ApiProperty({ example: '+1234567890', required: false })\n  @IsOptional()\n  phone_number?: string;\n\n  @ApiProperty({ example: 'USER', required: false })\n  @IsOptional()\n  @IsEnum(Role)\n  role: Role;\n\n  @ApiProperty({ example: 'john.jpg', required: false })\n  @IsOptional()\n  image?: string;\n\n  @ApiProperty({ example: 'Google', required: false })\n  @IsOptional()\n  provider?: string;\n\n  @ApiProperty({ example: '32131dqewewqe', required: false })\n  @IsOptional()\n  tokens?: any;\n  @ApiProperty({ example: 'user01', required: false })\n  @IsOptional()\n  username?: any;\n}\nexport class LoginDto {\n  @ApiProperty({ example: 'user@example.com' })\n  @IsEmail()\n  email: string;\n\n  @ApiProperty({ example: 'StrongPassword123' })\n  @IsNotEmpty()\n  password: string;\n}\n\n\n// File: src/auth/dto/email-verification-response.dto.ts\n// src/auth/dto/email-verification-response.dto.ts\nimport { ApiProperty } from '@nestjs/swagger';\n\nexport class EmailVerificationResponseDto {\n  @ApiProperty({ example: 'Email verified successfully.' })\n  message: string;\n}\n\n\n// File: src/auth/dto/github-profile.dto.ts\n// src/auth/dto/github-profile.dto.ts\nimport {\n  IsArray,\n  IsOptional,\n  IsString,\n  IsEmail,\n  IsUrl,\n  ValidateNested,\n} from 'class-validator';\nimport { Type } from 'class-transformer';\nimport { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';\n\nexport class GitHubProfileDto {\n  @ApiProperty({ example: '12345678' })\n  @IsString()\n  id: string;\n\n  @ApiProperty({ example: 'octocat' })\n  @IsString()\n  login: string;\n\n  @ApiPropertyOptional({ example: 'The Octocat' })\n  @IsOptional()\n  @IsString()\n  name?: string;\n\n  @ApiPropertyOptional({ example: 'octocat@github.com' })\n  @IsOptional()\n  @IsString()\n  email?: string;\n\n  @ApiPropertyOptional({\n    example: 'https://avatars.githubusercontent.com/u/12345678?v=4',\n  })\n  @IsOptional()\n  @IsUrl()\n  avatar_url?: string;\n\n  @ApiPropertyOptional({ example: 'github' })\n  @IsOptional()\n  @IsString()\n  provider?: string;\n}\n\nexport class GitHubTokenDto {\n  @ApiProperty()\n  @IsString()\n  accessToken: string;\n\n  @ApiPropertyOptional()\n  @IsOptional()\n  @IsString()\n  refreshToken?: string;\n\n  @ApiPropertyOptional()\n  @IsOptional()\n  @IsString()\n  scope?: string;\n\n  @ApiPropertyOptional()\n  @IsOptional()\n  @IsString()\n  tokenType?: string;\n}\n\n\n// File: src/auth/dto/google-profile.dto.ts\n// src/auth/dto/google-profile.dto.ts\nimport {\n  IsArray,\n  IsOptional,\n  IsString,\n  IsEmail,\n  IsUrl,\n  ValidateNested,\n} from 'class-validator';\nimport { Type } from 'class-transformer';\nimport { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';\n\nclass GoogleNameDto {\n  @ApiPropertyOptional({ example: 'Doe' })\n  @IsOptional()\n  @IsString()\n  familyName?: string;\n\n  @ApiPropertyOptional({ example: 'John' })\n  @IsOptional()\n  @IsString()\n  givenName?: string;\n}\n\nclass GoogleEmailDto {\n  @ApiProperty({ example: 'john.doe@gmail.com' })\n  @IsEmail()\n  value: string;\n\n  @ApiPropertyOptional({ example: true })\n  @IsOptional()\n  verified?: boolean;\n}\n\nclass GooglePhotoDto {\n  @ApiProperty({ example: 'https://lh3.googleusercontent.com/a-/photo.jpg' })\n  @IsUrl()\n  value: string;\n}\n\nexport class GoogleProfileDto {\n  @ApiProperty({ example: '112233445566778899001' })\n  @IsString()\n  id: string;\n\n  @ApiPropertyOptional({ example: 'John Doe' })\n  @IsOptional()\n  @IsString()\n  displayName?: string;\n\n  @ApiPropertyOptional({ type: GoogleNameDto })\n  @IsOptional()\n  @ValidateNested()\n  @Type(() => GoogleNameDto)\n  name?: GoogleNameDto;\n\n  @ApiPropertyOptional({ type: [GoogleEmailDto] })\n  @IsOptional()\n  @IsArray()\n  @ValidateNested({ each: true })\n  @Type(() => GoogleEmailDto)\n  emails?: GoogleEmailDto[];\n\n  @ApiPropertyOptional({ type: [GooglePhotoDto] })\n  @IsOptional()\n  @IsArray()\n  @ValidateNested({ each: true })\n  @Type(() => GooglePhotoDto)\n  photos?: GooglePhotoDto[];\n\n  @ApiPropertyOptional({ example: 'google' })\n  @IsOptional()\n  @IsString()\n  provider?: string;\n}\n\n\n// File: src/auth/dto/google-token.dto.ts\n// src/auth/dto/google-token.dto.ts\nimport { IsOptional, IsString, IsNumber } from 'class-validator';\nimport { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';\n\nexport class GoogleTokenDto {\n  @ApiProperty({ example: 'ya29.a0AVvZVt...' })\n  @IsString()\n  accessToken: string;\n\n  @ApiPropertyOptional({ example: '1//0gJ7xyz...' })\n  @IsOptional()\n  @IsString()\n  refreshToken?: string;\n\n  @ApiPropertyOptional({ example: 'eyJhbGciOiJSUzI1NiIsInR...' })\n  @IsOptional()\n  @IsString()\n  idToken?: string;\n\n  @ApiPropertyOptional({ example: 1715881745 })\n  @IsOptional()\n  @IsNumber()\n  expiresAt?: number;\n\n  @ApiPropertyOptional({ example: 'profile email' })\n  @IsOptional()\n  @IsString()\n  scope?: string;\n\n  @ApiPropertyOptional({ example: 'Bearer' })\n  @IsOptional()\n  @IsString()\n  tokenType?: string;\n}\n\n\n// File: src/auth/dto/verify-email.dto.ts\n// src/auth/dto/verify-email.dto.ts\nimport { IsString } from 'class-validator';\nimport { ApiProperty } from '@nestjs/swagger';\n\nexport class VerifyEmailDto {\n  @ApiProperty({\n    description: 'JWT token for email verification',\n    example: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...',\n  })\n  @IsString()\n  token: string;\n}\n\n\n// File: src/auth/enums/user-role.enum.ts\nexport enum UserRole {\n  ADMIN = 'ADMIN',\n  USER = 'USER',\n  MANAGER = 'MANAGER',\n  SUPERADMIN = 'SUPERADMIN',\n  // add more as needed\n}\n\n\n// File: src/auth/guards/github.guard.ts\n// src/auth/guards/google.guard.ts\nimport { Injectable } from '@nestjs/common';\nimport { AuthGuard } from '@nestjs/passport';\nimport { ExecutionContext } from '@nestjs/common';\n\n@Injectable()\nexport class GitHubAuthGuard extends AuthGuard('github') {\n  canActivate(context: ExecutionContext) {\n    return super.canActivate(context);\n  }\n\n  handleRequest(err: any, user: any, info: any, context: any) {\n    if (err || !user) {\n      throw err || new Error('Unauthorized');\n    }\n    return user;\n  }\n}\n\n\n// File: src/auth/guards/google.guard.ts\n// src/auth/guards/google.guard.ts\nimport { Injectable } from '@nestjs/common';\nimport { AuthGuard } from '@nestjs/passport';\nimport { ExecutionContext } from '@nestjs/common';\n\n@Injectable()\nexport class GoogleAuthGuard extends AuthGuard('google') {\n  canActivate(context: ExecutionContext) {\n    return super.canActivate(context);\n  }\n\n  handleRequest(err: any, user: any, info: any, context: any) {\n    if (err || !user) {\n      throw err || new Error('Unauthorized');\n    }\n    return user;\n  }\n}\n\n\n// File: src/auth/guards/roles.guard.ts\nimport {\n  CanActivate,\n  ExecutionContext,\n  ForbiddenException,\n  Injectable,\n} from '@nestjs/common';\nimport { Reflector } from '@nestjs/core';\nimport { Role } from '@prisma/client'; // or wherever your Role enum is\n\n@Injectable()\nexport class RolesGuard implements CanActivate {\n  constructor(private reflector: Reflector) {}\n\n  canActivate(context: ExecutionContext): boolean {\n    const requiredRoles = this.reflector.getAllAndOverride<Role[]>('roles', [\n      context.getHandler(),\n      context.getClass(),\n    ]);\n\n    if (!requiredRoles || requiredRoles.length === 0) {\n      return true; // No roles required → public access\n    }\n\n    const request = context.switchToHttp().getRequest();\n    const user = request.user;\n\n    if (!user || !user.role || !requiredRoles.includes(user.role)) {\n      throw new ForbiddenException('Access denied: insufficient role');\n    }\n\n    return true;\n  }\n}\n\n\n// File: src/auth/interfaces/auth-request.interface.ts\nimport { Request } from 'express';\nimport { User } from '@prisma/client';\n\nexport interface AuthRequest extends Request {\n  user: Partial<Pick<User, 'id' | 'email' | 'name' | 'role' | 'username'>>;\n  provider?: 'github'|'google';\n  providerToken?: string;\n}\n\n\n// File: src/auth/interfaces/github-profile.interface.ts\n // Define a basic structure for the GitHub profile returned by passport-github\nexport interface GitHubProfile {\n    id: string; // GitHub user ID (string)\n    nodeId: string;\n    displayName: string;\n    username: string;\n    profileUrl: string;\n    photos: [{ value: string }]; // Array of photo URLs\n    provider: string; // 'github'\n    _raw: string; // Raw JSON response from GitHub\n    _json: any; // Parsed JSON response from GitHub\n}\n\n// User object to be stored in memory and passed around\nexport interface User {\n    id: string; // Internal user ID\n    githubId: string; // GitHub user ID (numeric string)\n    username: string;\n    email: string;\n    githubAccessToken: string; // The token we need for API calls\n    displayName: string;\n}\n\n\n// File: src/auth/interfaces/jwt-payload.interface.ts\nimport { Role } from '@prisma/client';\n\nexport interface JwtPayload {\n  sub: string; // user.id is a string\n  email: string; // user.email is a string\n  role: Role; // assign a fallback elsewhere, not in the type\n  name?: string; // optional\n  provider?: 'google' | 'github'; // optional\n}\n\n\n// File: src/auth/strategies/github.strategy.ts\n// src/auth/strategies/github.strategy.ts\nimport { PassportStrategy } from '@nestjs/passport';\nimport { Injectable } from '@nestjs/common';\nimport { Strategy, VerifyCallback } from 'passport-github2';\nimport { GitHubProfileDto, GitHubTokenDto } from '../dto/github-profile.dto';\n\n@Injectable()\nexport class GitHubStrategy extends PassportStrategy(Strategy, 'github') {\n  constructor() {\n    super({\n      clientID: process.env.GITHUB_CLIENT_ID,\n      clientSecret: process.env.GITHUB_CLIENT_SECRET,\n      callbackURL: process.env.GITHUB_CALLBACK_URL,\n      scope: ['user:email'],\n    });\n  }\n\n  async validate(\n    accessToken: string,\n    refreshToken: string,\n    profile: any,\n    done: VerifyCallback,\n  ): Promise<void> {\n    const { id, login, displayName, emails, photos, provider } = profile;\n\n    // Construct typed DTOs\n    const profileDto: GitHubProfileDto = {\n      id,\n      login,\n      name: displayName,\n      provider,\n      email: emails?.[0]?.value,\n      avatar_url: photos?.[0]?.value,\n      \n    };\n\n    const tokenDto: GitHubTokenDto = {\n      accessToken,\n      refreshToken,\n      scope: profile._scope || null,\n      tokenType: profile._tokenType || null,\n    };\n\n    done(null, { profile: profileDto, tokens: tokenDto });\n  }\n}\n\n\n// File: src/auth/strategies/google.strategy.ts\nimport { PassportStrategy } from '@nestjs/passport';\nimport { Injectable } from '@nestjs/common';\nimport { Strategy, VerifyCallback } from 'passport-google-oauth20';\nimport { GoogleProfileDto } from '../dto/google-profile.dto';\nimport { GoogleTokenDto } from '../dto/google-token.dto';\n\n@Injectable()\nexport class GoogleStrategy extends PassportStrategy(Strategy, 'google') {\n  constructor() {\n    super({\n      clientID: process.env.GOOGLE_CLIENT_ID,\n      clientSecret: process.env.GOOGLE_CLIENT_SECRET,\n      callbackURL: process.env.GOOGLE_CALLBACK_URL,\n      scope: ['email', 'profile'],\n    });\n  }\n\n  async validate(\n    accessToken: string,\n    refreshToken: string,\n    profile: any,\n    done: VerifyCallback,\n  ): Promise<void> {\n    const { id, name, emails, photos, provider } = profile;\n\n    // Construct typed DTOs\n    const profileDto: GoogleProfileDto = {\n      id,\n      displayName: profile.displayName,\n      provider,\n      name: {\n        familyName: name.familyName,\n        givenName: name.givenName,\n      },\n      emails: emails?.map((e: any) => ({ value: e.value })) || [],\n      photos: photos?.map((p: any) => ({ value: p.value })) || [],\n    };\n\n    const tokenDto: GoogleTokenDto = {\n      accessToken,\n      refreshToken,\n      idToken: profile.id_token, // in case it's included\n      expiresAt: profile._json?.exp || null,\n      scope: profile.scope || null,\n      tokenType: profile.token_type || null,\n    };\n\n    done(null, { profile: profileDto, tokens: tokenDto });\n  }\n}\n\n\n// File: ../ai-assistant/ai-editor/src/constants.ts\n export const INSTRUCTION = `\n            You are an expert TypeScript/React/Tailwind developer.\n            Focus on creating clean, idiomatic code. Ensure all generated code is fully type-safe.\n            When modifying existing files, preserve existing formatting and code style as much as possible.\n            If adding new components or modules, place them in logical, idiomatic locations within the project structure.\n            Consider common best practices for React (hooks, functional components, state management with nanostores if applicable) and Tailwind CSS v4 (utility-first, responsive design).\n            If a new file is created, ensure it follows the correct naming conventions and is properly imported/exported where necessary.\n            Always consider the full context of the project when making changes.\n            For 'modify' actions, provide only the *entire new content* of the file, not just a diff.\n            For 'add' actions, provide the *entire content* of the new file.\n            For 'delete' actions, no newContent is required.\n            If you need to add a new dependency, mention it in the summary or thought process, but do NOT include 'npm install' or 'yarn add' commands in the file changes.\n          `.replace(/^\\s+/gm, \"\");\nexport const ADDIONAL_INSTRUCTION_EXPECTED_OUTPUT = `\n            Your response must be a JSON object with two top-level keys: 'summary' (string) and 'changes' (array of objects).\n            The 'changes' array should contain objects, each representing a file operation:\n            {\n              \"filePath\": \"path/to/file.tsx\", // Absolute path (use path.join(projectRoot, relativePath) to construct)\n              \"action\": \"add\" | \"modify\" | \"delete\",\n              \"newContent\"?: \"...\", // Required for 'add'/'modify', omit for 'delete'\n              \"reason\"?: \"...\" // Optional, short explanation for this specific file change\n            }\n            Example:\n            {\n              \"summary\": \"Implemented user authentication and updated Navbar component.\",\n              \"thoughtProcess\": \"Created new components for login and signup, updated navigation to include auth links, and added a basic auth context.\",\n              \"changes\": [\n                {\n                  \"filePath\": \"/path/to/project/src/auth/Login.tsx\",\n                  \"action\": \"add\",\n                  \"newContent\": \"import React from 'react';\\\\nimport { useStore } from '@nanostores/react';\\\\nimport { authStore } from './authStore';\\\\n\\\\nfunction Login() {\\\\n  const $auth = useStore(authStore);\\\\n  // ... login form logic\\\\n  return <div className='p-4'>Login Form</div>;\\\\n}\\\\nexport default Login;\",\n                  \"reason\": \"New login component for user authentication.\"\n                },\n                {\n                  \"filePath\": \"/path/to/project/src/components/Navbar.tsx\",\n                  \"action\": \"modify\",\n                  \"newContent\": \"import React from 'react';\\\\nimport { Link } from 'react-router-dom';\\\\nimport { useStore } from '@nanostores/react';\\\\nimport { authStore } from '../auth/authStore';\\\\n\\\\nfunction Navbar() {\\\\n  const $auth = useStore(authStore);\\\\n  return (\\\\n    <nav className='bg-blue-500 p-4 text-white flex justify-between'>\\\\n      <Link to='/' className='font-bold text-lg'>My App</Link>\\\\n      <div>\\\\n        {$auth.isLoggedIn ? (\\\\n          <button onClick={() => authStore.setKey('isLoggedIn', false)} className='ml-4'>Logout</button>\\\\n        ) : (\\\\n          <>\\\\n            <Link to='/login' className='ml-4'>Login</Link>\\\\n            <Link to='/signup' className='ml-4'>Signup</Link>\\\\n          </>\\\\n        )}\\\\n      </div>\\\\n    </nav>\\\\n  );\\\\n}\\\\nexport default Navbar;\",\n                  \"reason\": \"Added login/logout links to Navbar based on authentication status.\"\n                },\n                {\n                  \"filePath\": \"/path/to/project/src/old/DeprecatedComponent.ts\",\n                  \"action\": \"delete\",\n                  \"reason\": \"Removed unused component as part of refactor.\"\n                }\n              ]\n            }\n          `.replace(/^\\s+/gm, \"\");\n\n\n// File: ../ai-assistant/ai-editor/src/index.ts\nimport dotenv from 'dotenv';\ndotenv.config();\nimport { Command } from 'commander';\nimport inquirer from 'inquirer';\nimport { scanProject } from './scanner';\nimport { INSTRUCTION, ADDIONAL_INSTRUCTION_EXPECTED_OUTPUT } from './constants';\nimport { prepareContextForLLM, buildLLMPrompt } from './llm/contextPreparer';\nimport { callLLM } from './llm/llmOrchestrator';\nimport { generateUnifiedDiff } from './file-operations/diffGenerator';\nimport { applyFileChange } from './file-operations/fileApplier';\nimport {\n  isGitRepository,\n  createBranch,\n  stageFiles,\n  getCurrentBranch,\n} from './git-operations/gitManager';\nimport { ScannedFile, LLMInput, LLMOutput, ProposedFileChange } from './types';\nimport simpleGit, { SimpleGit } from 'simple-git';\nimport * as path from 'path';\n\nconst program = new Command();\n\nprogram\n  .name('ai-editor')\n  .description('An AI-powered tool for editing and updating code files.')\n  .version('0.1.0');\n\nprogram\n  .command('scan [paths...]') // Changed to accept multiple paths (files or directories)\n  .description('Scans one or more files or directories for relevant code files and reads their content.')\n  .option('-v, --verbose', 'Output detailed information during scan.')\n  .option('-s, --show-content', 'Show a snippet of file content for sample files.')\n  .action(async (paths: string[], options: { verbose?: boolean; showContent?: boolean }) => {\n    // If no paths are provided, default to current working directory\n    const targetPaths = paths.length > 0 ? paths : ['.'];\n    const projectRoot = process.cwd(); // For 'scan' command, assume CWD is the project root\n\n    console.log(`Scanning paths: ${targetPaths.map(p => path.resolve(projectRoot, p)).join(', ')}`);\n    if (options.verbose) {\n      console.log('Verbose mode enabled.');\n    }\n\n    try {\n      // Pass the array of targetPaths and the projectRoot to scanProject\n      const scannedFiles: ScannedFile[] = await scanProject(targetPaths, projectRoot, options.verbose);\n      console.log('\\n--- Scan Complete ---');\n      console.log(`Found ${scannedFiles.length} files.`);\n\n      if (scannedFiles.length > 0) {\n        console.log('Sample files found:');\n        scannedFiles.slice(0, 5).forEach((file) => {\n          // Display path relative to CWD for user clarity\n          const displayPath = path.relative(process.cwd(), file.filePath);\n          console.log(`  - ${displayPath}`);\n          if (options.showContent) {\n            const contentSnippet =\n              file.content.substring(0, 200) + (file.content.length > 200 ? '...' : '');\n            console.log(\n              `    Content snippet:\\n${contentSnippet\n                .split('\\n')\n                .map((line) => `      ${line}`)\n                .join('\\n')}\\n`,\n            );\n          }\n        });\n        if (scannedFiles.length > 5) {\n          console.log(`  ... and ${scannedFiles.length - 5} more.`);\n        }\n      }\n    } catch (error) {\n      console.error(`Error during scan: ${(error as Error).message}`);\n      process.exit(1);\n    }\n  });\n\nprogram\n  .command('generate <prompt>')\n  .description('Generates or modifies code based on a natural language prompt.')\n  .option(\n    '-p, --path <path>',\n    'Specify the project root directory (default: current directory). This is where Git operations and file resolution will be based.',\n    '.',\n  )\n  .option(\n    '--scan-dirs <dirs...>',\n    'Space-separated list of directories to scan within the project root (e.g., \"src tests\").',\n  )\n  .option(\n    '--scan-files <files...>', // NEW option for individual files\n    'Space-separated list of individual file paths to scan within the project root (e.g., \"src/App.tsx tests/my-test.ts\").',\n  )\n  .option(\n    '-y, --yes',\n    'Automatically confirm all proposed changes without prompting (USE WITH CAUTION!).',\n    false,\n  )\n  .option('--no-git', 'Skip all Git operations (branching, staging).', false)\n  .option(\n    '--branch <name>',\n    'Specify a branch name to create/checkout. If not provided, a default is suggested.',\n  )\n  .action(\n    async (\n      prompt: string,\n      options: {\n        path: string; // This is the project root\n        scanDirs?: string[]; // Commander.js will pass as array or undefined\n        scanFiles?: string[]; // NEW: Commander.js will pass as array or undefined\n        yes: boolean;\n        noGit: boolean;\n        branch?: string;\n      },\n    ) => {\n      const projectRoot = path.resolve(process.cwd(), options.path);\n      \n      let allScanPaths: string[] = [];\n\n      if (options.scanDirs && options.scanDirs.length > 0) {\n          allScanPaths = allScanPaths.concat(options.scanDirs);\n      }\n      if (options.scanFiles && options.scanFiles.length > 0) {\n          allScanPaths = allScanPaths.concat(options.scanFiles);\n      }\n\n      // If neither --scan-dirs nor --scan-files are provided, default to scanning the entire project root.\n      if (allScanPaths.length === 0) {\n          allScanPaths = ['.'];\n      }\n\n      const autoConfirm = options.yes;\n      const skipGit = options.noGit;\n      const customBranchName = options.branch;\n\n      console.log(`AI Code Generation Request: \"${prompt}\"`);\n      console.log(`Project root: ${projectRoot}`);\n      console.log(`Scanning paths (relative to project root): ${allScanPaths.join(', ')}`);\n\n      try {\n        let isGitRepo = false;\n        let originalBranch: string | null = null;\n        if (!skipGit) {\n          // Git operations should always be relative to the project root\n          isGitRepo = await isGitRepository(projectRoot);\n          if (isGitRepo) {\n            originalBranch = await getCurrentBranch(projectRoot);\n            console.log(\n              `\\n--- Git: Detected Git repository. Current branch: ${originalBranch} ---`,\n            );\n            if (!autoConfirm) {\n              const defaultBranchSuggestion =\n                `ai-feature/${prompt.toLowerCase().replace(/[^a-z0-9]+/g, '-')}`.substring(0, 50);\n              const { proceedGit } = await inquirer.prompt([\n                {\n                  type: 'confirm',\n                  name: 'proceedGit',\n                  message: `Proceed with Git operations (create new branch, stage changes)? Recommended.`,\n                  default: true,\n                },\n              ]);\n              if (!proceedGit) {\n                options.noGit = true;\n              } else {\n                if (!customBranchName) {\n                  const { branchNameInput } = await inquirer.prompt([\n                    {\n                      type: 'input',\n                      name: 'branchNameInput',\n                      message: `Enter new branch name (default: ${defaultBranchSuggestion}):`,\n                      default: defaultBranchSuggestion,\n                    },\n                  ]);\n                  options.branch = branchNameInput;\n                }\n                await createBranch(projectRoot, options.branch!);\n              }\n            } else {\n              if (!options.noGit && !customBranchName) {\n                options.branch =\n                  `ai-feature/${prompt.toLowerCase().replace(/[^a-z0-9]+/g, '-')}`.substring(0, 50);\n                console.log(`Auto-creating branch: ${options.branch}`);\n              }\n              if (!options.noGit && options.branch) {\n                await createBranch(projectRoot, options.branch);\n              }\n            }\n          } else {\n            console.log(`\\n--- Git: Not a Git repository. Skipping Git operations. ---`);\n            options.noGit = true;\n          }\n        } else {\n          console.log(`\\n--- Git: Skipping Git operations as requested. ---`);\n        }\n\n        console.log('\\n--- Step 1: Scanning project files ---');\n        // Pass the array of allScanPaths, and the projectRoot for context.\n        const scannedFiles: ScannedFile[] = await scanProject(allScanPaths, projectRoot);\n        console.log(`Found ${scannedFiles.length} files.`);\n\n        const originalFileContents = new Map<string, string>();\n        scannedFiles.forEach((file) => originalFileContents.set(file.filePath, file.content));\n\n        console.log('\\n--- Step 2: Preparing LLM context ---');\n        // Generate a simple project structure string from the scanned files\n        const projectStructure = generateProjectStructureString(scannedFiles);\n\n        const llmInput: LLMInput = {\n          userPrompt: prompt,\n          projectRoot: projectRoot,\n          projectStructure: projectStructure,\n          relevantFiles: scannedFiles,\n          additionalInstructions: `${INSTRUCTION}`.replace(/^\\s+/gm, ''), // Clean up leading whitespace\n          expectedOutputFormat: `${ADDIONAL_INSTRUCTION_EXPECTED_OUTPUT}`.replace(/^\\s+/gm, ''), // Clean up leading whitespace\n        };\n\n        console.log('\\n--- Step 3: Calling LLM ---');\n        const llmOutput: LLMOutput = await callLLM(llmInput, projectRoot); // Pass projectRoot for potential LLM calls that need it\n\n        console.log('\\n--- Step 4: LLM Proposed Changes ---');\n        console.log(`Summary: ${llmOutput.summary}`);\n        if (llmOutput.thoughtProcess) {\n          console.log(`Thought Process:\\n${llmOutput.thoughtProcess}`);\n        }\n\n        if (llmOutput.changes.length === 0) {\n          console.log('No changes proposed by the LLM. Exiting.');\n          return;\n        }\n\n        console.log('\\nReviewing Proposed File Changes:');\n        const changesToApply: ProposedFileChange[] = [];\n        const filesModifiedOrAdded: string[] = [];\n\n        for (const change of llmOutput.changes) {\n          // Paths displayed to user should be relative to project root (or CWD)\n          const relativePathForDisplay = path.relative(projectRoot, change.filePath);\n          console.log(\n            `\\n--- Proposed Change for: ${relativePathForDisplay} (${change.action.toUpperCase()}) ---`,\n          );\n          if (change.reason) {\n            console.log(`Reason: ${change.reason}`);\n          }\n\n          if (change.action === 'add') {\n            console.log('This will create a NEW file.');\n            console.log('New Content Preview (first 20 lines):');\n            console.log('```typescript'); // Assuming TypeScript for code preview\n            console.log(change.newContent?.split('\\n').slice(0, 20).join('\\n'));\n            if (change.newContent && change.newContent.split('\\n').length > 20) {\n              console.log('...');\n            }\n            console.log('```');\n          } else if (change.action === 'modify') {\n            const originalContent = originalFileContents.get(change.filePath) || '';\n            const diff = generateUnifiedDiff(originalContent, change.newContent || '');\n            if (diff) {\n              console.log('Changes (diff):');\n              console.log(diff);\n            } else {\n              console.log(\n                'No effective changes detected (content is identical). Skipping this modification.',\n              );\n              continue;\n            }\n          } else if (change.action === 'delete') {\n            console.log('This will DELETE the file.');\n          }\n\n          if (autoConfirm) {\n            console.log('Auto-confirming this change (--yes flag).');\n            changesToApply.push(change);\n            filesModifiedOrAdded.push(change.filePath);\n          } else {\n            const { confirm } = await inquirer.prompt([\n              {\n                type: 'list',\n                name: 'confirm',\n                message: `Apply this change to ${relativePathForDisplay}?`,\n                choices: [\n                  { name: 'Yes (apply this change)', value: 'yes' },\n                  { name: 'No (skip this change)', value: 'no' },\n                  { name: 'Apply All (apply this and all subsequent changes)', value: 'all' },\n                  { name: 'Abort (stop entirely)', value: 'abort' },\n                ],\n              },\n            ]);\n\n            if (confirm === 'yes') {\n              changesToApply.push(change);\n              filesModifiedOrAdded.push(change.filePath);\n            } else if (confirm === 'all') {\n              changesToApply.push(change);\n              filesModifiedOrAdded.push(change.filePath);\n              options.yes = true; // Set autoConfirm for subsequent loops\n            } else if (confirm === 'abort') {\n              console.log('Aborting changes. No files modified.');\n              if (isGitRepo && !options.noGit && options.branch && originalBranch) {\n                console.log(`Reverting to original branch: ${originalBranch}`);\n\n                await getGit(projectRoot).checkout(originalBranch);\n              }\n              return;\n            } else {\n              console.log(`Skipping change for ${relativePathForDisplay}.`);\n            }\n          }\n        }\n\n        if (changesToApply.length === 0) {\n          console.log('\\nNo changes were confirmed. Exiting.');\n          if (isGitRepo && !options.noGit && options.branch && originalBranch) {\n            console.log(`Reverting to original branch: ${originalBranch}`);\n            await getGit(projectRoot).checkout(originalBranch);\n          }\n          return;\n        }\n\n        console.log('\\n--- Applying Confirmed Changes ---');\n        for (const change of changesToApply) {\n          try {\n            await applyFileChange(projectRoot, change); // applyFileChange needs projectRoot or baseDir\n          } catch (fileError) {\n            console.error(\n              `Failed to apply change for ${change.filePath}: ${(fileError as Error).message}`,\n            );\n          }\n        }\n\n        console.log('\\n--- Changes Applied Successfully! ---');\n\n        if (isGitRepo && !options.noGit) {\n          console.log('\\n--- Git: Staging changes ---');\n          await stageFiles(projectRoot, filesModifiedOrAdded);\n\n          console.log('\\nNext Steps:');\n          console.log(\n            `1. Your changes have been applied and staged on branch '${options.branch || originalBranch}'.`,\n          );\n          console.log(`2. Review the changes using 'git diff --staged'.`);\n          console.log(`3. Commit your changes:`);\n          console.log(`   git commit -m \"${llmOutput.summary}\"`);\n          console.log(`4. Run your tests to ensure everything still works as expected.`);\n          console.log(\n            `5. If you want to revert to the previous branch: git checkout ${originalBranch}`,\n          );\n        } else {\n          console.log('\\nNext Steps:');\n          console.log(`1. It's highly recommended to review the changes in your editor.`);\n          if (isGitRepo) {\n            console.log(`2. You skipped Git operations. To commit, you'll need to manually:`);\n            console.log(`   git add .`);\n            console.log(`   git commit -m \"${llmOutput.summary}\"`);\n          } else {\n            console.log(\n              `2. This is not a Git repository. Consider initializing one if this is a project:`,\n            );\n            console.log(`   git init`);\n            console.log(`   git add .`);\n            console.log(`   git commit -m \"Initial commit by AI Editor\"`);\n          }\n          console.log(`3. Run your tests to ensure everything still works as expected.`);\n        }\n      } catch (error) {\n        console.error(`Error during generation: ${(error as Error).message}`);\n        process.exit(1);\n      }\n    },\n  );\n\nprogram.parse(process.argv);\n\nfunction getGit(baseDir: string): SimpleGit {\n  return simpleGit(baseDir, { binary: 'git' });\n}\n\n/**\n * Generates a simple tree-like string representing the project structure\n * based on the relative paths of scanned files.\n * This structure is intended to provide high-level context to the LLM.\n *\n * @param scannedFiles An array of ScannedFile objects.\n * @returns A string representing the project structure.\n */\nfunction generateProjectStructureString(scannedFiles: ScannedFile[]): string {\n  const structurePaths: Set<string> = new Set();\n  const sortedRelativePaths = scannedFiles.map(f => f.relativePath).sort(); // Sort for consistent output\n\n  // Add all file paths and their parent directories to the set\n  for (const relPath of sortedRelativePaths) {\n    let currentSegment = '';\n    const parts = relPath.split(path.sep);\n    for (let i = 0; i < parts.length; i++) {\n      currentSegment = path.join(currentSegment, parts[i]);\n      if (i === parts.length - 1) { // It's a file\n        structurePaths.add(currentSegment);\n      } else { // It's a directory\n        structurePaths.add(currentSegment + path.sep); // Add trailing slash for directories\n      }\n    }\n  }\n\n  // Convert the set to a sorted array for consistent output\n  const items = Array.from(structurePaths).sort();\n\n  const structuredLines: string[] = [];\n  items.forEach(item => {\n    // Determine depth for indentation. Count path separators.\n    // For directories (ending with sep), count parts-1. For files, count parts.\n    const depth = item.split(path.sep).length - (item.endsWith(path.sep) ? 1 : 0);\n    const indent = '  '.repeat(Math.max(0, depth)); // Ensure non-negative depth\n    structuredLines.push(`${indent}- ${item}`);\n  });\n\n  return structuredLines.join('\\n');\n}\n\n\n// File: ../ai-assistant/ai-editor/src/scanner.ts\nimport { promises as fs } from 'fs';\nimport * as path from 'path';\nimport { ScannedFile } from './types'; // Import our updated type\n\n/**\n * Defines file extensions relevant to frontend development and general code.\n */\nconst RELEVANT_FILE_EXTENSIONS = new Set([\n  '.ts', '.tsx', '.js', '.jsx', '.json', '.md', '.yml', '.html', '.css', '.scss', '.less',\n  '.cjs', '.mjs', '.toml', '.xml', // config and module types\n  '.jsonc', // JSON with comments\n  '.vue', '.svelte', // Frontend frameworks\n  '.graphql', '.gql', // GraphQL schema/queries\n  '.sql', // Database schemas\n  '.py', '.rb', '.go', '.java', '.c', '.cpp', '.cs', '.php', // Backend/other languages\n  '.sh', '.bash', '.zsh', // Shell scripts\n  '.env', // Environment files\n  '.txt', // Plain text\n]);\n\n/**\n * Directories to always exclude from scanning, regardless of depth.\n * These are matched by their exact name (basename).\n */\nconst EXCLUDE_DIR_NAMES = new Set([\n  'node_modules', '.git', '.vscode', '.idea', 'dist', 'build', 'out', 'coverage',\n  '__pycache__', 'venv', 'target', 'vendor', '.ai-editor-logs'// common for other languages\n]);\n\n/**\n * Specific file names to always exclude from scanning, regardless of depth.\n * These are matched by their exact name (basename).\n */\nconst EXCLUDE_FILE_NAMES = new Set([\n  'package-lock.json', 'yarn.lock', 'pnpm-lock.yaml', '.DS_Store', // Lock files and system files\n]);\n\n/**\n * Specific file names that should always be included, even if their extension is not in RELEVANT_FILE_EXTENSIONS,\n * or if they are common dotfiles (e.g., config files).\n */\nconst RELEVANT_CONFIG_FILENAMES = new Set([\n  'package.json', 'tsconfig.json', 'vite.config.ts', 'webpack.config.js',\n  'rollup.config.js', 'tailwind.config.ts', '.gitignore', '.eslintrc.js',\n  '.prettierrc.js', 'Dockerfile', 'Makefile', 'LICENSE', 'README.md', 'README.txt',\n  'biome.json', 'jest.config.ts',\n  '.env.local', '.env.development', '.env.production', // Specific .env files\n]);\n\n\n/**\n * Scans specified paths (which can be directories or individual files) recursively for relevant code files\n * and reads their content. Ensures file paths are absolute and also provides a path relative to the project root.\n * Handles multiple scan paths and deduplicates files.\n *\n * @param scanPaths An array of paths (relative or absolute) to scan. Each path can be a directory or a file.\n * @param projectRoot The root directory of the project, used for calculating relative paths.\n * @param verbose If true, logs detailed information during scanning.\n * @returns A promise that resolves to an array of ScannedFile objects.\n */\nexport async function scanProject(\n  scanPaths: string[],\n  projectRoot: string,\n  verbose: boolean = false\n): Promise<ScannedFile[]> {\n  const allScannedFiles: ScannedFile[] = [];\n  const processedAbsolutePaths = new Set<string>(); // To deduplicate files if multiple scan paths overlap\n\n  // Process each path in the input array\n  for (const currentPath of scanPaths) {\n    const absolutePath = path.resolve(projectRoot, currentPath);\n\n    if (processedAbsolutePaths.has(absolutePath)) {\n      if (verbose) {\n        console.log(`  Skipping '${absolutePath}' (already processed).`);\n      }\n      continue;\n    }\n\n    let stats;\n    try {\n      stats = await fs.stat(absolutePath);\n    } catch (error) {\n      console.error(`Error accessing path '${absolutePath}': ${(error as Error).message}. Skipping.`);\n      continue;\n    }\n\n    if (stats.isFile()) {\n      // If the path is an explicit file, include it directly\n      try {\n        const content = await fs.readFile(absolutePath, 'utf-8');\n        const relativeToProjectRoot = path.relative(projectRoot, absolutePath);\n        allScannedFiles.push({\n          filePath: absolutePath,\n          relativePath: relativeToProjectRoot,\n          content: content,\n        });\n        processedAbsolutePaths.add(absolutePath);\n        if (verbose) {\n          console.log(`  Included explicit file: ${relativeToProjectRoot}`);\n        }\n      } catch (readError) {\n        console.warn(`Warning: Could not read explicit file '${absolutePath}': ${(readError as Error).message}`);\n      }\n    } else if (stats.isDirectory()) {\n      // If the path is a directory, use the recursive scanning logic\n      if (verbose) {\n        console.log(`  Initiating recursive scan for directory: ${absolutePath}`);\n      }\n      const queue: string[] = [absolutePath];\n\n      while (queue.length > 0) {\n        const currentDir = queue.shift()!;\n        let entries;\n        try {\n          entries = await fs.readdir(currentDir, { withFileTypes: true });\n        } catch (error) {\n          console.error(`Error reading directory '${currentDir}': ${(error as Error).message}. Skipping.`);\n          continue;\n        }\n\n        for (const entry of entries) {\n          const entryFullPath = path.join(currentDir, entry.name);\n          const relativeToProjectRoot = path.relative(projectRoot, entryFullPath);\n\n          // --- Exclusion Logic for recursive directory scanning ---\n          // 1. Exclude specific directory names (e.g., node_modules, .git)\n          if (entry.isDirectory() && EXCLUDE_DIR_NAMES.has(entry.name)) {\n            if (verbose) {\n              console.log(`    Excluding directory: ${relativeToProjectRoot}`);\n            }\n            continue;\n          }\n\n          // 2. Exclude specific file names (e.g., package-lock.json, .DS_Store)\n          if (entry.isFile() && EXCLUDE_FILE_NAMES.has(entry.name)) {\n            if (verbose) {\n              console.log(`    Excluding file: ${relativeToProjectRoot}`);\n            }\n            continue;\n          }\n\n          if (entry.isDirectory()) {\n            queue.push(entryFullPath);\n          } else if (entry.isFile()) {\n            const ext = path.extname(entry.name).toLowerCase();\n\n            // Determine if the file should be included based on extension or explicit filename\n            const isIncluded = RELEVANT_FILE_EXTENSIONS.has(ext) || RELEVANT_CONFIG_FILENAMES.has(entry.name);\n\n            if (isIncluded) {\n              // Add file only if its absolute path hasn't been processed yet (for deduplication)\n              if (!processedAbsolutePaths.has(entryFullPath)) {\n                try {\n                  const content = await fs.readFile(entryFullPath, 'utf-8');\n                  allScannedFiles.push({\n                    filePath: entryFullPath, // Absolute path\n                    relativePath: relativeToProjectRoot, // Path relative to project root\n                    content: content,\n                  });\n                  processedAbsolutePaths.add(entryFullPath); // Mark as processed\n                  if (verbose) {\n                    console.log(`    Included: ${relativeToProjectRoot}`);\n                  }\n                } catch (readError) {\n                  console.warn(`Warning: Could not read file '${entryFullPath}': ${(readError as Error).message}`);\n                }\n              } else if (verbose) {\n                console.log(`    Skipping (already processed): ${relativeToProjectRoot}`);\n              }\n            } else {\n              if (verbose) {\n                console.log(`    Skipping file: ${relativeToProjectRoot} (unsupported type)`);\n              }\n            }\n          }\n        }\n      }\n    } else {\n      console.warn(`Warning: '${absolutePath}' is neither a file nor a directory. Skipping.`);\n    }\n  }\n\n  return allScannedFiles;\n}\n\n\n// File: ../ai-assistant/ai-editor/src/types.ts\n// src/types.ts\n\n/**\n * Represents a file that has been scanned from the project,\n * including its absolute path, its path relative to the project root, and its textual content.\n */\nexport interface ScannedFile {\n  filePath: string; // Absolute path to the file\n  relativePath: string; // Path relative to the project root (e.g., \"src/components/MyComponent.tsx\")\n  content: string;\n}\n\n/**\n * Represents a proposed change to a file.\n * This is the structured output we expect from the LLM.\n */\nexport interface ProposedFileChange {\n  filePath: string; // Absolute path to the file to be changed\n  action: 'add' | 'modify' | 'delete';\n  /**\n   * For 'add' or 'modify' actions, this is the new content of the file.\n   * For 'delete' actions, this field is not used.\n   */\n  newContent?: string;\n  /**\n   * An optional human-readable reason or summary for the change.\n   */\n  reason?: string;\n}\n\n/**\n * Represents the structured input that will be sent to the LLM.\n */\nexport interface LLMInput {\n  userPrompt: string;\n  projectRoot: string;\n  projectStructure: string; // A high-level overview of the project directory (e.g., tree string)\n  relevantFiles: ScannedFile[];\n  additionalInstructions: string; // Specific behavioral instructions for the LLM\n  expectedOutputFormat: string; // Instructions on the JSON format for the LLM's response\n}\n\n/**\n * Represents the structured output received from the LLM.\n */\nexport interface LLMOutput {\n  changes: ProposedFileChange[];\n  summary: string; // A concise summary of all changes made/proposed\n  thoughtProcess?: string; // LLM's detailed reasoning for the changes\n}\n\n\n\n// File: ../ai-assistant/ai-editor/src/file-operations/diffGenerator.ts\n // src/file-operations/diffGenerator.ts\nimport * as Diff from 'diff';\nimport chalk from 'chalk'; // For colorful console output (install if you don't have it: npm i chalk)\n\n// Ensure chalk is installed: npm install chalk@4.1.2 (or latest version)\n// Note: chalk v5+ is ESM only, so using v4 for CommonJS compatibility with ts-node without extra config.\n// If you want to use chalk v5+, you might need to adjust tsconfig.json to \"module\": \"ESNext\" and add \"type\": \"module\" to package.json.\n\n/**\n * Generates a human-readable diff string between two text contents.\n * @param originalContent The original content of the file.\n * @param newContent The proposed new content of the file.\n * @returns A string representing the unified diff, or an empty string if contents are identical.\n */\nexport function generateUnifiedDiff(originalContent: string, newContent: string): string {\n  // Use Diff.createPatch for a standard unified diff format\n  // For simpler line-by-line diffs without patch headers, Diff.diffLines is also an option.\n  const diff = Diff.diffLines(originalContent, newContent);\n\n  if (diff.length === 1 && diff[0].added === undefined && diff[0].removed === undefined) {\n    return ''; // No changes\n  }\n\n  let diffString = '';\n  diff.forEach(part => {\n    // green for additions, red for deletions, white for common parts\n    const color = part.added ? chalk.green :\n                  part.removed ? chalk.red :\n                  chalk.grey; // Changed to grey for context lines\n    const prefix = part.added ? '+ ' :\n                   part.removed ? '- ' :\n                   '  '; // Indent common lines\n    // Add prefix to each line\n    diffString += color(part.value.split('\\n').map(line => prefix + line).join('\\n'));\n  });\n\n  return diffString;\n}\n\n\n// File: ../ai-assistant/ai-editor/src/file-operations/fileApplier.ts\n// src/file-operations/fileApplier.ts\nimport { promises as fs } from 'fs';\nimport * as path from 'path';\nimport { ProposedFileChange } from '../types';\n\n/**\n * Applies a single proposed file change (add, modify, or delete) to the file system.\n * Ensures parent directories exist for 'add' actions.\n * @param projectRoot The absolute path to the root of the target project.\n * @param change The ProposedFileChange object.\n * @returns A Promise that resolves when the operation is complete.\n */\nexport async function applyFileChange(projectRoot: string, change: ProposedFileChange): Promise<void> {\n  // Resolve the absolute path using the provided projectRoot\n  const absolutePath = path.resolve(projectRoot, change.filePath);\n\n  switch (change.action) {\n    case 'add':\n      // Ensure the directory exists before writing the file\n      const dir = path.dirname(absolutePath);\n      await fs.mkdir(dir, { recursive: true });\n      if (change.newContent === undefined) {\n        throw new Error(`Cannot add file '${change.filePath}': newContent is undefined.`);\n      }\n      await fs.writeFile(absolutePath, change.newContent, 'utf-8');\n      console.log(`  ➕ Created: ${path.relative(projectRoot, absolutePath)}`); // Log path relative to project\n      break;\n\n    case 'modify':\n      // Check if the file exists before attempting to modify\n      try {\n        await fs.access(absolutePath); // Throws if file doesn't exist\n      } catch {\n        throw new Error(`Cannot modify file '${change.filePath}': File does not exist in target project.`);\n      }\n      if (change.newContent === undefined) {\n        throw new Error(`Cannot modify file '${change.filePath}': newContent is undefined.`);\n      }\n      await fs.writeFile(absolutePath, change.newContent, 'utf-8');\n      console.log(`  ✏️ Modified: ${path.relative(projectRoot, absolutePath)}`); // Log path relative to project\n      break;\n\n    case 'delete':\n      // Check if the file exists before attempting to delete\n      try {\n        await fs.access(absolutePath);\n      } catch {\n        throw new Error(`Cannot delete file '${change.filePath}': File does not exist in target project.`);\n      }\n      await fs.unlink(absolutePath);\n      console.log(`  🗑️ Deleted: ${path.relative(projectRoot, absolutePath)}`); // Log path relative to project\n      // Optional: Recursively delete empty parent directories\n      await cleanupEmptyParentDirectories(projectRoot, absolutePath); // Pass projectRoot here\n      break;\n\n    default:\n      throw new Error(`Unknown action type: ${(change as any).action}`);\n  }\n}\n\n/**\n * Attempts to delete empty parent directories after a file is deleted.\n * Stops at the first non-empty or non-existent directory.\n * @param projectRoot The absolute path to the root of the target project.\n * @param filePath The path of the file that was deleted (absolute path).\n */\nasync function cleanupEmptyParentDirectories(projectRoot: string, filePath: string): Promise<void> {\n  let currentDir = path.dirname(filePath); // This filePath is already absolute\n  // const projectRoot = process.cwd(); // This line is now removed or changed\n\n  // Walk up the directory tree\n  // Stop when currentDir reaches the projectRoot or the system root\n  while (currentDir !== projectRoot && currentDir !== path.parse(currentDir).root) {\n    try {\n      const entries = await fs.readdir(currentDir);\n      if (entries.length === 0) {\n        // Directory is empty, delete it\n        await fs.rmdir(currentDir);\n        console.log(`  🧹 Cleaned up empty directory: ${path.relative(projectRoot, currentDir)}`);\n        currentDir = path.dirname(currentDir); // Move up to parent\n      } else {\n        // Directory is not empty, stop\n        break;\n      }\n    } catch (error) {\n      // If directory doesn't exist or other error, stop\n      break;\n    }\n  }\n}\n\n\n// File: ../ai-assistant/ai-editor/src/git-operations/gitManager.ts\n // src/git-operations/gitManager.ts\nimport simpleGit, { SimpleGit, CleanOptions, CheckRepoActions } from 'simple-git'; \nimport * as path from 'path';\n\n/**\n * Initializes a simple-git instance for the given directory.\n * @param baseDir The base directory of the Git repository.\n * @returns A SimpleGit instance.\n */\nfunction getGit(baseDir: string): SimpleGit {\n  return simpleGit(baseDir, { binary: 'git' });\n}\n\n/**\n * Checks if the given directory is a Git repository.\n * @param dirPath The path to check.\n * @returns True if it's a Git repo, false otherwise.\n */\nexport async function isGitRepository(dirPath: string): Promise<boolean> {\n  try {\n    const git = getGit(dirPath);\n    // Correct usage: CheckRepoActions.IS_GIT_REPO checks if the path is inside any Git repo\n    // or CheckRepoActions.IS_REPO_ROOT if you only want to verify it's the .git directory root.\n    await git.checkIsRepo(CheckRepoActions.IS_REPO_ROOT ); // <-- CHANGE THIS LINE\n    return true;\n  } catch (error) {\n    // This typically throws if it's not a repo.\n    return false;\n  }\n}\n\n/**\n * Creates a new Git branch.\n * @param repoPath The path to the Git repository.\n * @param branchName The name of the new branch to create.\n */\nexport async function createBranch(repoPath: string, branchName: string): Promise<void> {\n  const git = getGit(repoPath);\n  try {\n    await git.branch([branchName]);\n    await git.checkout(branchName);\n    console.log(`  ✅ Git: Created and checked out new branch: ${branchName}`);\n  } catch (error) {\n    console.warn(`  ⚠️ Git: Could not create or checkout branch '${branchName}': ${(error as Error).message}`);\n    // If branch already exists, it might just checkout. If it's a fatal error, rethrow.\n    if ((error as Error).message.includes('A branch named') && (error as Error).message.includes('already exists')) {\n        console.warn(`  ⚠️ Git: Branch '${branchName}' already exists. Checking it out instead.`);\n        await git.checkout(branchName);\n    } else {\n        throw error; // Re-throw unhandled errors\n    }\n  }\n}\n\n/**\n * Stages (adds) specified files to the Git index.\n * @param repoPath The path to the Git repository.\n * @param filePaths An array of file paths (relative to repoPath) to stage.\n */\nexport async function stageFiles(repoPath: string, filePaths: string[]): Promise<void> {\n  const git = getGit(repoPath);\n  try {\n    // Convert absolute paths to paths relative to the repo root for git add\n    const relativePaths = filePaths.map(filePath => path.relative(repoPath, filePath));\n    await git.add(relativePaths);\n    console.log(`  ✅ Git: Staged ${filePaths.length} files.`);\n  } catch (error) {\n    console.error(`  ❌ Git: Failed to stage files: ${(error as Error).message}`);\n    throw error;\n  }\n}\n\n/**\n * Gets the current branch name.\n * @param repoPath The path to the Git repository.\n * @returns The name of the current branch, or null if not in a branch.\n */\nexport async function getCurrentBranch(repoPath: string): Promise<string | null> {\n    const git = getGit(repoPath);\n    try {\n        const branchSummary = await git.branchLocal();\n        return branchSummary.current;\n    } catch (error) {\n        // Not a git repo, or other error\n        return null;\n    }\n}\n\n\n// File: ../ai-assistant/ai-editor/src/llm/contextPreparer.ts\n// src/llm/contextPreparer.ts\nimport * as path from 'path';\nimport { ScannedFile, LLMInput } from '../types';\n\n/**\n * Prepares the context for the LLM by structuring the user prompt,\n * relevant files, and system instructions into a single LLMInput object.\n *\n * @param userPrompt The natural language request from the user.\n * @param scannedFiles An array of all files scanned from the project.\n * @param projectRoot The absolute path to the project's root directory.\n * @returns An LLMInput object ready to be sent to the LLM.\n */\nexport function prepareContextForLLM(userPrompt: string, scannedFiles: ScannedFile[], projectRoot: string): LLMInput {\n\n  // 1. Generate a simplified project structure string using relative paths\n  const projectStructureLines = scannedFiles\n    .map(file => file.relativePath) // Use the relativePath from ScannedFile\n    .sort()\n    .map(relPath => `- ${relPath}`);\n\n  const projectStructure = `Project File Structure (relative to root):\\n${projectStructureLines.join('\\n')}\\n`;\n\n  // 2. Define the expected output format for the LLM\n  const outputSchema = `\n            Your response must be a JSON object with two top-level keys: 'summary' (string) and 'changes' (array of objects).\n            The 'changes' array should contain objects, each representing a file operation:\n            {\n              \"filePath\": \"path/to/file.tsx\", // Absolute path (use path.join(projectRoot, relativePath) to construct)\n              \"action\": \"add\" | \"modify\" | \"delete\",\n              \"newContent\"?: \"...\", // Required for 'add'/'modify', omit for 'delete'\n              \"reason\"?: \"...\" // Optional, short explanation for this specific file change\n            }\n            Example:\n            {\n              \"summary\": \"Implemented user authentication and updated Navbar component.\",\n              \"thoughtProcess\": \"Created new components for login and signup, updated navigation to include auth links, and added a basic auth context.\",\n              \"changes\": [\n                {\n                  \"filePath\": \"/path/to/project/src/auth/Login.tsx\",\n                  \"action\": \"add\",\n                  \"newContent\": \"import React from 'react';\\\\nimport { useStore } from '@nanostores/react';\\\\nimport { authStore } from './authStore';\\\\n\\\\nfunction Login() {\\\\n  const $auth = useStore(authStore);\\\\n  // ... login form logic\\\\n  return <div className='p-4'>Login Form</div>;\\\\n}\\\\nexport default Login;\",\n                  \"reason\": \"New login component for user authentication.\"\n                },\n                {\n                  \"filePath\": \"/path/to/project/src/components/Navbar.tsx\",\n                  \"action\": \"modify\",\n                  \"newContent\": \"import React from 'react';\\\\nimport { Link } from 'react-router-dom';\\\\nimport { useStore } from '@nanostores/react';\\\\nimport { authStore } from '../auth/authStore';\\\\n\\\\nfunction Navbar() {\\\\n  const $auth = useStore(authStore);\\\\n  return (\\\\n    <nav className='bg-blue-500 p-4 text-white flex justify-between'>\\\\n      <Link to='/' className='font-bold text-lg'>My App</Link>\\\\n      <div>\\\\n        {$auth.isLoggedIn ? (\\\\n          <button onClick={() => authStore.setKey('isLoggedIn', false)} className='ml-4'>Logout</button>\\\\n        ) : (\\\\n          <>\\\\n            <Link to='/login' className='ml-4'>Login</Link>\\\\n            <Link to='/signup' className='ml-4'>Signup</Link>\\\\n          </>\\\\n        )}\\\\n      </div>\\\\n    </nav>\\\\n  );\\\\n}\\\\nexport default Navbar;\",\n                  \"reason\": \"Added login/logout links to Navbar based on authentication status.\"\n                },\n                {\n                  \"filePath\": \"/path/to/project/src/old/DeprecatedComponent.ts\",\n                  \"action\": \"delete\",\n                  \"reason\": \"Removed unused component as part of refactor.\"\n                }\n              ]\n            }\n          `.replace(/^\\s+/gm, '');\n\n  // 3. Construct additional instructions for the LLM\n  const additionalInstructions = `\nYou are an elite TypeSafe UI Architect. Your goal is to generate or modify code to fulfill the user's request, strictly adhering to modern frontend best practices.\nFocus on TypeScript, React (with Hooks and nanostores where applicable), and Tailwind CSS v4.\nGenerate clean, idiomatic, production-ready code.\nAlways propose a clear, refactored, and logically separated file and folder structure.\nConsider type safety paramount.\nIf the request involves new components, ensure they are well-structured, reusable, and include necessary imports and typings.\nIf modifying existing components, ensure backward compatibility where reasonable, or clearly state breaking changes.\nWhen generating new code, ensure it aligns with the existing project's style (indentation, semicolons, etc.).\nDo not make assumptions about external APIs unless specified.\nIf you need to add a new file, propose the full content of that new file.\nIf you need to modify an existing file, propose the full new content of that file.\nIf you need to delete a file, specify its path and action 'delete'.\n`;\n\n  return {\n    userPrompt: userPrompt,\n    projectRoot: projectRoot,\n    projectStructure: projectStructure,\n    relevantFiles: scannedFiles,\n    additionalInstructions: additionalInstructions,\n    expectedOutputFormat: outputSchema,\n  };\n}\n\n/**\n * This function will construct the final prompt string that is sent to the LLM.\n * This combines all parts of the LLMInput into a single markdown-formatted string.\n * @param llmInput The structured input object.\n * @param projectRoot The project root (passed to ensure consistency, but `llmInput.projectRoot` is the primary source).\n * @returns A string representing the full prompt for the LLM.\n */\nexport function buildLLMPrompt(llmInput: LLMInput, projectRoot: string): string {\n  // Use `file.relativePath` from `scannedFiles` for the prompt, as it's cleaner for LLM context.\n  const formattedRelevantFiles = llmInput.relevantFiles.map(file => {\n    return `// File: ${file.relativePath}\\n${file.content}`;\n  }).join('\\n\\n'); // Separate files with double newlines\n\n  return `\n# AI Code Generation Request\n\n## User Request\n\\`\\`\\`text\n${llmInput.userPrompt}\n\\`\\`\\`\n\n## Project Context\n${llmInput.projectStructure}\n\n### Relevant Files (for analysis)\n\\`\\`\\`files\n${formattedRelevantFiles}\n\\`\\`\\`\n`;\n}\n\n\n// File: ../ai-assistant/ai-editor/src/llm/jsonRepair.ts\n// src/llm/jsonRepair.ts\n\n/**\n * Attempts to repair common bad escape sequences in a JSON string\n * that might be returned by an LLM.\n * This function primarily focuses on fixing lone backslashes within string values\n * that cause JSON parsing errors.\n *\n * It is assumed that the LLM, when instructed to return JSON (e.g., with responseMimeType: \"application/json\"),\n * generally handles standard string escapes like `\\n`, `\\t`, `\\\"` correctly.\n * This repair function is a fallback for common minor deviations, mainly malformed backslashes.\n *\n * @param jsonString The potentially malformed JSON string.\n * @returns A repaired JSON string, or the original string if no repairs were made.\n */\nexport function repairJsonBadEscapes(jsonString: string): string {\n  let repaired = jsonString;\n\n  // IMPORTANT: Removed the replacement for unescaped newlines/tabs/carriage returns.\n  // These replacements (e.g., `/(?<!\\\\)\\n/g, '\\\\n'`) were incorrectly converting\n  // structural newlines (used for JSON pretty-printing) into escaped newlines (`\\n` -> `\\\\n`),\n  // which makes the JSON invalid at the structural level.\n  // JSON parsers expect literal newlines/tabs for formatting outside of string literals.\n  // If a newline is inside a string value, the LLM should already be providing `\\\\n`.\n\n  // 1. Escape lone backslashes that are not part of a valid JSON escape sequence.\n  // This regex targets backslashes not followed by another backslash or a standard JSON escape char.\n  // Example: \"C:\\path\\to\\file\" should become \"C:\\\\path\\\\to\\\\file\"\n  // The `(?!...)` is a negative lookahead, ensuring the backslash is not followed by\n  // a valid JSON escape character (\", \\, /, b, f, n, r, t, u (for unicode escapes)).\n  // This is the most common and relatively safe repair for paths or other literal backslashes within string values.\n  repaired = repaired.replace(/\\\\(?![\"\\\\/bfnrtu])/g, '\\\\\\\\');\n\n  return repaired; // Return the repaired string\n}\n\n\n// File: ../ai-assistant/ai-editor/src/llm/llmOrchestrator.ts\nimport { promises as fs } from 'fs';\nimport * as path from 'path';\nimport { GoogleGenerativeAI, HarmCategory, HarmBlockThreshold } from '@google/generative-ai';\nimport { LLMInput, LLMOutput, ProposedFileChange } from '../types';\nimport { buildLLMPrompt } from './contextPreparer';\nimport { repairJsonBadEscapes } from './jsonRepair';\n\n// Access your API key (ensure dotenv is configured in index.ts)\nconst API_KEY = process.env.GOOGLE_GEMINI_API_KEY;\nconst MODEL = process.env.GOOGLE_GEMINI_MODEL || 'gemini-1.5-pro-latest'; // Added a default model for robustness\n\nif (!API_KEY) {\n  console.error('Error: GOOGLE_GEMINI_API_KEY environment variable not set.');\n  console.error('Please create a .env file in the project root with GOOGLE_GEMINI_API_KEY=\"YOUR_API_KEY\".');\n  process.exit(1);\n}\n\nconst genAI = new GoogleGenerativeAI(API_KEY);\n\n// Choose a model. Gemini 1.5 Pro is generally good for coding.\nconst model = genAI.getGenerativeModel({ model: MODEL });\n\n// Safety settings to ensure generated content is appropriate\nconst safetySettings = [\n  {\n    category: HarmCategory.HARM_CATEGORY_HARASSMENT,\n    threshold: HarmBlockThreshold.BLOCK_NONE, // Adjust as needed, BLOCK_NONE can lead to more candid responses, but potentially harmful ones. BLOCK_LOW_AND_ABOVE is safer default.\n  },\n  {\n    category: HarmCategory.HARM_CATEGORY_HATE_SPEECH,\n    threshold: HarmBlockThreshold.BLOCK_NONE,\n  },\n  {\n    category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT,\n    threshold: HarmBlockThreshold.BLOCK_NONE,\n  },\n  {\n    category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT,\n    threshold: HarmBlockThreshold.BLOCK_NONE,\n  },\n];\nconst LOGS_DIR = path.join(process.cwd(), '.ai-editor-logs'); // Logs directory at project root\n\n/**\n * Saves the raw text response from the LLM to a timestamped JSON file.\n * The file is saved in a `.ai-editor-logs` directory at the project root.\n * @param rawText The raw string response from the LLM.\n * @param prompt The original prompt sent to the LLM (for context in the log file).\n */\nasync function saveRawLLMResponse(rawText: string, prompt: string): Promise<void> {\n  try {\n    await fs.mkdir(LOGS_DIR, { recursive: true }); // Ensure log directory exists\n\n    const timestamp = new Date().toISOString().replace(/[:.]/g, '-'); // YYYY-MM-DDTHH-MM-SS-MSZ\n    const fileName = `llm-response-${timestamp}.json`; // Using .json as it's expected to be JSON\n    const filePath = path.join(LOGS_DIR, fileName);\n\n    const logContent = {\n      timestamp: new Date().toISOString(),\n      prompt: prompt,\n      // Attempt to parse if it's JSON, otherwise store as string for better logging\n      rawLLMResponse: (() => {\n        try {\n          return JSON.parse(rawText);\n        } catch {\n          return rawText;\n        }\n      })(),\n    };\n\n    await fs.writeFile(filePath, JSON.stringify(logContent, null, 2), 'utf-8');\n    console.log(`  📝 Saved raw LLM response to: ${path.relative(process.cwd(), filePath)}`);\n  } catch (error) {\n    console.error(`  ❌ Error saving raw LLM response to file: ${(error as Error).message}`);\n  }\n}\n/**\n * Extracts a JSON string from text that might be wrapped in markdown code blocks.\n * This makes parsing more robust against LLM formatting variations.\n * @param text The raw text from the LLM.\n * @returns The extracted JSON string, or the original text if no JSON block is found.\n */\nfunction extractJsonFromMarkdown(text: string): string {\n    const jsonBlockRegex = /```json\\n([\\s\\S]*?)\\n```/;\n    const match = text.match(jsonBlockRegex);\n    if (match && match[1]) {\n        return match[1].trim();\n    }\n    // If it's not wrapped in a JSON block, assume it's pure JSON and just trim it.\n    return text.trim();\n}\n\n/**\n * Calls the Google Gemini LLM API and processes the structured JSON response.\n *\n * @param input The structured LLMInput object.\n * @returns A promise that resolves to the LLMOutput.\n */\nexport async function callLLM(input: LLMInput, projectRoot: string): Promise<LLMOutput> {\n  const fullPrompt = buildLLMPrompt(input, projectRoot);\n  // This constructs the system instruction based on the LLMInput\n  const systemInstruction = `${input.additionalInstructions}\\n\\n${input.expectedOutputFormat}`;\n\n  console.log('\\n--- Prompt sent to LLM ---');\n  // console.log(fullPrompt); // Uncomment for debugging the full prompt\n  console.log(`Prompt size: ${fullPrompt.length} characters.`);\n  console.log('--------------------------\\n');\n\n  try {\n    const result = await model.generateContent({\n      contents: [{ role: \"user\", parts: [{ text: fullPrompt }] }],\n      // UNCOMMENT THIS LINE TO ADD SYSTEM INSTRUCTION\n      systemInstruction: {role: \"system\",  parts: [{ text: systemInstruction }]},\n      safetySettings,\n      generationConfig: {\n        responseMimeType: \"application/json\",\n      },\n    });\n\n    const response = result.response;\n    let rawText = response.text();\n\n    // Save raw LLM response for debugging and auditing\n    await saveRawLLMResponse(rawText, fullPrompt);\n\n    console.log('\\n--- Raw LLM Response ---');\n    console.log(rawText);\n    console.log('------------------------\\n');\n\n    let cleanedJsonString = extractJsonFromMarkdown(rawText);\n\n    let parsedResult: any; // Use 'any' initially as the top-level structure might vary\n    try {\n      parsedResult = JSON.parse(cleanedJsonString);\n    } catch (jsonError) {\n      console.warn('Warning: Initial JSON parsing failed. Attempting to repair bad escaped characters.');\n      try {\n        const repairedJsonString = repairJsonBadEscapes(cleanedJsonString);\n        parsedResult = JSON.parse(repairedJsonString);\n        console.log('JSON parsing succeeded after repair.');\n      } catch (repairError) {\n        console.error('Error parsing LLM response as JSON even after repair attempt.');\n        console.error('Raw LLM Response before cleaning:', rawText);\n        console.error('Cleaned JSON string attempt:', cleanedJsonString);\n        console.error('Repaired JSON string attempt (which also failed):', (repairError as Error).message);\n        throw new Error(`Invalid JSON response from LLM: ${(jsonError as Error).message}. Repair attempt failed: ${(repairError as Error).message}`);\n      }\n    }\n\n    let llmOutput: LLMOutput;\n\n    // --- Logic to handle array or object structure (already correct) ---\n    if (Array.isArray(parsedResult)) {\n      // If LLM returned an array, assume it's the 'changes' array\n      console.warn(\"LLM returned an array directly instead of the full LLMOutput object. Wrapping it as 'changes'.\");\n      llmOutput = {\n        changes: parsedResult as ProposedFileChange[], // Cast to the expected array type\n        summary: \"Changes proposed by AI (summary not provided by LLM).\", // Default summary\n        thoughtProcess: \"LLM returned only the changes array, so a default summary and thought process are provided.\"\n      };\n    } else if (typeof parsedResult === 'object' && parsedResult !== null) {\n      // If LLM returned an object, validate its structure\n      if (Array.isArray(parsedResult.changes) && typeof parsedResult.summary === 'string') {\n        llmOutput = parsedResult as LLMOutput; // It matches the expected LLMOutput interface\n      } else {\n        // Object, but missing required properties like 'changes' or 'summary'\n        console.error('Parsed LLM output object is missing expected \"changes\" array or \"summary\" string.');\n        console.error('Received object (stringified):', JSON.stringify(parsedResult, null, 2));\n        throw new Error('LLM response object missing expected \"changes\" array or \"summary\" string.');\n      }\n    } else {\n      // Neither an array nor an object, or null\n      console.error('Parsed LLM output is neither an array nor an object, or null:', typeof parsedResult, parsedResult);\n      throw new Error('Invalid top-level JSON structure from LLM. Expected an object or an array.');\n    }\n    // --- End Logic ---\n\n    // Now, `llmOutput` is guaranteed to be an LLMOutput object, proceed with detailed validation of its contents\n    llmOutput.changes.forEach(change => {\n        if (!change.filePath || !['add', 'modify', 'delete'].includes(change.action)) {\n            throw new Error(`Invalid change object found: ${JSON.stringify(change)}. Missing filePath or invalid action.`);\n        }\n        // Warn if newContent is missing for add/modify, but don't stop execution\n        if ((change.action === 'add' || change.action === 'modify') && change.newContent === undefined) {\n             console.warn(`Warning: Change for ${change.filePath} (action: ${change.action}) has undefined newContent. This might be an issue and could lead to empty files.`);\n        }\n    });\n\n    return llmOutput;\n\n  } catch (error: any) {\n    if (error.response && error.response.error) {\n      console.error(`Gemini API Error: ${error.response.error.message}`);\n      if (error.response.error.details) {\n        console.error('Details:', error.response.error.details);\n      }\n      if (error.response.error.status) {\n        console.error('Status:', error.response.error.status);\n      }\n    } else {\n      console.error(`Error calling LLM: ${(error as Error).message}`);\n    }\n    throw new Error(`Failed to get response from LLM: ${(error as Error).message}`);\n  }\n}\n\n```\n",
  "rawLLMResponse": {
    "summary": "Implemented OAuth authentication flow for the `ai-editor` CLI, allowing users to log in via Google or GitHub. This involves creating a local HTTP server in the CLI to intercept OAuth callbacks, storing the JWT token, and modifying the backend to support CLI redirects.",
    "changes": [
      {
        "filePath": "/media/eddie/Data/projects/nestJS/nest-modules/full-stack/src/auth/auth.controller.ts",
        "action": "modify",
        "newContent": "import {\n  Controller,\n  Post,\n  Body,\n  Res,\n  UseGuards,\n  Get,\n  Req,\n  BadRequestException,\n  Query,\n  NotFoundException,\n  Redirect,\n} from '@nestjs/common';\nimport {\n  ApiTags,\n  ApiOperation,\n  ApiResponse,\n  ApiBearerAuth,\n  ApiQuery,\n  ApiBody,\n} from '@nestjs/swagger';\nimport { JwtService } from '@nestjs/jwt';\nimport { PrismaService } from '../prisma/prisma.service';\nimport { MailService } from '../mail/mail.service';\nimport { AuthService } from './auth.service';\nimport { RegisterDto, LoginDto, CreateJwtUserDto } from './dto/auth.dto';\nimport { VerifyEmailDto } from './dto/verify-email.dto';\nimport { AuthRequest } from './interfaces/auth-request.interface';\nimport { GoogleAuthGuard } from './guards/google.guard';\nimport { GitHubAuthGuard } from './guards/github.guard';\nimport { JwtAuthGuard } from './auth.guard';\nimport { Response, Request } from 'express';\nimport { GitHubProfileDto, GitHubTokenDto } from './dto/github-profile.dto';\nimport { GoogleProfileDto } from './dto/google-profile.dto';\nimport { GoogleTokenDto } from './dto/google-token.dto';\nimport { UserRole } from './enums/user-role.enum';\nimport { Role, User } from '@prisma/client';\n\n\n/**\n * AuthController handles authentication-related endpoints, including user registration,\n * login, logout, email verification, and OAuth2 authentication with Google and GitHub.\n *\n * @ApiTags Auth\n * @Controller api/auth\n */\n@ApiTags('Auth')\n@Controller('api/auth')\nexport class AuthController {\n  constructor(\n    private readonly authService: AuthService,\n    private readonly prisma: PrismaService,\n    private readonly mailService: MailService,\n  ) {}\n\n  /**\n   * Handles the OAuth2 callback from Google or GitHub, validating the profile,\n   * generating a JWT token, and returning the access token and user information.\n   *\n   * @private\n   * @async\n   * @function handleOAuthCallback\n   * @param {('google' | 'github')} provider - The OAuth2 provider (either 'google' or 'github').\n   * @param {AuthRequest} req - The request object containing user profile and tokens.\n   * @returns {Promise<{ accessToken: string; user: any }>} - A promise that resolves to an object\n   * containing the access token and user information.  The user object type is 'any' because the\n   * specific profile type will depend on the OAuth2 provider.\n   */\n  private async handleOAuthCallback(\n    provider: 'google' | 'github',\n    req: AuthRequest,\n  ): Promise<{ accessToken: string; user: User, profile?: GoogleProfileDto | GitHubProfileDto, tokens: GoogleTokenDto | GitHubTokenDto } > {\n    const { profile, tokens } = req.user as {\n      profile: GoogleProfileDto | GitHubProfileDto;\n      tokens: GoogleTokenDto | GitHubTokenDto;\n     // provider: 'google' | 'github';\n    };\n\n    const user  = await this.authService.validateOAuthProfile(\n      provider,\n      profile,\n      tokens,\n    );\n\n    const payload: CreateJwtUserDto = {\n      id: user.id,\n      sub: user.id,\n      email: user.email,\n      role: user.role ?? Role.USER,\n      image: user.image ?? undefined,\n      name: user.name ?? '',\n      phone_number: user.phone_number ?? '',\n      provider,\n      username: user.username ?? undefined, // Include username in JWT payload\n     // tokens,\n      \n    };\n\n    const accessToken = await this.authService.generateToken(payload);\n  \n    return { accessToken, user, profile, tokens };\n  }\n\n  /**\n   * Logs in a user and sets a JWT cookie.\n   *\n   * @Post login\n   * @ApiOperation summary Log in a user and set JWT cookie\n   * @ApiResponse status 200 - User logged in successfully\n   * @ApiResponse status 401 - Invalid credentials\n   * @async\n   * @function login\n   * @param {LoginDto} dto - The login credentials data transfer object.\n   * @param {Response} res - The Express response object for setting cookies.\n   * @returns {Promise<any>} - A promise that resolves to the user information.  The user object type is 'any' because the\n   * specific shape may depend on the authentication strategy.\n   */\n  @Post('login')\n  @ApiOperation({ summary: 'Log in a user and set JWT cookie' })\n  @ApiResponse({ status: 200, description: 'User logged in successfully' })\n  @ApiResponse({ status: 401, description: 'Invalid credentials' })\n  async login(\n    @Body() dto: LoginDto,\n    @Res({ passthrough: true }) res: Response,\n  ) {\n    const user = await this.authService.login(dto);\n    res.cookie('accessToken', user.accessToken, {\n      httpOnly: true,\n      secure: process.env.NODE_ENV === 'production',\n      sameSite: 'lax',\n    });\n    return user;\n  }\n\n  /**\n   * Logs out a user by clearing the JWT cookie.\n   *\n   * @Post logout\n   * @ApiOperation summary Log out user (clear cookie)\n   * @ApiResponse status 200 - Logged out successfully\n   * @async\n   * @function logout\n   * @param {Response} res - The Express response object for clearing cookies.\n   * @returns {Promise<{ message: string }>} - A promise that resolves to a success message.\n   */\n  @Post('logout')\n  @ApiOperation({ summary: 'Log out user (clear cookie)' })\n  @ApiResponse({ status: 200, description: 'Logged out successfully' })\n  async logout(@Res({ passthrough: true }) res: Response) {\n    res.clearCookie('accessToken');\n    return { message: 'Logged out successfully' };\n  }\n\n  /**\n   * Initiates the GitHub OAuth2 login flow.\n   *\n   * @Get github\n   * @UseGuards GitHubAuthGuard\n   * @ApiOperation summary Initiate GitHub OAuth2 login\n   * @ApiResponse status 302 - Redirects to GitHub login\n   * @async\n   * @function githubAuth\n   */\n  @Get('github')\n  @UseGuards(GitHubAuthGuard)\n  @ApiOperation({ summary: 'Initiate GitHub OAuth2 login' })\n  @ApiResponse({ status: 302, description: 'Redirects to GitHub login' })\n  async githubAuth(@Query('state') state?: string, @Query('cli_port') cliPort?: number) {\n    // The state and cli_port are handled by Passport.js and the callback\n    // Passport-github2 will automatically include `state` if configured.\n    // cli_port can be passed through to the session or directly to the callback if needed.\n  }\n\n  /**\n   * Handles the GitHub OAuth2 callback, issues a JWT token, and redirects the user.\n   *\n   * @Get github/callback\n   * @UseGuards GitHubAuthGuard\n   * @ApiOperation summary Handle GitHub OAuth2 callback and issue JWT token\n   * @ApiResponse status 200 - GitHub login successful with JWT issued\n   * @ApiResponse status 401 - Unauthorized or failed login attempt\n   * @async\n   * @function githubAuthRedirect\n   * @param {AuthRequest} req - The request object containing user information from GitHub.\n   * @param {Response} res - The Express response object for setting cookies and redirecting.\n   * @returns {Promise<any>} - A promise that resolves after redirecting the user.\n   */\n  @Get('github/callback')\n  @UseGuards(GitHubAuthGuard)\n  @ApiOperation({\n    summary: 'Handle GitHub OAuth2 callback and issue JWT token',\n  })\n  @ApiResponse({\n    status: 200,\n    description: 'GitHub login successful with JWT issued',\n  })\n  @ApiResponse({\n    status: 401,\n    description: 'Unauthorized or failed login attempt',\n  })\n  async githubAuthRedirect(\n    @Req() req: AuthRequest,\n    @Res() res: Response,\n    @Query('state') state?: string,\n    @Query('cli_port') cliPort?: number,\n  ) {\n    try {\n      // Basic state validation for CLI callback\n      if (cliPort && (!state || state !== req.query.state)) {\n        // If cli_port is present, it's likely a CLI request, validate state\n        // Note: Passport.js handles its own state verification by default. This is an additional layer\n        // if the client passes an explicit 'state' that needs to be matched.\n        console.warn('State mismatch in GitHub CLI callback. Potential CSRF attempt.');\n        return res.redirect('/login?error=State%20Mismatch');\n      }\n\n      const { accessToken, user } = await this.handleOAuthCallback(\n        'github',\n        req,\n      );\n\n      res.cookie('accessToken', accessToken, {\n        httpOnly: true,\n        secure: process.env.NODE_ENV === 'production',\n        sameSite: 'lax',\n      });\n\n      if (cliPort) {\n        // Redirect to CLI's local server callback\n        const cliCallbackUrl = `http://localhost:${cliPort}/auth/callback?accessToken=${accessToken}&userId=${user.id}&userEmail=${user.email}&userName=${encodeURIComponent(user.name || '')}&userImage=${encodeURIComponent(user.image || '')}&userRole=${user.role}&username=${encodeURIComponent(user.username || '')}&provider=github`;\n        return res.redirect(cliCallbackUrl);\n      } else {\n        // Original frontend redirect\n        return res.redirect(\n          `${process.env.FRONTEND_URL}/login?action=success&accessToken=${accessToken}&userId=${user.id}&userEmail=${user.email}&userName=${encodeURIComponent(user.name || '')}&userImage=${encodeURIComponent(user.image || '')}&userRole=${user.role}&username=${encodeURIComponent(user.username || '')}&provider=github`,\n        );\n      }\n    } catch (error) {\n      console.error('OAuth redirect error:', error);\n      return res.redirect('/login?error=OAuth%20Login%20Failed');\n    }\n  }\n\n  /**\n   * Initiates the Google OAuth2 login flow.\n   *\n   * @Get google\n   * @UseGuards GoogleAuthGuard\n   * @ApiOperation summary Initiate Google OAuth2 login\n   * @ApiResponse status 302 - Redirects to Google login\n   * @async\n   * @function googleAuth\n   */\n  @Get('google')\n  @UseGuards(GoogleAuthGuard)\n  @ApiOperation({ summary: 'Initiate Google OAuth2 login' })\n  @ApiResponse({ status: 302, description: 'Redirects to Google login' })\n  async googleAuth(@Query('state') state?: string, @Query('cli_port') cliPort?: number) {\n    // The state and cli_port are handled by Passport.js and the callback\n    // Passport-google-oauth20 will automatically include `state` if configured.\n    // cli_port can be passed through to the session or directly to the callback if needed.\n  }\n\n  /**\n   * Handles the Google OAuth2 callback, issues a JWT token, and redirects the user.\n   *\n   * @Get google/callback\n   * @UseGuards GoogleAuthGuard\n   * @ApiOperation summary Handle Google OAuth2 callback and issue JWT token\n   * @ApiResponse status 200 - Google login successful with JWT issued\n   * @ApiResponse status 401 - Unauthorized or failed login attempt\n   * @async\n   * @function googleAuthRedirect\n   * @param {AuthRequest} req - The request object containing user information from Google.\n   * @param {Response} res - The Express response object for setting cookies and redirecting.\n   * @returns {Promise<any>} - A promise that resolves after redirecting the user.\n   */\n  @Get('google/callback')\n  @UseGuards(GoogleAuthGuard)\n  @ApiOperation({\n    summary: 'Handle Google OAuth2 callback and issue JWT token',\n  })\n  @ApiResponse({\n    status: 200,\n    description: 'Google login successful with JWT issued',\n  })\n  @ApiResponse({\n    status: 401,\n    description: 'Unauthorized or failed login attempt',\n  })\n  async googleAuthRedirect(\n    @Req() req: AuthRequest,\n    @Res() res: Response,\n    @Query('state') state?: string,\n    @Query('cli_port') cliPort?: number,\n  ) {\n    try {\n       // Basic state validation for CLI callback\n       if (cliPort && (!state || state !== req.query.state)) {\n        // If cli_port is present, it's likely a CLI request, validate state\n        console.warn('State mismatch in Google CLI callback. Potential CSRF attempt.');\n        return res.redirect('/login?error=State%20Mismatch');\n      }\n\n      const { accessToken, user } = await this.handleOAuthCallback(\n        'google',\n        req,\n      );\n\n      res.cookie('accessToken', accessToken, {\n        httpOnly: true,\n        secure: process.env.NODE_ENV === 'production',\n        sameSite: 'lax',\n      });\n\n      if (cliPort) {\n        // Redirect to CLI's local server callback\n        const cliCallbackUrl = `http://localhost:${cliPort}/auth/callback?accessToken=${accessToken}&userId=${user.id}&userEmail=${user.email}&userName=${encodeURIComponent(user.name || '')}&userImage=${encodeURIComponent(user.image || '')}&userRole=${user.role}&username=${encodeURIComponent(user.username || '')}&provider=google`;\n        return res.redirect(cliCallbackUrl);\n      } else {\n        // Original frontend redirect\n        return res.redirect(\n          `${process.env.FRONTEND_URL}/login?action=success&accessToken=${accessToken}&userId=${user.id}&userEmail=${user.email}&userName=${encodeURIComponent(user.name || '')}&userImage=${encodeURIComponent(user.image || '')}&userRole=${user.role}&username=${encodeURIComponent(user.username || '')}&provider=google`,\n        );\n      }\n    } catch (error) {\n      console.error('OAuth redirect error:', error);\n      return res.redirect('/login?error=OAuth%20Login%20Failed');\n    }\n  }\n\n  /**\n   * Registers a new user.\n   *\n   * @Post register\n   * @ApiOperation summary Register a new user\n   * @ApiResponse status 201 - User registered successfully\n   * @ApiResponse status 400 - Validation failed or user already exists\n   * @async\n   * @function register\n   * @param {RegisterDto} dto - The registration data transfer object.\n   * @returns {Promise<void>} - A promise that resolves when registration is complete.\n   */\n  @Post('register')\n  @ApiOperation({ summary: 'Register a new user' })\n  @ApiResponse({ status: 201, description: 'User registered successfully' })\n  @ApiResponse({\n    status: 400,\n    description: 'Validation failed or user already exists',\n  })\n  async register(@Body() dto: RegisterDto): Promise<void> {\n    await this.authService.register(dto);\n  }\n\n  /**\n   * Resends the email verification link to the user.\n   *\n   * @Post resend-verification\n   * @ApiOperation summary Resend email verification link\n   * @ApiBody schema containing the user's email address.\n   * @async\n   * @function resendVerification\n   * @param {string} email - The email address of the user.\n   * @returns {Promise<any>} - A promise that resolves with the result of resending verification.  The result type is 'any'\n   * because the structure of the response from the mail service can vary.\n   */\n  @Post('resend-verification')\n  @ApiOperation({ summary: 'Resend email verification link' })\n  @ApiBody({\n    schema: {\n      properties: { email: { type: 'string', example: 'user@example.com' } },\n    },\n  })\n  async resendVerification(@Body('email') email: string) {\n    return this.authService.resendVerification(email);\n  }\n\n  /**\n   * Verifies the user's email address using the provided token.\n   *\n   * @Get verify-email\n   * @ApiOperation summary Verify user email address\n   * @ApiResponse status 200 - Email verified successfully\n   * @ApiResponse status 400 - Invalid or expired token\n   * @async\n   * @function verifyEmail\n   * @param {VerifyEmailDto} query - The query parameters containing the verification token.\n   * @returns {Promise<any>} - A promise that resolves with the result of email verification.  The result type is 'any' because\n   * the response format can depend on the implementation of the verification service.\n   */\n  @Get('verify-email')\n  @ApiOperation({ summary: 'Verify user email address' })\n  @ApiResponse({ status: 200, description: 'Email verified successfully' })\n  @ApiResponse({ status: 400, description: 'Invalid or expired token' })\n  async verifyEmail(@Query() query: VerifyEmailDto) {\n    return this.authService.verifyEmail(query.token);\n  }\n\n  /**\n   * Gets the profile of the currently authenticated user.\n   *\n   * @Get me\n   * @UseGuards JwtAuthGuard\n   * @ApiBearerAuth\n   * @ApiOperation summary Get current authenticated user\n   * @ApiResponse status 200 - User profile returned\n   * @ApiResponse status 401 - Unauthorized\n   * @async\n   * @function getProfile\n   * @param {Request} req - The request object containing the user information.\n   * @returns {Promise<any>} - A promise that resolves with the user profile.  The user profile type is 'any' because the shape\n   * can vary based on the data stored about the user.\n   */\n  @UseGuards(JwtAuthGuard)\n  @Get('me')\n  @ApiBearerAuth()\n  @ApiOperation({ summary: 'Get current authenticated user' })\n  @ApiResponse({ status: 200, description: 'User profile returned' })\n  @ApiResponse({ status: 401, description: 'Unauthorized' })\n  async getProfile(@Req() req: Request) {\n    const meR = req['user'];\n    if(meR.email){\n       const getAccount = this.prisma.user.findUnique({\n      where: { email: meR?.email },\n      include: {\n        Account: true,\n      },\n    });\n    if(getAccount){\n     \n    return getAccount;\n    } else {\n      return meR;\n    }\n    \n    }\n   \n  }\n}\n",
        "reason": "Modified OAuth callback methods (googleAuthRedirect, githubAuthRedirect) to conditionally redirect to a CLI local server if `cli_port` query parameter is present. This enables the CLI to complete the OAuth flow. Also added `state` and `cli_port` parameters to `googleAuth` and `githubAuth` to reflect their potential use for CLI integration."
      },
      {
        "filePath": "/media/eddie/Data/projects/nestJS/nest-modules/full-stack/ai-assistant/ai-editor/src/auth/authManager.ts",
        "action": "add",
        "newContent": "import * as http from 'http';\nimport * as open from 'open';\nimport * as path from 'path';\nimport * as os from 'os';\nimport { promises as fs } from 'fs';\nimport * as crypto from 'crypto';\nimport inquirer from 'inquirer';\nimport { CLI_OAUTH_CALLBACK_PATH, AI_EDITOR_CONFIG_DIR_NAME, AUTH_CONFIG_FILE_NAME } from '../constants';\nimport { AuthData } from '../types';\n\nconst BACKEND_BASE_URL = process.env.BACKEND_BASE_URL || 'http://localhost:3000';\nconst CLI_PORT_RANGE_START = 49152; // Ephemeral port range start\nconst CLI_PORT_RANGE_END = 65535;   // Ephemeral port range end\n\n/**\n * Resolves the path to the AI Editor configuration directory in the user's home directory.\n * @returns The absolute path to the configuration directory.\n */\nfunction getAuthConfigDirPath(): string {\n  return path.join(os.homedir(), AI_EDITOR_CONFIG_DIR_NAME);\n}\n\n/**\n * Resolves the path to the authentication configuration file.\n * @returns The absolute path to the authentication config file.\n */\nfunction getAuthConfigFilePath(): string {\n  return path.join(getAuthConfigDirPath(), AUTH_CONFIG_FILE_NAME);\n}\n\n/**\n * Stores authentication data (access token, user info) to a local file.\n * @param authData The authentication data to store.\n */\nexport async function storeAuthData(authData: AuthData): Promise<void> {\n  try {\n    const configDir = getAuthConfigDirPath();\n    await fs.mkdir(configDir, { recursive: true });\n    const configPath = getAuthConfigFilePath();\n    await fs.writeFile(configPath, JSON.stringify(authData, null, 2), 'utf-8');\n    console.log(`\n✅ Login successful! Token stored at ${configPath}`);\n  } catch (error) {\n    console.error(`Error storing authentication data: ${(error as Error).message}`);\n  }\n}\n\n/**\n * Retrieves stored authentication data from the local file.\n * @returns A Promise that resolves to the AuthData if found, otherwise null.\n */\nexport async function getAuthData(): Promise<AuthData | null> {\n  try {\n    const configPath = getAuthConfigFilePath();\n    const content = await fs.readFile(configPath, 'utf-8');\n    return JSON.parse(content) as AuthData;\n  } catch (error: any) {\n    if (error.code === 'ENOENT') {\n      // File not found, meaning not logged in\n      return null;\n    }\n    console.error(`Error reading authentication data: ${(error as Error).message}`);\n    return null;\n  }\n}\n\n/**\n * Clears stored authentication data.\n */\nexport async function clearAuthData(): Promise<void> {\n  try {\n    const configPath = getAuthConfigFilePath();\n    await fs.unlink(configPath);\n    console.log(`\n✅ Logged out successfully. Local token cleared.`);\n  } catch (error: any) {\n    if (error.code === 'ENOENT') {\n      console.log('Not logged in, no token to clear.');\n      return; // Already logged out\n    }\n    console.error(`Error clearing authentication data: ${(error as Error).message}`);\n  }\n}\n\n/**\n * Checks the current authentication status and displays user info if logged in.\n * @returns A Promise resolving to true if logged in, false otherwise.\n */\nexport async function getAuthStatus(): Promise<boolean> {\n  const authData = await getAuthData();\n  if (authData && authData.accessToken) {\n    console.log(`\n✨ You are currently logged in as:`);\n    console.log(`  Email: ${authData.userEmail}`);\n    if (authData.userName) console.log(`  Name: ${authData.userName}`);\n    if (authData.provider) console.log(`  Provider: ${authData.provider}`);\n    console.log(`  User ID: ${authData.userId}`);\n    console.log(`  Role: ${authData.userRole}`);\n    console.log(`  (Token valid until: Needs validation against backend)`); // JWT expiration should be validated on backend calls\n    return true;\n  } else {\n    console.log('\\n🚫 Not currently logged in. Use `ai-editor login` to authenticate.');\n    return false;\n  }\n}\n\n/**\n * Initiates the OAuth login flow for the CLI.\n * @param provider The OAuth provider ('google' or 'github').\n */\nexport async function loginWithOAuth(provider: 'google' | 'github'): Promise<void> {\n  console.log(`\nInitiating ${provider} login...`);\n  console.log('A browser window will open for authentication.');\n  console.log('Please ensure you complete the login process in the browser.');\n\n  let server: http.Server | null = null;\n  let port: number | null = null;\n  let resolvePromise: ((value: AuthData) => void) | null = null;\n  let rejectPromise: ((reason?: any) => void) | null = null;\n  const authPromise = new Promise<AuthData>((resolve, reject) => {\n    resolvePromise = resolve;\n    rejectPromise = reject;\n  });\n\n  // Generate a random port within the ephemeral range\n  const tempPort = Math.floor(Math.random() * (CLI_PORT_RANGE_END - CLI_PORT_RANGE_START + 1)) + CLI_PORT_RANGE_START;\n\n  // Generate a cryptographically strong random state parameter\n  const state = crypto.randomBytes(16).toString('hex');\n\n  server = http.createServer(async (req, res) => {\n    try {\n      const url = new URL(req.url || '/', `http://localhost:${tempPort}`);\n      if (url.pathname === CLI_OAUTH_CALLBACK_PATH) {\n        const receivedState = url.searchParams.get('state');\n        const accessToken = url.searchParams.get('accessToken');\n        const userId = url.searchParams.get('userId');\n        const userEmail = url.searchParams.get('userEmail');\n        const userName = url.searchParams.get('userName');\n        const userImage = url.searchParams.get('userImage');\n        const userRole = url.searchParams.get('userRole');\n        const username = url.searchParams.get('username');\n        const authProvider = url.searchParams.get('provider');\n        const error = url.searchParams.get('error');\n\n        if (error) {\n          res.writeHead(400, { 'Content-Type': 'text/html' });\n          res.end('<h1>Login Failed</h1><p>Error: ' + decodeURIComponent(error) + '</p><p>You can close this window.</p>');\n          rejectPromise?.(new Error(`OAuth login failed: ${decodeURIComponent(error)}`));\n          return;\n        }\n\n        if (receivedState !== state) {\n          res.writeHead(403, { 'Content-Type': 'text/html' });\n          res.end('<h1>Login Failed</h1><p>State mismatch. Potential CSRF attack. You can close this window.</p>');\n          rejectPromise?.(new Error('OAuth login failed: State mismatch.'));\n          return;\n        }\n\n        if (accessToken && userId && userEmail) {\n          const authData: AuthData = {\n            accessToken,\n            userId,\n            userEmail,\n            userName: userName ? decodeURIComponent(userName) : undefined,\n            userImage: userImage ? decodeURIComponent(userImage) : undefined,\n            userRole: userRole || 'USER', // Default to 'USER' if not provided\n            username: username ? decodeURIComponent(username) : undefined,\n            provider: authProvider || undefined\n          };\n          await storeAuthData(authData);\n          res.writeHead(200, { 'Content-Type': 'text/html' });\n          res.end('<h1>Login Successful!</h1><p>You can close this window and return to the terminal.</p>');\n          resolvePromise?.(authData);\n        } else {\n          res.writeHead(400, { 'Content-Type': 'text/html' });\n          res.end('<h1>Login Failed</h1><p>Missing access token or user info. You can close this window.</p>');\n          rejectPromise?.(new Error('OAuth login failed: Missing token or user info.'));\n        }\n      } else {\n        res.writeHead(404, { 'Content-Type': 'text/html' });\n        res.end('<h1>Not Found</h1><p>This path is not a valid OAuth callback. You can close this window.</p>');\n      }\n    } catch (error) {\n      console.error('Error in local server callback:', error);\n      res.writeHead(500, { 'Content-Type': 'text/html' });\n      res.end('<h1>Internal Server Error</h1><p>An error occurred during callback processing.</p>');\n      rejectPromise?.(error);\n    } finally {\n      if (server) {\n        server.close(() => {\n          // console.log(`Local server on port ${port} closed.`);\n        });\n        server = null;\n      }\n    }\n  });\n\n  server.listen(tempPort, async () => {\n    port = tempPort;\n    const authUrl = `${BACKEND_BASE_URL}/api/auth/${provider}?cli_port=${port}&state=${state}`;\n    console.log(`\nOpening browser to: ${authUrl}`);\n    console.log(`Listening for callback on http://localhost:${port}${CLI_OAUTH_CALLBACK_PATH}`);\n    try {\n      await open(authUrl);\n    } catch (openErr) {\n      console.error(`Failed to open browser: ${(openErr as Error).message}`);\n      console.log(`Please open the URL manually: ${authUrl}`);\n    }\n  });\n\n  // Set a timeout for the authentication process\n  const timeout = setTimeout(() => {\n    if (server) {\n      server.close();\n      console.error('\\nLogin timed out. Please try again.');\n      rejectPromise?.(new Error('Login timed out.'));\n    }\n  }, 5 * 60 * 1000); // 5 minutes timeout\n\n  try {\n    const authData = await authPromise;\n    clearTimeout(timeout);\n    return authData;\n  } catch (err) {\n    clearTimeout(timeout);\n    throw err;\n  } finally {\n    if (server) {\n      server.close(); // Ensure server is closed even if promise rejects\n    }\n  }\n}\n\nexport async function chooseAndLogin(): Promise<void> {\n  const { provider } = await inquirer.prompt([\n    {\n      type: 'list',\n      name: 'provider',\n      message: 'Choose your OAuth provider:',\n      choices: [\n        { name: 'Google', value: 'google' },\n        { name: 'GitHub', value: 'github' },\n      ],\n    },\n  ]);\n\n  try {\n    await loginWithOAuth(provider);\n  } catch (error) {\n    console.error(`\nLogin process failed: ${(error as Error).message}`);\n  }\n}\n",
        "reason": "Added a new module `authManager.ts` to handle the CLI-specific OAuth login flow. This includes starting a temporary local HTTP server to listen for OAuth callbacks, opening the browser, securely storing the received JWT token and user data in a local config file, and providing functions to check status and log out."
      },
      {
        "filePath": "/media/eddie/Data/projects/nestJS/nest-modules/full-stack/ai-assistant/ai-editor/src/constants.ts",
        "action": "modify",
        "newContent": " export const INSTRUCTION = `\n            You are an expert TypeScript/React/Tailwind developer.\n            Focus on creating clean, idiomatic code. Ensure all generated code is fully type-safe.\n            When modifying existing files, preserve existing formatting and code style as much as possible.\n            If adding new components or modules, place them in logical, idiomatic locations within the project structure.\n            Consider common best practices for React (hooks, functional components, state management with nanostores if applicable) and Tailwind CSS v4 (utility-first, responsive design).\n            If a new file is created, ensure it follows the correct naming conventions and is properly imported/exported where necessary.\n            Always consider the full context of the project when making changes.\n            For 'modify' actions, provide only the *entire new content* of the file, not just a diff.\n            For 'add' actions, provide the *entire content* of the new file.\n            For 'delete' actions, no newContent is required.\n            If you need to add a new dependency, mention it in the summary or thought process, but do NOT include 'npm install' or 'yarn add' commands in the file changes.\n          `.replace(/^\\s+/gm, \"\");\nexport const ADDIONAL_INSTRUCTION_EXPECTED_OUTPUT = `\n            Your response must be a JSON object with two top-level keys: 'summary' (string) and 'changes' (array of objects).\n            The 'changes' array should contain objects, each representing a file operation:\n            {\n              \"filePath\": \"path/to/file.tsx\", // Absolute path (use path.join(projectRoot, relativePath) to construct)\n              \"action\": \"add\" | \"modify\" | \"delete\",\n              \"newContent\"?: \"...\", // Required for 'add'/'modify', omit for 'delete'\n              \"reason\"?: \"...\" // Optional, short explanation for this specific file change\n            }\n            Example:\n            {\n              \"summary\": \"Implemented user authentication and updated Navbar component.\",\n              \"thoughtProcess\": \"Created new components for login and signup, updated navigation to include auth links, and added a basic auth context.\",\n              \"changes\": [\n                {\n                  \"filePath\": \"/path/to/project/src/auth/Login.tsx\",\n                  \"action\": \"add\",\n                  \"newContent\": \"import React from 'react';\\\\nimport { useStore } from '@nanostores/react';\\\\nimport { authStore } from './authStore';\\\\n\\\\nfunction Login() {\\\\n  const $auth = useStore(authStore);\\\\n  // ... login form logic\\\\n  return <div className='p-4'>Login Form</div>;\\\\n}\\\\nexport default Login;\",\n                  \"reason\": \"New login component for user authentication.\"\n                },\n                {\n                  \"filePath\": \"/path/to/project/src/components/Navbar.tsx\",\n                  \"action\": \"modify\",\n                  \"newContent\": \"import React from 'react';\\\\nimport { Link } from 'react-router-dom';\\\\nimport { useStore } from '@nanostores/react';\\\\nimport { authStore } from '../auth/authStore';\\\\n\\\\nfunction Navbar() {\\\\n  const $auth = useStore(authStore);\\\\n  return (\\\\n    <nav className='bg-blue-500 p-4 text-white flex justify-between'>\\\\n      <Link to='/' className='font-bold text-lg'>My App</Link>\\\\n      <div>\\\\n        {$auth.isLoggedIn ? (\\\\n          <button onClick={() => authStore.setKey('isLoggedIn', false)} className='ml-4'>Logout</button>\\\\n        ) : (\\\\n          <>\\\\n            <Link to='/login' className='ml-4'>Login</Link>\\\\n            <Link to='/signup' className='ml-4'>Signup</Link>\\\\n          </>\\\\n        )}\\\\n      </div>\\\\n    </nav>\\\\n  );\\\\n}\\\\nexport default Navbar;\",\n                  \"reason\": \"Added login/logout links to Navbar based on authentication status.\"\n                },\n                {\n                  \"filePath\": \"/path/to/project/src/old/DeprecatedComponent.ts\",\n                  \"action\": \"delete\",\n                  \"reason\": \"Removed unused component as part of refactor.\"\n                }\n              ]\n            }\n          `.replace(/^\\s+/gm, \"\");\n\n// CLI Auth Constants\nexport const CLI_OAUTH_CALLBACK_PATH = '/auth/callback';\nexport const AI_EDITOR_CONFIG_DIR_NAME = '.ai-editor';\nexport const AUTH_CONFIG_FILE_NAME = 'auth.json';\n",
        "reason": "Added new constants for the CLI's OAuth callback path and configuration file paths to centralize configuration."
      },
      {
        "filePath": "/media/eddie/Data/projects/nestJS/nest-modules/full-stack/ai-assistant/ai-editor/src/index.ts",
        "action": "modify",
        "newContent": "import dotenv from 'dotenv';\ndotenv.config();\nimport { Command } from 'commander';\nimport inquirer from 'inquirer';\nimport { scanProject } from './scanner';\nimport { INSTRUCTION, ADDIONAL_INSTRUCTION_EXPECTED_OUTPUT } from './constants';\nimport { prepareContextForLLM, buildLLMPrompt } from './llm/contextPreparer';\nimport { callLLM } from './llm/llmOrchestrator';\nimport { generateUnifiedDiff } from './file-operations/diffGenerator';\nimport { applyFileChange } from './file-operations/fileApplier';\nimport {\n  isGitRepository,\n  createBranch,\n  stageFiles,\n  getCurrentBranch,\n} from './git-operations/gitManager';\nimport { ScannedFile, LLMInput, LLMOutput, ProposedFileChange } from './types';\nimport simpleGit, { SimpleGit } from 'simple-git';\nimport * as path from 'path';\nimport { chooseAndLogin, clearAuthData, getAuthStatus } from './auth/authManager'; // Import auth functions\n\nconst program = new Command();\n\nprogram\n  .name('ai-editor')\n  .description('An AI-powered tool for editing and updating code files.')\n  .version('0.1.0');\n\nprogram\n  .command('scan [paths...]') // Changed to accept multiple paths (files or directories)\n  .description('Scans one or more files or directories for relevant code files and reads their content.')\n  .option('-v, --verbose', 'Output detailed information during scan.')\n  .option('-s, --show-content', 'Show a snippet of file content for sample files.')\n  .action(async (paths: string[], options: { verbose?: boolean; showContent?: boolean }) => {\n    // If no paths are provided, default to current working directory\n    const targetPaths = paths.length > 0 ? paths : ['.'];\n    const projectRoot = process.cwd(); // For 'scan' command, assume CWD is the project root\n\n    console.log(`Scanning paths: ${targetPaths.map(p => path.resolve(projectRoot, p)).join(', ')}`);\n    if (options.verbose) {\n      console.log('Verbose mode enabled.');\n    }\n\n    try {\n      // Pass the array of targetPaths and the projectRoot to scanProject\n      const scannedFiles: ScannedFile[] = await scanProject(targetPaths, projectRoot, options.verbose);\n      console.log('\\n--- Scan Complete ---');\n      console.log(`Found ${scannedFiles.length} files.`);\n\n      if (scannedFiles.length > 0) {\n        console.log('Sample files found:');\n        scannedFiles.slice(0, 5).forEach((file) => {\n          // Display path relative to CWD for user clarity\n          const displayPath = path.relative(process.cwd(), file.filePath);\n          console.log(`  - ${displayPath}`);\n          if (options.showContent) {\n            const contentSnippet =\n              file.content.substring(0, 200) + (file.content.length > 200 ? '...' : '');\n            console.log(\n              `    Content snippet:\\n${contentSnippet\n                .split('\\n')\n                .map((line) => `      ${line}`)\n                .join('\\n')}\\n`,\n            );\n          }\n        });\n        if (scannedFiles.length > 5) {\n          console.log(`  ... and ${scannedFiles.length - 5} more.`);\n        }\n      }\n    } catch (error) {\n      console.error(`Error during scan: ${(error as Error).message}`);\n      process.exit(1);\n    }\n  });\n\nprogram\n  .command('generate <prompt>')\n  .description('Generates or modifies code based on a natural language prompt.')\n  .option(\n    '-p, --path <path>',\n    'Specify the project root directory (default: current directory). This is where Git operations and file resolution will be based.',\n    '.',\n  )\n  .option(\n    '--scan-dirs <dirs...>',\n    'Space-separated list of directories to scan within the project root (e.g., \"src tests\").',\n  )\n  .option(\n    '--scan-files <files...>', // NEW option for individual files\n    'Space-separated list of individual file paths to scan within the project root (e.g., \"src/App.tsx tests/my-test.ts\").',\n  )\n  .option(\n    '-y, --yes',\n    'Automatically confirm all proposed changes without prompting (USE WITH CAUTION!).',\n    false,\n  )\n  .option('--no-git', 'Skip all Git operations (branching, staging).', false)\n  .option(\n    '--branch <name>',\n    'Specify a branch name to create/checkout. If not provided, a default is suggested.',\n  )\n  .action(\n    async (\n      prompt: string,\n      options: {\n        path: string; // This is the project root\n        scanDirs?: string[]; // Commander.js will pass as array or undefined\n        scanFiles?: string[]; // NEW: Commander.js will pass as array or undefined\n        yes: boolean;\n        noGit: boolean;\n        branch?: string;\n      },\n    ) => {\n      const projectRoot = path.resolve(process.cwd(), options.path);\n      \n      let allScanPaths: string[] = [];\n\n      if (options.scanDirs && options.scanDirs.length > 0) {\n          allScanPaths = allScanPaths.concat(options.scanDirs);\n      }\n      if (options.scanFiles && options.scanFiles.length > 0) {\n          allScanPaths = allScanPaths.concat(options.scanFiles);\n      }\n\n      // If neither --scan-dirs nor --scan-files are provided, default to scanning the entire project root.\n      if (allScanPaths.length === 0) {\n          allScanPaths = ['.'];\n      }\n\n      const autoConfirm = options.yes;\n      const skipGit = options.noGit;\n      const customBranchName = options.branch;\n\n      console.log(`AI Code Generation Request: \"${prompt}\"`);\n      console.log(`Project root: ${projectRoot}`);\n      console.log(`Scanning paths (relative to project root): ${allScanPaths.join(', ')}`);\n\n      try {\n        let isGitRepo = false;\n        let originalBranch: string | null = null;\n        if (!skipGit) {\n          // Git operations should always be relative to the project root\n          isGitRepo = await isGitRepository(projectRoot);\n          if (isGitRepo) {\n            originalBranch = await getCurrentBranch(projectRoot);\n            console.log(\n              `\\n--- Git: Detected Git repository. Current branch: ${originalBranch} ---`,\n            );\n            if (!autoConfirm) {\n              const defaultBranchSuggestion =\n                `ai-feature/${prompt.toLowerCase().replace(/[^a-z0-9]+/g, '-')}`.substring(0, 50);\n              const { proceedGit } = await inquirer.prompt([\n                {\n                  type: 'confirm',\n                  name: 'proceedGit',\n                  message: `Proceed with Git operations (create new branch, stage changes)? Recommended.`,\n                  default: true,\n                },\n              ]);\n              if (!proceedGit) {\n                options.noGit = true;\n              } else {\n                if (!customBranchName) {\n                  const { branchNameInput } = await inquirer.prompt([\n                    {\n                      type: 'input',\n                      name: 'branchNameInput',\n                      message: `Enter new branch name (default: ${defaultBranchSuggestion}):`,\n                      default: defaultBranchSuggestion,\n                    },\n                  ]);\n                  options.branch = branchNameInput;\n                }\n                await createBranch(projectRoot, options.branch!);\n              }\n            } else {\n              if (!options.noGit && !customBranchName) {\n                options.branch =\n                  `ai-feature/${prompt.toLowerCase().replace(/[^a-z0-9]+/g, '-')}`.substring(0, 50);\n                console.log(`Auto-creating branch: ${options.branch}`);\n              }\n              if (!options.noGit && options.branch) {\n                await createBranch(projectRoot, options.branch);\n              }\n            }\n          } else {\n            console.log(`\\n--- Git: Not a Git repository. Skipping Git operations. ---`);\n            options.noGit = true;\n          }\n        } else {\n          console.log(`\\n--- Git: Skipping Git operations as requested. ---`);\n        }\n\n        console.log('\\n--- Step 1: Scanning project files ---');\n        // Pass the array of allScanPaths, and the projectRoot for context.\n        const scannedFiles: ScannedFile[] = await scanProject(allScanPaths, projectRoot);\n        console.log(`Found ${scannedFiles.length} files.`);\n\n        const originalFileContents = new Map<string, string>();\n        scannedFiles.forEach((file) => originalFileContents.set(file.filePath, file.content));\n\n        console.log('\\n--- Step 2: Preparing LLM context ---');\n        // Generate a simple project structure string from the scanned files\n        const projectStructure = generateProjectStructureString(scannedFiles);\n\n        const llmInput: LLMInput = {\n          userPrompt: prompt,\n          projectRoot: projectRoot,\n          projectStructure: projectStructure,\n          relevantFiles: scannedFiles,\n          additionalInstructions: `${INSTRUCTION}`.replace(/^\\s+/gm, ''), // Clean up leading whitespace\n          expectedOutputFormat: `${ADDIONAL_INSTRUCTION_EXPECTED_OUTPUT}`.replace(/^\\s+/gm, ''), // Clean up leading whitespace\n        };\n\n        console.log('\\n--- Step 3: Calling LLM ---');\n        const llmOutput: LLMOutput = await callLLM(llmInput, projectRoot); // Pass projectRoot for potential LLM calls that need it\n\n        console.log('\\n--- Step 4: LLM Proposed Changes ---');\n        console.log(`Summary: ${llmOutput.summary}`);\n        if (llmOutput.thoughtProcess) {\n          console.log(`Thought Process:\\n${llmOutput.thoughtProcess}`);\n        }\n\n        if (llmOutput.changes.length === 0) {\n          console.log('No changes proposed by the LLM. Exiting.');\n          return;\n        }\n\n        console.log('\\nReviewing Proposed File Changes:');\n        const changesToApply: ProposedFileChange[] = [];\n        const filesModifiedOrAdded: string[] = [];\n\n        for (const change of llmOutput.changes) {\n          // Paths displayed to user should be relative to project root (or CWD)\n          const relativePathForDisplay = path.relative(projectRoot, change.filePath);\n          console.log(\n            `\\n--- Proposed Change for: ${relativePathForDisplay} (${change.action.toUpperCase()}) ---`,\n          );\n          if (change.reason) {\n            console.log(`Reason: ${change.reason}`);\n          }\n\n          if (change.action === 'add') {\n            console.log('This will create a NEW file.');\n            console.log('New Content Preview (first 20 lines):');\n            console.log('```typescript'); // Assuming TypeScript for code preview\n            console.log(change.newContent?.split('\\n').slice(0, 20).join('\\n'));\n            if (change.newContent && change.newContent.split('\\n').length > 20) {\n              console.log('...');\n            }\n            console.log('```');\n          } else if (change.action === 'modify') {\n            const originalContent = originalFileContents.get(change.filePath) || '';\n            const diff = generateUnifiedDiff(originalContent, change.newContent || '');\n            if (diff) {\n              console.log('Changes (diff):');\n              console.log(diff);\n            } else {\n              console.log(\n                'No effective changes detected (content is identical). Skipping this modification.',\n              );\n              continue;\n            }\n          } else if (change.action === 'delete') {\n            console.log('This will DELETE the file.');\n          }\n\n          if (autoConfirm) {\n            console.log('Auto-confirming this change (--yes flag).');\n            changesToApply.push(change);\n            filesModifiedOrAdded.push(change.filePath);\n          } else {\n            const { confirm } = await inquirer.prompt([\n              {\n                type: 'list',\n                name: 'confirm',\n                message: `Apply this change to ${relativePathForDisplay}?`,\n                choices: [\n                  { name: 'Yes (apply this change)', value: 'yes' },\n                  { name: 'No (skip this change)', value: 'no' },\n                  { name: 'Apply All (apply this and all subsequent changes)', value: 'all' },\n                  { name: 'Abort (stop entirely)', value: 'abort' },\n                ],\n              },\n            ]);\n\n            if (confirm === 'yes') {\n              changesToApply.push(change);\n              filesModifiedOrAdded.push(change.filePath);\n            } else if (confirm === 'all') {\n              changesToApply.push(change);\n              filesModifiedOrAdded.push(change.filePath);\n              options.yes = true; // Set autoConfirm for subsequent loops\n            } else if (confirm === 'abort') {\n              console.log('Aborting changes. No files modified.');\n              if (isGitRepo && !options.noGit && options.branch && originalBranch) {\n                console.log(`Reverting to original branch: ${originalBranch}`);\n\n                await getGit(projectRoot).checkout(originalBranch);\n              }\n              return;\n            } else {\n              console.log(`Skipping change for ${relativePathForDisplay}.`);\n            }\n          }\n        }\n\n        if (changesToApply.length === 0) {\n          console.log('\\nNo changes were confirmed. Exiting.');\n          if (isGitRepo && !options.noGit && options.branch && originalBranch) {\n            console.log(`Reverting to original branch: ${originalBranch}`);\n            await getGit(projectRoot).checkout(originalBranch);\n          }\n          return;\n        }\n\n        console.log('\\n--- Applying Confirmed Changes ---');\n        for (const change of changesToApply) {\n          try {\n            await applyFileChange(projectRoot, change); // applyFileChange needs projectRoot or baseDir\n          } catch (fileError) {\n            console.error(\n              `Failed to apply change for ${change.filePath}: ${(fileError as Error).message}`,\n            );\n          }\n        }\n\n        console.log('\\n--- Changes Applied Successfully! ---');\n\n        if (isGitRepo && !options.noGit) {\n          console.log('\\n--- Git: Staging changes ---');\n          await stageFiles(projectRoot, filesModifiedOrAdded);\n\n          console.log('\\nNext Steps:');\n          console.log(\n            `1. Your changes have been applied and staged on branch '${options.branch || originalBranch}'.`,\n          );\n          console.log(`2. Review the changes using 'git diff --staged'.`);\n          console.log(`3. Commit your changes:`);\n          console.log(`   git commit -m \"${llmOutput.summary}\"`);\n          console.log(`4. Run your tests to ensure everything still works as expected.`);\n          console.log(\n            `5. If you want to revert to the previous branch: git checkout ${originalBranch}`,\n          );\n        } else {\n          console.log('\\nNext Steps:');\n          console.log(`1. It's highly recommended to review the changes in your editor.`);\n          if (isGitRepo) {\n            console.log(`2. You skipped Git operations. To commit, you'll need to manually:`);\n            console.log(`   git add .`);\n            console.log(`   git commit -m \"${llmOutput.summary}\"`);\n          } else {\n            console.log(\n              `2. This is not a Git repository. Consider initializing one if this is a project:`,\n            );\n            console.log(`   git init`);\n            console.log(`   git add .`);\n            console.log(`   git commit -m \"Initial commit by AI Editor\"`);\n          }\n          console.log(`3. Run your tests to ensure everything still works as expected.`);\n        }\n      } catch (error) {\n        console.error(`Error during generation: ${(error as Error).message}`);\n        process.exit(1);\n      }\n    },\n  );\n\nprogram\n  .command('login')\n  .description('Authenticate with the AI Editor service using OAuth (Google/GitHub).')\n  .action(async () => {\n    await chooseAndLogin();\n  });\n\nprogram\n  .command('logout')\n  .description('Log out from the AI Editor service and clear local token.')\n  .action(async () => {\n    await clearAuthData();\n  });\n\nprogram\n  .command('status')\n  .description('Check current authentication status.')\n  .action(async () => {\n    await getAuthStatus();\n  });\n\nprogram.parse(process.argv);\n\nfunction getGit(baseDir: string): SimpleGit {\n  return simpleGit(baseDir, { binary: 'git' });\n}\n\n/**\n * Generates a simple tree-like string representing the project structure\n * based on the relative paths of scanned files.\n * This structure is intended to provide high-level context to the LLM.\n *\n * @param scannedFiles An array of ScannedFile objects.\n * @returns A string representing the project structure.\n */\nfunction generateProjectStructureString(scannedFiles: ScannedFile[]): string {\n  const structurePaths: Set<string> = new Set();\n  const sortedRelativePaths = scannedFiles.map(f => f.relativePath).sort(); // Sort for consistent output\n\n  // Add all file paths and their parent directories to the set\n  for (const relPath of sortedRelativePaths) {\n    let currentSegment = '';\n    const parts = relPath.split(path.sep);\n    for (let i = 0; i < parts.length; i++) {\n      currentSegment = path.join(currentSegment, parts[i]);\n      if (i === parts.length - 1) { // It's a file\n        structurePaths.add(currentSegment);\n      } else { // It's a directory\n        structurePaths.add(currentSegment + path.sep); // Add trailing slash for directories\n      }\n    }\n  }\n\n  // Convert the set to a sorted array for consistent output\n  const items = Array.from(structurePaths).sort();\n\n  const structuredLines: string[] = [];\n  items.forEach(item => {\n    // Determine depth for indentation. Count path separators.\n    // For directories (ending with sep), count parts-1. For files, count parts.\n    const depth = item.split(path.sep).length - (item.endsWith(path.sep) ? 1 : 0);\n    const indent = '  '.repeat(Math.max(0, depth)); // Ensure non-negative depth\n    structuredLines.push(`${indent}- ${item}`);\n  });\n\n  return structuredLines.join('\\n');\n}\n",
        "reason": "Added `login`, `logout`, and `status` commands to the `ai-editor` CLI. These commands utilize the new `authManager` module to facilitate OAuth authentication, token management, and display of current login status."
      },
      {
        "filePath": "/media/eddie/Data/projects/nestJS/nest-modules/full-stack/ai-assistant/ai-editor/src/types.ts",
        "action": "modify",
        "newContent": "// src/types.ts\n\n/**\n * Represents a file that has been scanned from the project,\n * including its absolute path, its path relative to the project root, and its textual content.\n */\nexport interface ScannedFile {\n  filePath: string; // Absolute path to the file\n  relativePath: string; // Path relative to the project root (e.g., \"src/components/MyComponent.tsx\")\n  content: string;\n}\n\n/**\n * Represents a proposed change to a file.\n * This is the structured output we expect from the LLM.\n */\nexport interface ProposedFileChange {\n  filePath: string; // Absolute path to the file to be changed\n  action: 'add' | 'modify' | 'delete';\n  /**\n   * For 'add' or 'modify' actions, this is the new content of the file.\n   * For 'delete' actions, this field is not used.\n   */\n  newContent?: string;\n  /**\n   * An optional human-readable reason or summary for the change.\n   */\n  reason?: string;\n}\n\n/**\n * Represents the structured input that will be sent to the LLM.\n */\nexport interface LLMInput {\n  userPrompt: string;\n  projectRoot: string;\n  projectStructure: string; // A high-level overview of the project directory (e.g., tree string)\n  relevantFiles: ScannedFile[];\n  additionalInstructions: string; // Specific behavioral instructions for the LLM\n  expectedOutputFormat: string; // Instructions on the JSON format for the LLM's response\n}\n\n/**\n * Represents the structured output received from the LLM.\n */\nexport interface LLMOutput {\n  changes: ProposedFileChange[];\n  summary: string; // A concise summary of all changes made/proposed\n  thoughtProcess?: string; // LLM's detailed reasoning for the changes\n}\n\n/**\n * Represents the authentication data stored by the CLI after a successful OAuth login.\n */\nexport interface AuthData {\n  accessToken: string;\n  userId: string;\n  userEmail: string;\n  userName?: string;\n  userImage?: string;\n  userRole: string; // Corresponds to Role enum on backend, but kept as string for CLI simplicity\n  username?: string;\n  provider?: 'google' | 'github';\n}\n"
      }
    ]
  }
}
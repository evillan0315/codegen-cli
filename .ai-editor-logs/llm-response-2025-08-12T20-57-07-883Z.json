{
  "timestamp": "2025-08-12T20:57:07.884Z",
  "prompt": "\n# AI Code Generation Request\n\nYou are an expert TypeScript/React/Tailwind developer.\nFocus on creating clean, idiomatic code. Ensure all generated code is fully type-safe.\nWhen modifying existing files, preserve existing formatting and code style as much as possible.\nIf adding new components or modules, place them in logical, idiomatic locations within the project structure.\nConsider common best practices for React (hooks, functional components, state management with nanostores if applicable) and Tailwind CSS v4 (utility-first, responsive design).\nIf a new file is created, ensure it follows the correct naming conventions and is properly imported/exported where necessary.\nAlways consider the full context of the project when making changes.\nFor 'modify' actions, provide only the *entire new content* of the file, not just a diff.\nFor 'add' actions, provide the *entire content* of the new file.\nFor 'delete' actions, no newContent is required.\nIf you need to add a new dependency, mention it in the summary or thought process, but do NOT include 'npm install' or 'yarn add' commands in the file changes.\n\n\n## User Request\n```text\nBuild the server API with vite SSR\n```\n\n## Project Context\n  - .gitignore\n  - CONTRIBUTING.md\n  - LICENSE\n  - README.md\n  - apps/\n    - apps/ai-editor-front/\n      - apps/ai-editor-front/.gitignore\n      - apps/ai-editor-front/README.md\n      - apps/ai-editor-front/eslint.config.ts\n      - apps/ai-editor-front/index.html\n      - apps/ai-editor-front/package.json\n      - apps/ai-editor-front/src/\n        - apps/ai-editor-front/src/App.tsx\n        - apps/ai-editor-front/src/api/\n          - apps/ai-editor-front/src/api/auth.ts\n        - apps/ai-editor-front/src/components/\n          - apps/ai-editor-front/src/components/Button.tsx\n          - apps/ai-editor-front/src/components/Layout.tsx\n        - apps/ai-editor-front/src/constants/\n          - apps/ai-editor-front/src/constants/index.ts\n        - apps/ai-editor-front/src/context/\n          - apps/ai-editor-front/src/context/AuthContext.tsx\n        - apps/ai-editor-front/src/hooks/\n          - apps/ai-editor-front/src/hooks/useAuth.ts\n        - apps/ai-editor-front/src/index.css\n        - apps/ai-editor-front/src/main.tsx\n        - apps/ai-editor-front/src/pages/\n          - apps/ai-editor-front/src/pages/AiEditorBackup.tsx\n          - apps/ai-editor-front/src/pages/AiEditorPage.tsx\n          - apps/ai-editor-front/src/pages/AuthPage.tsx\n          - apps/ai-editor-front/src/pages/LandingPage.tsx\n        - apps/ai-editor-front/src/routes/\n          - apps/ai-editor-front/src/routes/index.tsx\n        - apps/ai-editor-front/src/stores/\n          - apps/ai-editor-front/src/stores/aiEditorStore.ts\n        - apps/ai-editor-front/src/types/\n          - apps/ai-editor-front/src/types/auth.ts\n          - apps/ai-editor-front/src/types/index.ts\n        - apps/ai-editor-front/src/utils/\n          - apps/ai-editor-front/src/utils/index.ts\n        - apps/ai-editor-front/src/vite-env.d.ts\n      - apps/ai-editor-front/tsconfig.app.json\n      - apps/ai-editor-front/tsconfig.json\n      - apps/ai-editor-front/tsconfig.node.json\n      - apps/ai-editor-front/vite.config.ts\n  - docs/\n    - docs/developer-guide.md\n    - docs/google-gemini-setup.md\n  - eslint.config.ts\n  - package.json\n  - src/\n    - src/file-operations/\n      - src/file-operations/diffGenerator.ts\n      - src/file-operations/fileApplier.ts\n    - src/git-operations/\n      - src/git-operations/gitManager.ts\n    - src/index.ts\n    - src/llm/\n      - src/llm/contextPreparer.ts\n      - src/llm/jsonRepair.ts\n      - src/llm/llmOrchestrator.ts\n    - src/scanner.ts\n    - src/types.ts\n  - tsconfig.json\n\n### Relevant Files (for analysis)\n```files\n// File: apps/ai-editor-front/.gitignore\n# Logs\nlogs\n*.log\nnpm-debug.log*\nyarn-debug.log*\nyarn-error.log*\npnpm-debug.log*\nlerna-debug.log*\n\nnode_modules\ndist\ndist-ssr\n*.local\n\n# Editor directories and files\n.vscode/*\n!.vscode/extensions.json\n.idea\n.DS_Store\n*.suo\n*.ntvs*\n*.njsproj\n*.sln\n*.sw?\n\n\n// File: apps/ai-editor-front/README.md\n# AI Editor Frontend\n\nThis project provides the frontend for an AI-powered editor, built with React, TypeScript, and Tailwind CSS. It is part of a larger monorepo that also includes a command-line interface (CLI) tool for AI code generation.\n\n## Project Structure\n\n-   `src/App.tsx`: Main application entry point, setting up routing.\n-   `src/components/`: Reusable UI components like `Layout.tsx` and `Button.tsx`.\n-   `src/pages/`: Top-level page components, including `LandingPage.tsx`, `AuthPage.tsx`, and `AiEditorPage.tsx`.\n-   `src/routes/`: Centralized routing configuration for the application.\n-   `src/api/`: API client functions for interacting with the backend (e.g., authentication).\n-   `src/context/`: React Contexts for global state management (e.g., `AuthContext.tsx`).\n-   `src/hooks/`: Custom React Hooks.\n-   `src/stores/`: Nanostores for simple, reactive state management.\n-   `src/types/`: TypeScript type definitions.\n-   `src/utils/`: Utility functions (e.g., JSON parsing helpers).\n-   `src/index.css`: Global CSS, primarily for Tailwind CSS directives and custom properties.\n-   `vite.config.ts`: Vite configuration, including path aliases and proxy settings.\n-   `package.json`: Project dependencies and scripts.\n\n## Available Scripts\n\nFrom this directory (`apps/ai-editor-front/`):\n\n-   `npm run dev`: Starts the development server.\n-   `npm run build`: Builds the project for production.\n-   `npm run lint`: Runs ESLint for code quality checks.\n-   `npm run preview`: Previews the production build.\n\n## Technologies Used\n\n-   **React**: For building the user interface.\n-   **TypeScript**: For type safety and better developer experience.\n-   **Tailwind CSS**: For utility-first styling (v4).\n-   **React Router DOM**: For declarative routing.\n-   **Vite**: As a fast development build tool.\n-   **Nanostores**: For lightweight global state management.\n\n## Expanding ESLint Configuration\n\nFor stricter type-aware linting, you can update your `eslint.config.ts` by replacing `tseslint.configs.recommended` with the following:\n\n```js\nexport default tseslint.config([\n  // ... other configs\n  {\n    files: ['**/*.{ts,tsx}'],\n    extends: [\n      ...tseslint.configs.recommendedTypeChecked,\n      // Alternatively, use this for stricter rules\n      // ...tseslint.configs.strictTypeChecked,\n      // Optionally, add this for stylistic rules\n      // ...tseslint.configs.stylisticTypeChecked,\n    ],\n    languageOptions: {\n      parserOptions: {\n        project: ['./tsconfig.node.json', './tsconfig.app.json'],\n        tsconfigRootDir: import.meta.dirname,\n      },\n    },\n  },\n  // ... other configs\n])\n```\n\nYou can also integrate React-specific lint rules by installing `eslint-plugin-react-x` and `eslint-plugin-react-dom` and adding them to your `extends` array:\n\n```js\n// eslint.config.js\nimport reactX from 'eslint-plugin-react-x'\nimport reactDom from 'eslint-plugin-react-dom'\n\nexport default tseslint.config([\n  // ... other configs\n  {\n    files: ['**/*.{ts,tsx}'],\n    extends: [\n      // ... other extends\n      reactX.configs['recommended-typescript'],\n      reactDom.configs.recommended,\n    ],\n    // ...\n  },\n])\n```\n\n\n// File: apps/ai-editor-front/eslint.config.ts\nimport globals from \"globals\";\nimport pluginJs from \"@eslint/js\";\nimport tseslint from \"typescript-eslint\";\nimport prettierPlugin from \"eslint-plugin-prettier\";\nimport prettierConfig from \"eslint-config-prettier\";\n\nexport default tseslint.config(\n  // Ignore patterns\n  {\n    ignores: [\n      \"node_modules/\",\n      \"dist/\",\n      \"coverage/\",\n      \"*.config.js\", // Exclude JS config files if they exist alongside TS config\n      \"*.mjs\", // Exclude ES module files if any special config needed\n      \"*.cjs\", // Exclude CommonJS files if any special config needed\n      \"package-lock.json\",\n    ],\n  },\n  // Global configuration for all files\n  {\n    languageOptions: {\n      ecmaVersion: \"latest\",\n      sourceType: \"module\",\n      globals: {\n        ...globals.node, // For Node.js environment\n        ...globals.browser, // Although it's a CLI tool, some browser globals might accidentally slip in via deps\n      },\n    },\n    linterOptions: {\n      reportUnusedDisableDirectives: \"error\",\n    },\n  },\n  // JavaScript rules (builtin recommended)\n  pluginJs.configs.recommended,\n  // TypeScript rules\n  ...tseslint.configs.recommended, // Uses recommended rules from @typescript-eslint\n  {\n    files: [\"**/*.ts\", \"**/*.tsx\"],\n    rules: {\n      // Add or override specific TypeScript rules here\n      \"@typescript-eslint/no-unused-vars\": [\n        \"warn\",\n        { argsIgnorePattern: \"^_\", varsIgnorePattern: \"^_\" }, // Allow unused args/vars starting with _\n      ],\n      \"@typescript-eslint/explicit-module-boundary-types\": \"off\", // Often too strict for simple functions\n      \"@typescript-eslint/no-explicit-any\": \"warn\", // Warn on any, don't block\n      \"@typescript-eslint/array-type\": [\"error\", { default: \"array-simple\" }],\n      \"@typescript-eslint/consistent-type-definitions\": [\"error\", \"interface\"], // Prefer interfaces over types for object literals\n    },\n  },\n  // Prettier integration\n  {\n    plugins: {\n      prettier: prettierPlugin,\n    },\n    rules: {\n      ...prettierConfig.rules,\n      \"prettier/prettier\": \"error\",\n    },\n  },\n);\n\n\n// File: apps/ai-editor-front/index.html\n<!doctype html>\n<html lang=\"en\" class=\"dark\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <link rel=\"icon\" type=\"image/svg+xml\" href=\"/vite.svg\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Vite + React + TS</title>\n  </head>\n  <body>\n    <div id=\"root\"></div>\n    <script type=\"module\" src=\"/src/main.tsx\"></script>\n  </body>\n</html>\n\n\n// File: apps/ai-editor-front/package.json\n{\n  \"name\": \"ai-editor-front\",\n  \"private\": true,\n  \"version\": \"0.0.0\",\n  \"type\": \"module\",\n  \"scripts\": {\n    \"dev\": \"vite\",\n    \"build\": \"tsc -b && vite build\",\n    \"lint\": \"eslint . --fix\",\n    \"preview\": \"vite preview\"\n  },\n  \"dependencies\": {\n    \"@nanostores/react\": \"^1.0.0\",\n    \"nanostores\": \"^1.0.1\",\n    \"react\": \"^19.1.1\",\n    \"react-dom\": \"^19.1.1\",\n    \"react-router-dom\": \"^6.25.1\"\n  },\n  \"devDependencies\": {\n    \"@eslint/js\": \"^9.33.0\",\n    \"@tailwindcss/vite\": \"^4.1.11\",\n    \"@types/react\": \"^19.1.10\",\n    \"@types/react-dom\": \"^19.1.7\",\n    \"@vitejs/plugin-react\": \"^5.0.0\",\n    \"autoprefixer\": \"^10.4.21\",\n    \"eslint\": \"^9.33.0\",\n    \"eslint-config-prettier\": \"^10.1.8\",\n    \"eslint-plugin-prettier\": \"^5.5.4\",\n    \"eslint-plugin-react-hooks\": \"^5.2.0\",\n    \"eslint-plugin-react-refresh\": \"^0.4.20\",\n    \"globals\": \"^16.3.0\",\n    \"postcss\": \"^8.5.6\",\n    \"tailwindcss\": \"^4.1.11\",\n    \"typescript\": \"~5.8.3\",\n    \"typescript-eslint\": \"^8.39.1\",\n    \"vite\": \"^7.1.2\"\n  }\n}\n\n\n// File: apps/ai-editor-front/tsconfig.app.json\n// tsconfig.app.json\n{\n  \"compilerOptions\": {\n    \"tsBuildInfoFile\": \"./node_modules/.tmp/tsconfig.app.tsbuildinfo\",\n    \"target\": \"ES2022\",\n    \"useDefineForClassFields\": true,\n    \"lib\": [\"ES2022\", \"DOM\", \"DOM.Iterable\"],\n    \"module\": \"ESNext\",\n    \"skipLibCheck\": true,\n\n    /* Bundler mode */\n    \"moduleResolution\": \"bundler\",\n    \"allowImportingTsExtensions\": true,\n    \"verbatimModuleSyntax\": true,\n    \"moduleDetection\": \"force\",\n    \"noEmit\": true,\n    \"jsx\": \"react-jsx\",\n\n    /* Linting */\n    \"strict\": true,\n    // --- START: Changes for TS6133 ---\n    \"noUnusedLocals\": false,     // Set to false to disable 'declared but never read' for local variables\n    \"noUnusedParameters\": false, // Set to false to disable 'declared but never read' for function parameters\n    // --- END: Changes for TS6133 ---\n    \"erasableSyntaxOnly\": true, // Keep as is, unrelated to this error\n    \"noFallthroughCasesInSwitch\": true,\n    \"noUncheckedSideEffectImports\": true\n  },\n  \"include\": [\"src\"]\n}\n\n\n// File: apps/ai-editor-front/tsconfig.json\n{\n  \"files\": [],\n  \"references\": [\n    { \"path\": \"./tsconfig.app.json\" },\n    { \"path\": \"./tsconfig.node.json\" }\n  ]\n}\n\n\n// File: apps/ai-editor-front/tsconfig.node.json\n{\n  \"compilerOptions\": {\n    \"tsBuildInfoFile\": \"./node_modules/.tmp/tsconfig.node.tsbuildinfo\",\n    \"target\": \"ES2023\",\n    \"lib\": [\"ES2023\"],\n    \"module\": \"ESNext\",\n    \"skipLibCheck\": true,\n\n    /* Bundler mode */\n    \"moduleResolution\": \"bundler\",\n    \"allowImportingTsExtensions\": true,\n    \"verbatimModuleSyntax\": true,\n    \"moduleDetection\": \"force\",\n    \"noEmit\": true,\n\n    /* Linting */\n    \"strict\": true,\n    \"noUnusedLocals\": true,\n    \"noUnusedParameters\": true,\n    \"erasableSyntaxOnly\": true,\n    \"noFallthroughCasesInSwitch\": true,\n    \"noUncheckedSideEffectImports\": true\n  },\n  \"include\": [\"vite.config.ts\"]\n}\n\n\n// File: apps/ai-editor-front/vite.config.ts\nimport { defineConfig, loadEnv } from \"vite\";\nimport react from \"@vitejs/plugin-react\";\nimport tailwindcss from \"@tailwindcss/vite\";\nimport path from \"path\";\n\nexport default defineConfig(({ mode }) => {\n  const env = loadEnv(mode, process.cwd());\n\n  return {\n    plugins: [react(), tailwindcss()],\n    resolve: {\n      alias: {\n        \"@\": path.resolve(__dirname, \"src\"),\n        \"@components\": path.resolve(__dirname, \"src/components\"),\n        \"@contexts\": path.resolve(__dirname, \"src/contexts\"),\n        \"@hooks\": path.resolve(__dirname, \"src/hooks\"),\n        \"@utils\": path.resolve(__dirname, \"src/utils\"),\n        \"@services\": path.resolve(__dirname, \"src/services\"),\n        \"@stores\": path.resolve(__dirname, \"src/stores\"),\n        \"@providers\": path.resolve(__dirname, \"src/providers\"),\n        \"@types\": path.resolve(__dirname, \"src/types\"),\n        \"@styles\": path.resolve(__dirname, \"src/styles\"),\n        \"@libs\": path.resolve(__dirname, \"src/libs\"),\n        \"@routes\": path.resolve(__dirname, \"src/routes\"),\n        \"@themes\": path.resolve(__dirname, \"src/themes\"),\n        \"@constants\": path.resolve(__dirname, \"src/constants\"),\n      },\n    },\n    build: {\n      chunkSizeWarningLimit: 1000,\n    },\n    server: {\n      port: 5173,\n      proxy: {\n        \"/api\": {\n          target: env.VITE_API_URL,\n          changeOrigin: true,\n          rewrite: (path) => path.replace(/^\\/api/, \"\"),\n        },\n\n        \"/socket.io\": {\n          target: env.VITE_API_URL,\n          changeOrigin: true,\n          ws: true,\n        },\n      },\n      cors: {\n        origin: [\"*\"],\n        methods: [\"GET\", \"POST\", \"OPTIONS\"],\n        allowedHeaders: [\"Content-Type\", \"Authorization\"],\n        credentials: true,\n      },\n      allowedHosts: [\"board-api.duckdns.org\", \"localhost\"],\n    },\n    define: {\n      \"process.env.NODE_ENV\": JSON.stringify(mode),\n      \"import.meta.env.BASE_URL_API\": JSON.stringify(env.BASE_URL),\n      \"import.meta.env.PROJECT_ROOT\": JSON.stringify(process.cwd()), // Renamed for clarity\n      \"import.meta.env.GITHUB_CALLBACK_URL\": JSON.stringify(\n        env.GITHUB_CALLBACK_URL,\n      ),\n      \"import.meta.env.GOOGLE_CALLBACK_URL\": JSON.stringify(\n        env.GOOGLE_CALLBACK_URL,\n      ),\n    },\n  };\n});\n\n\n// File: apps/ai-editor-front/src/App.tsx\nimport { BrowserRouter } from \"react-router-dom\";\nimport { AppRoutes } from \"./routes\";\n\nfunction App() {\n  return (\n    <BrowserRouter>\n      <AppRoutes />\n    </BrowserRouter>\n  );\n}\n\nexport default App;\n\n\n// File: apps/ai-editor-front/src/index.css\n@import \"tailwindcss\";\n\n@custom-variant dark (&:where(.dark, .dark *));\n@layer base {\n  :root {\n    --btn-bg: theme(colors.neutral.50);\n    --btn-text: theme(colors.neutral.900);\n    --btn-border: theme(colors.neutral.300);\n    --btn-hover-bg: theme(colors.sky.100);\n    --btn-hover-text: theme(colors.sky.700);\n    --btn-icon: theme(colors.neutral.600);\n    --btn-icon-hover: theme(colors.sky.600);\n  }\n  html.dark {\n    --btn-bg: theme(colors.neutral.800);\n    --btn-text: theme(colors.neutral.100);\n    --btn-border: theme(colors.neutral.800);\n    --btn-hover-bg: theme(colors.slate.900);\n    --btn-hover-text: theme(colors.slate.400);\n    --btn-icon: theme(colors.neutral.300);\n    --btn-icon-hover: theme(colors.sky.500);\n  }\n  :root {\n    --color-bg: theme(colors.neutral.50);\n    --color-text-accent: theme(colors.zinc.400);\n    --color-text: theme(colors.neutral.700);\n    --color-border: theme(colors.neutral.300);\n    --color-hover: theme(colors.neutral.200);\n    --color-resizer: theme(colors.neutral.300);\n    --color-resizer-hover: theme(colors.slate.200);\n    --color-pre-bg: theme(colors.neutral.100);\n    --color-bg-lighter: theme(colors.neutral.50);\n    --color-primary-bg: theme(colors.slate.200);\n    --color-extra-bg: theme(colors.slate.100);\n    --color-primary-text: theme(colors.yellow.800);\n    --color-success-bg: theme(colors.green.600);\n    --color-info-bg: theme(colors.sky.600);\n    --color-active-bg: theme(colors.zinc.400);\n    --color-error: theme(colors.red.600);\n    --color-warning: theme(colors.orange.600);\n    --color-muted: theme(colors.neutral.400);\n    --color-modal-bg: theme(colors.white / 0.8);\n    --color-shadow: rgba(0, 0, 0, 0.1);\n  }\n\n  html.dark {\n    --color-bg: theme(colors.neutral.950);\n    --color-text-accent: theme(colors.slate.400);\n    --color-text: theme(colors.neutral.200);\n    --color-border: theme(colors.neutral.800);\n    --color-hover: theme(colors.slate.500);\n    --color-resizer: theme(colors.neutral.800);\n    --color-resizer-hover: theme(colors.slate.800);\n    --color-pre-bg: theme(colors.neutral.900);\n    --color-bg-lighter: theme(colors.neutral.700);\n    --color-primary-bg: theme(colors.slate.800);\n    --color-extra-bg: theme(colors.slate.900);\n    --color-extra-dark: theme(colors.neutral.950 / 0.5);\n    --color-primary-text: theme(colors.slate.400);\n    --color-active-bg: theme(colors.slate.400);\n    --color-success: theme(colors.green.500);\n    --color-info: theme(colors.sky.500);\n    --color-error: theme(colors.red.500);\n    --color-warning: theme(colors.orange.500);\n    --color-muted: theme(colors.neutral.600);\n    --color-modal-bg: theme(colors.black / 0.7);\n    --color-shadow: rgba(255, 255, 255, 0.1);\n  }\n\n  body {\n    background-color: var(--color-bg);\n    color: var(--color-text);\n    font-size: var(--color-text);\n    @apply transition-colors duration-300;\n  }\n\n  button {\n    @apply p-[2px] min-w-[24px] text-sm;\n  }\n\n  button:hover {\n    @media (hover: hover) {\n      color: var(--color-sky-600);\n    }\n  }\n\n  html.dark button:hover {\n    @media (hover: hover) {\n      color: var(--color-sky-500);\n    }\n  }\n}\n@theme {\n  \n}\n.text-base {\n  color: var(--color-text);\n}\n.text-primary {\n  color: var(--color-primary-text);\n}\n.text-accent {\n  color: var(--color-text-accent);\n}\n.cursor-ns-resize {\n  cursor: ns-resize;\n}\n.cm-editor {\n  background-color: var(--color-bg);\n}\n.bg-primary {\n  background-color: var(--color-primary-bg);\n}\n.bg-secondary {\n  background-color: var(--color-pre-bg);\n}\n.bg-dark {\n  background-color: var(--color-bg);\n}\n.bg-dark-secondary {\n  background-color: var(--color-extra-dark);\n}\n.bg-dark-extra {\n  background-color: var(--color-extra-bg);\n}\n.bg-border {\n  background-color: var(--color-border);\n}\n\n.border-dark {\n  border-color: var(--color-bg);\n}\n.border-secondary {\n  border-color: var(--color-pre-bg);\n}\n.border {\n  border-color: var(--color-border);\n}\n.color-secondary {\n  color: var(--color-border);\n}\nbutton.active {\n  color: var(--color-bg);\n  background-color: var(--color-active-bg);\n}\n\nbutton:hover {\n  @apply opacity-50;\n  @apply cursor-pointer;\n}\n\nbutton:disabled {\n  color: var(--color-shadow);\n  @apply cursor-default;\n  @apply bg-transparent;\n}\n@layer components {\n  .border-t,\n  .border-b,\n  .border-l,\n  .border-r {\n    border-color: var(--color-border);\n  }\n\n  .resizer {\n    background-color: var(--color-resizer);\n  }\n\n  .resizer:hover {\n    background-color: var(--color-resizer-hover);\n  }\n  .editor-top-header {\n    @apply py-0;\n  }\n  .top-right-editor-buttons {\n    background-color: var(--color-pre-bg);\n  }\n  .file-tab-item:hover {\n    background-color: var(--color-hover);\n  }\n  .file-tab-item.active {\n  }\n  #context-menu {\n    background-color: var(--color-bg);\n    border-color: var(--color-border);\n    @apply border;\n  }\n  #directory-dropdown-menu {\n    background-color: var(--color-bg);\n  }\n  #context-menu li {\n    @apply cursor-pointer;\n  }\n\n  #context-menu li:hover {\n    background-color: var(--color-hover);\n  }\n\n  .collapsible-panel {\n    background-color: var(--color-bg);\n  }\n\n  html .collapsible-panel .collapsible-panel-header,\n  html .editor-top-header,\n  html .footer-wrapper {\n    background-color: theme(colors.gray.100);\n    border-bottom: 1px solid theme(colors.gray.300);\n  }\n\n  html.dark .collapsible-panel .collapsible-panel-header,\n  html.dark .editor-top-header,\n  html.dark .footer-wrapper {\n    background-color: theme(colors.gray.900);\n    border-bottom: 1px solid theme(colors.gray.800);\n  }\n\n  .dropdown-menu {\n    background-color: var(--color-pre-bg);\n    border-color: var(--color-border);\n  }\n\n  .dropdown-menu li.dropdown-item:hover {\n    background-color: var(--color-hover);\n  }\n  .terminal.xterm {\n    @apply p-3;\n  }\n\n  .editor-footer {\n    border-color: var(--color-border);\n    @apply border-t;\n  }\n\n  .typewriter-code-wrapper {\n    border-color: var(--color-border);\n    background-color: var(--color-hover);\n    @apply shadow-lg rounded-lg;\n  }\n\n  .typewriter-code-wrapper > .screen {\n    border-color: var(--color-border);\n    background-color: var(--color-bg);\n    @apply shadow-xl rounded-xl;\n  }\n\n  .dialog-modal {\n    background-color: var(--color-modal-bg);\n  }\n\n  .dialog-modal .dialog-modal-body {\n    border-color: var(--color-border);\n    background-color: var(--color-pre-bg);\n    color: var(--color-text);\n    @apply shadow-lg border;\n  }\n\n  .dialog-modal .dialog-modal-body button {\n    border-color: var(--color-border);\n    @apply shadow-xs mx-2 px-4 py-2;\n  }\n\n  .dialog-modal .dialog-modal-body input {\n    border-color: var(--color-border);\n    @apply text-sm px-4 py-1 border;\n  }\n\n  .dialog-modal .dialog-modal-body input:focus,\n  .dialog-modal .dialog-modal-body textarea:focus,\n  .dialog-modal .dialog-modal-body select:focus {\n    @apply border-sky-800 ring-1 ring-offset-2 ring-sky-700 shadow-md rounded;\n  }\n\n  html.dark .dialog-modal .dialog-modal-body input:focus,\n  html.dark .dialog-modal .dialog-modal-body textarea:focus,\n  html.dark .dialog-modal .dialog-modal-body select:focus {\n    @apply bg-sky-600;\n  }\n  .mini-audio-player {\n    background-color: var(--color-bg-lighter);\n    border-color: var(--color-primary-text);\n    color: var(--color-primary-text);\n  }\n  .btn {\n    background-color: var(--btn-bg);\n    color: var(--btn-text);\n    border: 1px solid var(--btn-border);\n    @apply inline-flex items-center justify-center rounded px-3 py-1.5 text-sm transition-colors duration-200;\n  }\n\n  .btn:hover {\n    background-color: var(--btn-hover-bg);\n    color: var(--btn-hover-text);\n  }\n\n  .btn-icon {\n    background-color: transparent;\n    color: var(--btn-icon);\n    @apply inline-flex items-center justify-center rounded p-1 transition-colors duration-200;\n  }\n\n  .btn-icon:hover {\n    color: var(--btn-icon-hover);\n    background-color: var(--btn-hover-bg);\n  }\n\n  .audio-player-playlist {\n    background-color: var(--color-pre-bg);\n  }\n  .audio-player-playlist li {\n    border-bottom: 1px solid;\n    padding: 4px;\n    border-color: var(--color-border);\n    @apply text-xs;\n    @apply px-3 py-2;\n  }\n  .audio-player-playlist li.active {\n    background-color: var(--color-modal-bg);\n    font-weight: bold;\n  }\n  .audio-player-playlist li:hover {\n    background-color: var(--color-hover);\n  }\n  .audio-player-playlist .playlist-header {\n    background-color: var(--color-modal-bg);\n    border-radius: 6px 6px 0px 0px;\n  }\n  .audio-player-playlist .player-header {\n    background-color: var(--color-hover);\n  }\n  .footer-mini-audio-player .scrolling-text {\n    background-color: var(--color-bg);\n  }\n  .dialog-modal .btn-confirm-ok {\n    background-color: theme(colors.red.500);\n  }\n  .dialog-modal .btn-confirm-cancel {\n    background-color: var(--color-modal-bg);\n  }\n  form label::first-letter {\n    text-transform: uppercase;\n    padding: 4px 0;\n  }\n  .modal-wrapper {\n    background-color: var(--color-modal-bg);\n  }\n  .modal-body {\n    background-color: var(--color-bg);\n  }\n  .modal-tabs button {\n    @apply rounded-t;\n    @apply rounded-b-none;\n    margin-right: 2px;\n  }\n  .modal-tabs button.active {\n    background-color: var(--color-bg);\n  }\n  .field-group {\n    background-color: var(--color-pre-bg);\n  }\n  .app-header {\n    background-color: var(--color-bg);\n  }\n\n  .app-footer {\n    background-color: var(--color-bg);\n  }\n\n  .explorer-header,\n  .browser-header {\n    background-color: var(--color-pre-bg);\n  }\n  .explorer-header .search-input {\n    border-color: var(--color-border);\n  }\n}\n@layer components {\n  .xterm {\n    text-align: left !important;\n  }\n  .xterm-viewport,\n  .xterm-screen {\n    text-align: left !important;\n  }\n}\n\n@layer utilities {\n  @keyframes shadowPulse {\n    0% {\n      box-shadow: 0 4px 6px var(--color-shadow);\n    }\n    50% {\n      box-shadow: 15px 15px 30px rgba(0, 128, 255, 0.5);\n    }\n    100% {\n      box-shadow: 0 4px 6px var(--color-shadow);\n    }\n  }\n\n  @keyframes shadowGradient {\n    0% {\n      box-shadow:\n        0 4px 6px var(--color-shadow),\n        0 0 10px rgba(255, 0, 0, 0.4);\n    }\n    33% {\n      box-shadow:\n        0 8px 12px rgba(0, 0, 0, 0.2),\n        0 0 20px rgba(0, 128, 255, 0.5);\n    }\n    66% {\n      box-shadow:\n        0 12px 16px rgba(0, 0, 0, 0.3),\n        0 0 30px rgba(128, 0, 255, 0.6);\n    }\n    100% {\n      box-shadow:\n        0 4px 6px var(--color-shadow),\n        0 0 10px rgba(255, 0, 0, 0.4);\n    }\n  }\n}\n\n@keyframes scroll-left {\n  0% {\n    transform: translateX(10%);\n  }\n  100% {\n    transform: translateX(-100%);\n  }\n}\n\n.animate-scroll {\n  animation: scroll-left 20s linear infinite;\n}\n\n.vertical-slider {\n  -webkit-appearance: none;\n  appearance: none;\n  width: 8px;\n  height: 80px;\n  background: transparent;\n  transform: rotate(-90deg);\n  cursor: pointer;\n}\n\n.vertical-slider::-webkit-slider-thumb {\n  -webkit-appearance: none;\n  appearance: none;\n\n  width: 12px;\n  height: 12px;\n  border-radius: 50%;\n  border: 1px solid #0f172a;\n}\n\n.vertical-slider::-moz-range-thumb {\n  width: 12px;\n  height: 12px;\n  border-radius: 50%;\n  border: 1px solid #0f172a;\n}\n\n.endpoint-explorer-container {\n  max-width: 1200px;\n  margin: 0 auto;\n  border-radius: 8px;\n  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);\n  padding: 20px;\n}\n\nh1,\nh2,\nh3 {\n  color: var(--color-muted);\n}\n\n.controller-selector {\n  margin-bottom: 20px;\n  padding-bottom: 20px;\n  border-bottom: 1px solid #eee;\n}\n\n.controller-selector label {\n  margin-right: 10px;\n  font-weight: bold;\n}\n\n.controller-selector select {\n  padding: 8px 12px;\n\n  border-radius: 4px;\n  cursor: pointer;\n  min-width: 200px;\n}\n\n.main-content {\n}\n\n.endpoint-list {\n  flex: 1;\n  max-height: 70vh;\n  overflow-y: auto;\n  border-right: 1px solid #eee;\n  padding-right: 20px;\n}\n\n.endpoint-list h2 {\n  margin-top: 0;\n  border-bottom: 1px solid #eee;\n  padding-bottom: 10px;\n  margin-bottom: 15px;\n}\n\n.endpoint-list ul {\n  list-style: none;\n  padding: 0;\n}\n\n.endpoint-list li {\n  margin-bottom: 5px;\n}\n\n.endpoint-list button {\n  width: 100%;\n  text-align: left;\n  padding: 10px 15px;\n  border: none;\n\n  border-radius: 5px;\n  cursor: pointer;\n  font-size: 1em;\n  line-height: 1.4;\n}\n\n.endpoint-list li.active button {\n  color: white;\n  font-weight: bold;\n}\n\n.method-tag {\n  display: inline-block;\n  padding: 3px 8px;\n  border-radius: 3px;\n  font-weight: bold;\n  font-size: 0.8em;\n  margin-right: 5px;\n  min-width: 60px;\n  text-align: center;\n}\n\n.method-tag.GET {\n  color: white;\n}\n.method-tag.POST {\n  color: white;\n}\n.method-tag.PUT {\n}\n.method-tag.DELETE {\n  color: white;\n}\n.method-tag.PATCH {\n  background-color: #6f42c1;\n  color: white;\n}\n\n.endpoint-tester {\n  flex: 2;\n  padding-left: 20px;\n}\n\n.endpoint-tester h2 {\n  margin-top: 0;\n  border-bottom: 1px solid #eee;\n  padding-bottom: 10px;\n  margin-bottom: 15px;\n}\n\n.endpoint-details p {\n  margin-bottom: 8px;\n}\n\n.endpoint-details strong {\n  color: #555;\n}\n\n.param-section,\n.body-section,\n.response-section {\n  border: 1px solid #eee;\n  border-radius: 5px;\n  padding: 15px;\n  margin-bottom: 20px;\n}\n\n.param-input {\n  display: flex;\n  align-items: center;\n  margin-bottom: 10px;\n  gap: 10px;\n}\n\n.param-input label {\n  flex: 0 0 100px;\n  font-weight: bold;\n}\n\n.param-input input[type=\"text\"],\n.path-input {\n  flex: 1;\n  padding: 8px;\n\n  border-radius: 4px;\n  font-family: monospace;\n}\n\ntextarea {\n  width: 100%;\n  padding: 10px;\n\n  border-radius: 4px;\n  font-family: monospace;\n  font-size: 0.9em;\n}\n\n.execute-button {\n  border: 1px solid #eee;\n  padding: 10px 20px;\n  border-radius: 5px;\n  cursor: pointer;\n  font-size: 1em;\n}\n\n.execute-button:hover:not(:disabled) {\n}\n\n.execute-button:disabled {\n  cursor: not-allowed;\n}\n\n.response-section pre {\n  padding: 15px;\n  border-radius: 5px;\n  overflow-x: auto;\n  font-family: monospace;\n  font-size: 0.9em;\n  white-space: pre-wrap;\n  word-break: break-all;\n}\n.response-body pre,\n.response-headers pre {\n  padding: 1em !important;\n  margin: 0 !important;\n  border-radius: 4px;\n  background: var(---color-bg);\n}\n\n.response-status {\n  margin-bottom: 10px;\n  padding: 8px;\n\n  border-left: 5px solid #2196f3;\n}\n\n// File: apps/ai-editor-front/src/main.tsx\nimport { StrictMode } from \"react\";\nimport { createRoot } from \"react-dom/client\";\nimport \"./index.css\";\nimport App from \"./App.tsx\";\nimport { AuthProvider } from \"./context/AuthContext.tsx\";\n\ncreateRoot(document.getElementById(\"root\")!).render(\n  <StrictMode>\n    <AuthProvider>\n      <App />\n    </AuthProvider>\n  </StrictMode>,\n);\n\n\n// File: apps/ai-editor-front/src/vite-env.d.ts\n/// <reference types=\"vite/client\" />\n\ninterface ImportMetaEnv {\n  readonly VITE_API_URL: string;\n  readonly PROJECT_ROOT: string; // Declared the new PROJECT_ROOT variable\n  readonly GITHUB_CALLBACK_URL: string;\n  readonly GOOGLE_CALLBACK_URL: string;\n}\n\ninterface ImportMeta {\n  readonly env: ImportMetaEnv;\n}\n\n\n// File: apps/ai-editor-front/src/api/auth.ts\nimport type { User } from \"../types/auth\";\n\nconst API_BASE_URL = \"/api\"; // Assuming backend is served from the same origin, or configure with process.env.VITE_API_BASE_URL\n\ninterface LoginResponse {\n  accessToken: string;\n  user: User;\n}\n\n/**\n * Fetches the currently authenticated user's profile.\n * @returns {Promise<User | null>} The user object if authenticated, otherwise null.\n */\nexport async function getProfile(): Promise<User | null> {\n  try {\n    const response = await fetch(`${API_BASE_URL}/auth/me`);\n    if (response.ok) {\n      const userData: User = await response.json();\n      return userData;\n    } else if (response.status === 401) {\n      // Not authenticated, which is expected if no cookie is present\n      return null;\n    }\n    throw new Error(`Failed to fetch profile: ${response.statusText}`);\n  } catch (error) {\n    console.error(\"Error fetching profile:\", error);\n    // If there's a network error or other issue, assume not authenticated\n    return null;\n  }\n}\n\n/**\n * Logs out the current user.\n * @returns {Promise<void>}\n */\nexport async function logout(): Promise<void> {\n  try {\n    const response = await fetch(`${API_BASE_URL}/auth/logout`, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n    });\n    if (!response.ok) {\n      throw new Error(`Logout failed: ${response.statusText}`);\n    }\n  } catch (error) {\n    console.error(\"Error during logout:\", error);\n    throw error; // Re-throw to allow calling component to handle\n  }\n}\n\n/**\n * Redirects to the Google OAuth login endpoint.\n */\nexport function redirectToGoogleAuth(): void {\n  window.location.href = `${API_BASE_URL}/auth/google`;\n}\n\n/**\n * Redirects to the GitHub OAuth login endpoint.\n */\nexport function redirectToGitHubAuth(): void {\n  window.location.href = `${API_BASE_URL}/auth/github`;\n}\n\n// Placeholder for direct email/password login if needed in the future\nexport async function loginWithCredentials(\n  email: string,\n  password: string,\n): Promise<LoginResponse> {\n  const response = await fetch(`${API_BASE_URL}/auth/login`, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify({ email, password }),\n  });\n  if (!response.ok) {\n    const errorData = await response.json();\n    throw new Error(errorData.message || \"Login failed\");\n  }\n  return response.json();\n}\n\n// Placeholder for direct email/password registration if needed in the future\nexport async function registerWithCredentials(data: any): Promise<any> {\n  const response = await fetch(`${API_BASE_URL}/auth/register`, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify(data),\n  });\n  if (!response.ok) {\n    const errorData = await response.json();\n    throw new Error(errorData.message || \"Registration failed\");\n  }\n  return response.json();\n}\n\n\n// File: apps/ai-editor-front/src/components/Button.tsx\nimport React, { type PropsWithChildren } from \"react\";\n\ninterface ButtonProps extends React.ComponentPropsWithoutRef<\"button\"> {\n  onClick?: React.MouseEventHandler<HTMLButtonElement>;\n}\n\nexport function Button({\n  children,\n  onClick,\n  className,\n  type = \"button\", // Default to 'button' to prevent unintended form submission\n  ...props\n}: PropsWithChildren<ButtonProps>) {\n  const baseClasses = \"btn\"; // This class is defined in src/index.css\n  const combinedClasses = `${baseClasses} ${className || \"\"}`.trim();\n\n  return (\n    <button\n      type={type}\n      onClick={onClick}\n      className={combinedClasses}\n      {...props}\n    >\n      {children}\n    </button>\n  );\n}\n\n\n// File: apps/ai-editor-front/src/components/Layout.tsx\nimport type { PropsWithChildren } from \"react\";\nimport { Link } from \"react-router-dom\";\nimport { useAuth } from \"../hooks/useAuth\";\n\nexport function Layout({ children }: PropsWithChildren) {\n  const { isAuthenticated, user, logout, isLoading } = useAuth();\n\n  return (\n    <div className=\"flex flex-col min-h-screen bg-gradient-to-br from-gray-900 to-gray-800 text-gray-100\">\n      <header className=\"py-4 px-6 border-b border-gray-700 app-header\">\n        <nav className=\"max-w-7xl mx-auto flex justify-between items-center\">\n          <Link\n            to=\"/\"\n            className=\"text-2xl font-bold text-indigo-400 hover:text-indigo-300 transition-colors\"\n          >\n            AI Editor\n          </Link>\n          <ul className=\"flex space-x-6 items-center\">\n            <li>\n              <Link\n                to=\"/\"\n                className=\"text-gray-300 hover:text-white transition-colors\"\n              >\n                Home\n              </Link>\n            </li>\n            <li>\n              <Link\n                to=\"/editor\"\n                className=\"text-gray-300 hover:text-white transition-colors\"\n              >\n                Editor\n              </Link>\n            </li>\n            {!isLoading &&\n              (isAuthenticated ? (\n                <>\n                  <li className=\"text-gray-300\">\n                    Welcome, {user?.name || user?.email}!\n                  </li>\n                  <li>\n                    <button\n                      onClick={logout}\n                      className=\"text-red-400 hover:text-red-300 transition-colors py-1 px-3 rounded border border-red-500 hover:bg-red-900\"\n                    >\n                      Logout\n                    </button>\n                  </li>\n                </>\n              ) : (\n                <li>\n                  <Link\n                    to=\"/login\"\n                    className=\"px-4 py-2 bg-indigo-600 text-white font-semibold rounded-lg shadow-md hover:bg-indigo-700 transition-colors\"\n                  >\n                    Login\n                  </Link>\n                </li>\n              ))}\n          </ul>\n        </nav>\n      </header>\n      <main className=\"flex-grow flex flex-col items-center justify-center p-8\">\n        {children}\n      </main>\n      <footer className=\"py-4 px-6 border-t border-gray-700 text-center text-gray-400 text-sm app-footer\">\n        © {new Date().getFullYear()} AI Editor. All rights reserved.\n      </footer>\n    </div>\n  );\n}\n\n\n// File: apps/ai-editor-front/src/constants/index.ts\nexport const INSTRUCTION = `\n            You are an expert TypeScript/React/Tailwind developer.\n            Focus on creating clean, idiomatic code. Ensure all generated code is fully type-safe.\n            When modifying existing files, preserve existing formatting and code style as much as possible.\n            If adding new components or modules, place them in logical, idiomatic locations within the project structure.\n            Consider common best practices for React (hooks, functional components, state management with nanostores if applicable) and Tailwind CSS v4 (utility-first, responsive design).\n            If a new file is created, ensure it follows the correct naming conventions and is properly imported/exported where necessary.\n            Always consider the full context of the project when making changes.\n            For 'modify' actions, provide only the *entire new content* of the file, not just a diff.\n            For 'add' actions, provide the *entire content* of the new file.\n            For 'delete' actions, no newContent is required.\n            If you need to add a new dependency, mention it in the summary or thought process, but do NOT include 'npm install' or 'yarn add' commands in the file changes.\n          `.replace(/^\\s+/gm, \"\");\nexport const ADDIONAL_INSTRUCTION_EXPECTED_OUTPUT = `\n            Your response must be a JSON object with two top-level keys: 'summary' (string) and 'changes' (array of objects).\n            The 'changes' array should contain objects, each representing a file operation:\n            {\n              \"filePath\": \"path/to/file.tsx\", // Absolute path (use path.join(projectRoot, relativePath) to construct)\n              \"action\": \"add\" | \"modify\" | \"delete\",\n              \"newContent\"?: \"...\", // Required for 'add'/'modify', omit for 'delete'\n              \"reason\"?: \"...\" // Optional, short explanation for this specific file change\n            }\n            Example:\n            {\n              \"summary\": \"Implemented user authentication and updated Navbar component.\",\n              \"thoughtProcess\": \"Created new components for login and signup, updated navigation to include auth links, and added a basic auth context.\",\n              \"changes\": [\n                {\n                  \"filePath\": \"/path/to/project/src/auth/Login.tsx\",\n                  \"action\": \"add\",\n                  \"newContent\": \"import React from 'react';\\\\nimport { useStore } from '@nanostores/react';\\\\nimport { authStore } from './authStore';\\\\n\\\\nfunction Login() {\\\\n  const $auth = useStore(authStore);\\\\n  // ... login form logic\\\\n  return <div className='p-4'>Login Form</div>;\\\\n}\\\\nexport default Login;\",\n                  \"reason\": \"New login component for user authentication.\"\n                },\n                {\n                  \"filePath\": \"/path/to/project/src/components/Navbar.tsx\",\n                  \"action\": \"modify\",\n                  \"newContent\": \"import React from 'react';\\\\nimport { Link } from 'react-router-dom';\\\\nimport { useStore } from '@nanostores/react';\\\\nimport { authStore } from '../auth/authStore';\\\\n\\\\nfunction Navbar() {\\\\n  const $auth = useStore(authStore);\\\\n  return (\\\\n    <nav className='bg-blue-500 p-4 text-white flex justify-between'>\\\\n      <Link to='/' className='font-bold text-lg'>My App</Link>\\\\n      <div>\\\\n        {$auth.isLoggedIn ? (\\\\n          <button onClick={() => authStore.setKey('isLoggedIn', false)} className='ml-4'>Logout</button>\\\\n        ) : (\\\\n          <>\\\\n            <Link to='/login' className='ml-4'>Login</Link>\\\\n            <Link to='/signup' className='ml-4'>Signup</Link>\\\\n          </>\\\\n        )}\\\\n      </div>\\\\n    </nav>\\\\n  );\\\\n}\\\\nexport default Navbar;\",\n                  \"reason\": \"Added login/logout links to Navbar based on authentication status.\"\n                },\n                {\n                  \"filePath\": \"/path/to/project/src/old/DeprecatedComponent.ts\",\n                  \"action\": \"delete\",\n                  \"reason\": \"Removed unused component as part of refactor.\"\n                }\n              ]\n            }\n          `.replace(/^\\s+/gm, \"\");\n\n\n// File: apps/ai-editor-front/src/context/AuthContext.tsx\nimport React, {\n  createContext,\n  useState,\n  useEffect,\n  useCallback,\n  type PropsWithChildren,\n} from \"react\";\nimport { getProfile, logout as apiLogout } from \"../api/auth\";\nimport type { User, AuthContextType } from \"../types/auth\";\n\n// Create the Auth Context with a default null value\nexport const AuthContext = createContext<AuthContextType | null>(null);\n\nexport function AuthProvider({ children }: PropsWithChildren) {\n  const [user, setUser] = useState<User | null>(null);\n  const [isLoading, setIsLoading] = useState(true);\n\n  const isAuthenticated = !!user;\n\n  // Function to set user data (e.g., after login)\n  const login = useCallback((userData: User) => {\n    setUser(userData);\n  }, []);\n\n  // Function to clear user data (e.g., after logout)\n  const logout = useCallback(async () => {\n    try {\n      await apiLogout();\n      setUser(null);\n    } catch (error) {\n      console.error(\"Failed to log out:\", error);\n      // Optionally, show an error message to the user\n    }\n  }, []);\n\n  // Function to check authentication status on mount or when needed\n  const checkAuthStatus = useCallback(async () => {\n    setIsLoading(true);\n    try {\n      const userData = await getProfile();\n      setUser(userData);\n    } catch (error) {\n      console.error(\"Error checking auth status:\", error);\n      setUser(null);\n    } finally {\n      setIsLoading(false);\n    }\n  }, []);\n\n  // Check auth status on initial mount\n  useEffect(() => {\n    checkAuthStatus();\n  }, [checkAuthStatus]);\n\n  const contextValue = React.useMemo(\n    () => ({\n      user,\n      isAuthenticated,\n      isLoading,\n      login,\n      logout,\n      checkAuthStatus,\n    }),\n    [user, isAuthenticated, isLoading, login, logout, checkAuthStatus],\n  );\n\n  return (\n    <AuthContext.Provider value={contextValue}>{children}</AuthContext.Provider>\n  );\n}\n\n\n// File: apps/ai-editor-front/src/hooks/useAuth.ts\nimport { useContext } from \"react\";\nimport { AuthContext } from \"../context/AuthContext\";\nimport type { AuthContextType } from \"../types/auth\";\n\n/**\n * Custom hook to access the authentication context.\n * Throws an error if used outside of an AuthProvider.\n * @returns {AuthContextType}\n */\nexport function useAuth(): AuthContextType {\n  const context = useContext(AuthContext);\n  if (!context) {\n    throw new Error(\"useAuth must be used within an AuthProvider\");\n  }\n  return context;\n}\n\n\n// File: apps/ai-editor-front/src/pages/AiEditorBackup.tsx\nimport { useState, useCallback } from \"react\";\nimport { Link } from \"react-router-dom\";\nimport { Button } from \"../components/Button\";\nimport { INSTRUCTION, ADDIONAL_INSTRUCTION_EXPECTED_OUTPUT } from \"../constants\"; // Import constants\nimport { extractJsonFromMarkdown, repairJsonBadEscapes, joinPaths } from \"../utils\"; // Import utility functions including joinPaths\nimport type {\n  FrontendProposedFileChange,\n  LLMOutput,\n} from \"../types\";\n\n// Backend DTO type for generate-text matching ../../full-stack/src/google/google-gemini/google-gemini-file/dto/generate-text.dto.ts\ninterface GenerateTextDto {\n  prompt: string;\n  systemInstruction?: string;\n  conversationId?: string;\n}\n\n// Define a type for the AI response that can be either structured LLMOutput or raw text\ntype AiResponseContent = LLMOutput | string | null;\n\n// Component for displaying a single proposed file change\ninterface FileChangeDisplayProps {\n  change: FrontendProposedFileChange;\n  onStatusChange: (\n    filePath: string,\n    status: \"pending\" | \"accepted\" | \"rejected\",\n  ) => void;\n}\n\nfunction FileChangeDisplay({ change, onStatusChange }: FileChangeDisplayProps) {\n  const {\n    filePath,\n    action,\n    newContent,\n    reason,\n    status,\n  } = change;\n\n  const statusClasses = {\n    pending: \"border-blue-400 text-blue-200\",\n    accepted: \"border-green-400 text-green-200\",\n    rejected: \"border-red-400 text-red-200\",\n  };\n\n  return (\n    <div\n      className={`p-4 mb-4 rounded-lg border ${statusClasses[status]} shadow-lg bg-gray-800`}\n    >\n      <div className=\"flex justify-between items-center mb-2 flex-wrap\">\n        <h3 className=\"text-xl font-semibold flex-grow min-w-0\">\n          <span className=\"font-mono text-indigo-300 break-all\">\n            {filePath}\n          </span>\n          <span\n            className={`ml-3 px-2 py-1 rounded-full text-xs font-bold ${\n              action === \"add\"\n                ? \"bg-green-600\"\n                : action === \"modify\"\n                  ? \"bg-yellow-600\"\n                  : \"bg-red-600\"\n            }`}\n          >\n            {action.toUpperCase()}\n          </span>\n        </h3>\n        <div className=\"flex space-x-2 mt-2 md:mt-0 flex-shrink-0\">\n          <Button\n            className={`text-sm px-3 py-1 ${status === \"accepted\" ? \"bg-green-700\" : \"bg-gray-700 hover:bg-green-600\"}`}\n            onClick={() => onStatusChange(filePath, \"accepted\")}\n            disabled={status === \"accepted\"}\n          >\n            Accept\n          </Button>\n          <Button\n            className={`text-sm px-3 py-1 ${status === \"rejected\" ? \"bg-red-700\" : \"bg-gray-700 hover:bg-red-600\"}`}\n            onClick={() => onStatusChange(filePath, \"rejected\")}\n            disabled={status === \"rejected\"}\n          >\n            Reject\n          </Button>\n          <Button\n            className={`text-sm px-3 py-1 ${status === \"pending\" ? \"bg-blue-700\" : \"bg-gray-700 hover:bg-blue-600\"}`}\n            onClick={() => onStatusChange(filePath, \"pending\")}\n            disabled={status === \"pending\"}\n          >\n            Reset\n          </Button>\n        </div>\n      </div>\n      {reason && <p className=\"text-sm text-gray-400 mb-2\">Reason: {reason}</p>}\n\n      {action === \"add\" && newContent && (\n        <div>\n          <h4 className=\"font-medium text-gray-300 mb-1\">New Content:</h4>\n          <pre className=\"bg-gray-900 p-3 rounded-md overflow-auto text-xs text-gray-200\">\n            <code>{newContent}</code>\n          </pre>\n        </div>\n      )}\n\n      {action === \"modify\" && (\n        <div className=\"flex flex-col md:flex-row gap-4\">\n          <div className=\"flex-1\">\n            {/* Original content cannot be displayed dynamically if not provided by the AI response */}\n            <h4 className=\"font-medium text-gray-300 mb-1\">\n              Original Content: (Not available from AI response)\n            </h4>\n            <pre className=\"bg-gray-900 p-3 rounded-md overflow-auto text-xs text-gray-200\">\n              <code>{/* Placeholder or fetch from backend if available */}\n              </code>\n            </pre>\n          </div>\n          <div className=\"flex-1\">\n            <h4 className=\"font-medium text-gray-300 mb-1\">New Content:</h4>\n            <pre className=\"bg-gray-900 p-3 rounded-md overflow-auto text-xs text-gray-200\">\n              <code>{newContent}</code>\n            </pre>\n          </div>\n        </div>\n      )}\n\n      {action === \"delete\" && (\n        <p className=\"text-red-300 italic\">This file will be deleted.</p>\n      )}\n    </div>\n  );\n}\n\nexport function AiEditorPage() {\n  const [prompt, setPrompt] = useState<string>(\n    // Initial user-facing prompt. The full instruction and output format will be combined later.\n    \"Generate TypeScript code to implement a simple React component that displays a welcome message. The component should be named WelcomeMessage.tsx and export a functional component.\",\n  );\n  const [isLoading, setIsLoading] = useState(false);\n  const [aiResponseContent, setAiResponseContent] = useState<AiResponseContent>(null);\n  const [proposedChanges, setProposedChanges] = useState<FrontendProposedFileChange[]>(\n    [],\n  );\n\n  const handleGenerateClick = useCallback(async () => {\n    if (!prompt.trim()) {\n      alert(\"Please enter a prompt.\");\n      return;\n    }\n\n    setIsLoading(true);\n    setAiResponseContent(null);\n    setProposedChanges([]);\n\n    try {\n      const generateTextDto: GenerateTextDto = {\n        prompt: `# User Request:\\n${prompt.trim()}`,\n        systemInstruction: `${INSTRUCTION}\\n\\n${ADDIONAL_INSTRUCTION_EXPECTED_OUTPUT}`,\n      };\n\n      // Call the backend's generate-text endpoint\n      const response = await fetch(\"/api/gemini/file/generate-text\", {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify(generateTextDto),\n      });\n\n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(\n          errorData.message || `HTTP error! status: ${response.status}`,\n        );\n      }\n\n      const aiRawResponseText: string = await response.text(); // Renamed for clarity\n      console.log(\"Raw AI response:\", aiRawResponseText);\n\n      try {\n        // 1. Extract potential JSON from markdown block\n        const extractedJsonString = extractJsonFromMarkdown(aiRawResponseText);\n        console.log(\"Extracted JSON string:\", extractedJsonString);\n\n        // 2. Attempt to repair common bad escape sequences\n        const repairedJsonString = repairJsonBadEscapes(extractedJsonString);\n        console.log(\"Repaired JSON string:\", repairedJsonString);\n\n        let parsedResponse: LLMOutput;\n        try {\n          // Attempt to parse the repaired string as LLMOutput JSON\n          parsedResponse = JSON.parse(repairedJsonString);\n        } catch (parseError) {\n          // If parsing fails after repair, log and set as raw text\n          console.error(\"Failed to parse repaired AI response as JSON:\", parseError);\n          setAiResponseContent(aiRawResponseText); // Fallback to original raw text\n          return; // Exit early if parsing failed\n        }\n\n        // Basic validation to check if it looks like an LLMOutput\n        if (\n          parsedResponse &&\n          Array.isArray(parsedResponse.changes) &&\n          typeof parsedResponse.summary === \"string\"\n        ) {\n          setAiResponseContent(parsedResponse);\n          // Initialize proposed changes with 'pending' status\n          const initialChanges: FrontendProposedFileChange[] = parsedResponse.changes.map((change) => ({\n            ...change,\n            status: \"pending\",\n          }));\n          setProposedChanges(initialChanges);\n        } else {\n          // If parsing succeeded but didn't match LLMOutput structure\n          setAiResponseContent(\n            \"AI response was structured but not in the expected file change format.\\n\" + aiRawResponseText,\n          );\n        }\n      } catch (error) {\n        // Catch any errors from extraction or repair functions, or initial response processing\n        console.error(\"Error processing AI response (extraction/repair stage):\", error);\n        setAiResponseContent(aiRawResponseText); // Always fall back to raw text on any processing error\n      }\n    } catch (error) {\n      console.error(\"Error generating AI response:\", error);\n      alert(`Failed to generate response: ${(error as Error).message}`);\n    } finally {\n      setIsLoading(false);\n    }\n  }, [prompt]);\n\n  const handleStatusChange = useCallback(\n    (filePath: string, status: \"pending\" | \"accepted\" | \"rejected\") => {\n      setProposedChanges((prevChanges) =>\n        prevChanges.map((change) =>\n          change.filePath === filePath ? { ...change, status } : change,\n        ),\n      );\n    },\n    [],\n  );\n\n  const handleApplyChanges = useCallback(async () => {\n    const acceptedChanges = proposedChanges.filter(\n      (change) => change.status === \"accepted\",\n    );\n    if (acceptedChanges.length === 0) {\n      alert(\"No changes accepted to apply.\");\n      return;\n    }\n\n    setIsLoading(true); // Indicate that changes are being applied\n\n    const projectRoot = import.meta.env.PROJECT_ROOT; // Get the project root from Vite's environment variables\n\n    // *** FIX: Robustness check for PROJECT_ROOT ***\n    if (!projectRoot || typeof projectRoot !== 'string' || projectRoot.trim() === '') {\n      alert(\n        \"Error: PROJECT_ROOT environment variable is not set or is empty. \" +\n        \"Please ensure your Vite configuration or .env file properly defines VITE_PROJECT_ROOT.\"\n      );\n      setIsLoading(false);\n      return; // Abort the operation\n    }\n\n    const operations: Promise<Response>[] = [];\n    const successfulChanges: string[] = [];\n    const failedChanges: { filePath: string; error: string }[] = [];\n\n    for (const change of acceptedChanges) {\n      let finalFilePath = change.filePath;\n\n      // Check if the filePath is already an absolute path (starts with / or Windows drive letter)\n      const isAbsolutePath = finalFilePath.startsWith('/') || /^[a-zA-Z]:[\\\\/]/.test(finalFilePath);\n\n      if (!isAbsolutePath) {\n        // Prepend projectRoot only if it's a relative path\n        finalFilePath = joinPaths(projectRoot, finalFilePath);\n      } else if (!finalFilePath.startsWith(projectRoot)) {\n        // If it's an absolute path but doesn't start with projectRoot, warn the user.\n        // This implies the AI might have proposed a path outside the project, which could be problematic.\n        console.warn(\n          `AI proposed an absolute path '${finalFilePath}' that does not start with the configured PROJECT_ROOT '${projectRoot}'. ` +\n          `Attempting to use this path as-is, but verify it's intended.`\n        );\n      }\n\n      let apiCall: Promise<Response>;\n      switch (change.action) {\n        case \"add\":\n          apiCall = fetch(\"/api/file/create\", {\n            method: \"POST\",\n            headers: { \"Content-Type\": \"application/json\" },\n            body: JSON.stringify({\n              filePath: finalFilePath,\n              isDirectory: false,\n              content: change.newContent || \"\", // Provide empty string if content is undefined\n            }),\n          });\n          break;\n        case \"modify\":\n          apiCall = fetch(\"/api/file/write\", {\n            method: \"POST\",\n            headers: { \"Content-Type\": \"application/json\" },\n            body: JSON.stringify({\n              filePath: finalFilePath,\n              content: change.newContent || \"\", // Provide empty string if content is undefined\n            }),\n          });\n          break;\n        case \"delete\":\n          apiCall = fetch(\"/api/file/delete\", {\n            method: \"POST\",\n            headers: { \"Content-Type\": \"application/json\" },\n            body: JSON.stringify({ filePath: finalFilePath }),\n          });\n          break;\n        default:\n          console.warn(`Unknown action type: ${change.action} for ${change.filePath}. Skipping.`);\n          continue; // Skip unknown actions\n      }\n\n      operations.push(apiCall.then(async (response) => {\n        if (!response.ok) {\n          const errorData = await response.json();\n          throw new Error(errorData.message || `HTTP error! status: ${response.status}`);\n        }\n        successfulChanges.push(change.filePath); // Track successful changes\n        return response;\n      }).catch(error => {\n        failedChanges.push({ filePath: change.filePath, error: error.message }); // Track failed changes\n        console.error(`Failed to apply change for ${change.filePath}:`, error);\n        // Do NOT re-throw here, as Promise.all should resolve even if some fail\n        // We're handling individual errors and collecting them.\n      }));\n    }\n\n    try {\n      await Promise.all(operations); // Wait for all promises to settle (even if some caught errors)\n\n      if (failedChanges.length === 0) {\n        alert(`Successfully applied ${successfulChanges.length} changes.`);\n      } else {\n        alert(\n          `Applied ${successfulChanges.length} changes, but ${failedChanges.length} failed.\\n` +\n          `Failed files:\\n${failedChanges.map(f => `  - ${f.filePath}: ${f.error}`).join('\\n')}`\n        );\n      }\n\n      // Reset state after attempting all applications\n      setAiResponseContent(null);\n      setProposedChanges([]);\n      setPrompt(\"\");\n\n    } catch (error) {\n      // This catch block would only be hit if one of the promises in 'operations'\n      // did not have its error caught and re-threw it, causing Promise.all to reject.\n      // With the individual .catch blocks, this specific catch might be less frequently hit,\n      // but it's good to keep for robustness.\n      console.error(\"An unexpected error occurred during application of changes:\", error);\n      alert(`An unexpected error occurred: ${(error as Error).message}`);\n    } finally {\n      setIsLoading(false);\n    }\n  }, [proposedChanges]);\n\n  const acceptedCount = proposedChanges.filter(\n    (c) => c.status === \"accepted\",\n  ).length;\n\n  const isLlmOutput = (content: AiResponseContent): content is LLMOutput => {\n    return (\n      content !== null &&\n      typeof content === \"object\" &&\n      \"changes\" in content &&\n      Array.isArray(content.changes) &&\n      \"summary\" in content &&\n      typeof content.summary === \"string\"\n    );\n  };\n\n  return (\n    <div className=\"flex flex-col flex-grow p-4 md:p-8 max-w-full lg:max-w-7xl mx-auto w-full\">\n      <h1 className=\"text-4xl font-bold text-white mb-6 text-center\">\n        AI Editor <span className=\"text-indigo-400\">Frontend</span>\n      </h1>\n\n      {/* Prompt Input Section */}\n      <div className=\"p-6 bg-gray-800 rounded-lg shadow-xl border border-gray-700 mb-8\">\n        <h2 className=\"text-2xl font-semibold text-indigo-300 mb-4\">\n          Your Request\n        </h2>\n        <textarea\n          className=\"w-full p-3 rounded-md bg-gray-900 text-gray-100 border border-gray-700 focus:ring-2 focus:ring-indigo-500 focus:border-transparent outline-none\"\n          rows={5}\n          placeholder=\"Describe the changes you want the AI to make (e.g., 'Add a new user authentication module', 'Refactor the data fetching logic in App.tsx to use React Query').\"\n          value={prompt}\n          onChange={(e) => setPrompt(e.target.value)}\n          disabled={isLoading}\n        ></textarea>\n        <div className=\"mt-4 flex justify-end\">\n          <Button\n            onClick={handleGenerateClick}\n            disabled={isLoading || !prompt.trim()}\n            className=\"bg-indigo-600 hover:bg-indigo-700 text-white\"\n          >\n            {isLoading ? \"Generating...\" : \"Generate AI Changes\"}\n          </Button>\n        </div>\n      </div>\n\n      {/* LLM Output and Proposed Changes */}\n      {isLoading && (\n        <div className=\"text-center text-indigo-400 text-xl py-8\">\n          Thinking and generating changes... (Expecting JSON output)\n        </div>\n      )}\n\n      {!isLoading && aiResponseContent && (\n        <div className=\"p-6 bg-gray-800 rounded-lg shadow-xl border border-gray-700 mb-8\">\n          <h2 className=\"text-2xl font-semibold text-indigo-300 mb-4\">\n            AI Proposed Solution\n          </h2>\n          {isLlmOutput(aiResponseContent) ? (\n            <>\n              <p className=\"text-lg text-gray-200 mb-4\">\n                <span className=\"font-bold\">Summary:</span> {aiResponseContent.summary}\n              </p>\n              {aiResponseContent.thoughtProcess && (\n                <div className=\"mb-4\">\n                  <h3 className=\"text-xl font-medium text-gray-300 mb-2\">\n                    Thought Process:\n                  </h3>\n                  <pre className=\"bg-gray-900 p-3 rounded-md whitespace-pre-wrap text-gray-400 leading-relaxed\">\n                    {aiResponseContent.thoughtProcess}\n                  </pre>\n                </div>\n              )}\n\n              <h3 className=\"text-xl font-medium text-gray-300 mb-4 mt-6\">\n                Review & Apply Changes ({acceptedCount} accepted)\n              </h3>\n              {proposedChanges.length > 0 ? (\n                <div className=\"space-y-4\">\n                  {proposedChanges.map((change) => (\n                    <FileChangeDisplay\n                      key={change.filePath} // Assuming filePath is unique and now relative\n                      change={change}\n                      onStatusChange={handleStatusChange}\n                    />\n                  ))}\n                </div>\n              ) : (\n                <p className=\"text-gray-400 italic\">\n                  No changes proposed by the AI for this request.\n                </p>\n              )}\n\n              {proposedChanges.length > 0 && (\n                <div className=\"mt-6 flex justify-end\">\n                  <Button\n                    onClick={handleApplyChanges}\n                    disabled={acceptedCount === 0 || isLoading} // Disable during application too\n                    className=\"bg-green-600 hover:bg-green-700 text-white\"\n                  >\n                    {isLoading\n                      ? \"Applying...\"\n                      : `Apply ${acceptedCount} Selected Changes`}\n                  </Button>\n                </div>\n              )}\n            </>\n          ) : (\n            <>\n              <h3 className=\"text-xl font-medium text-gray-300 mb-2\">\n                AI Response (Raw Text):\n              </h3>\n              <pre className=\"bg-gray-900 p-3 rounded-md overflow-auto text-xs text-gray-200 whitespace-pre-wrap\">\n                <code>{aiResponseContent}</code>\n              </pre>\n              <p className=\"text-gray-400 italic mt-2\">\n                The AI did not return a response in the expected structured JSON format for file changes.\n                Ensure your prompt explicitly asks for JSON matching the LLMOutput interface.\n              </p>\n            </>\n          )}\n        </div>\n      )}\n\n      {/* Go Back Home */}\n      <div className=\"mt-8 text-center\">\n        <Link\n          to=\"/\"\n          className=\"inline-flex items-center px-6 py-3 bg-gray-700 text-white font-semibold rounded-lg shadow-md hover:bg-gray-600 transition-colors\"\n        >\n          Go Back Home\n        </Link>\n      </div>\n    </div>\n  );\n}\n\n\n// File: apps/ai-editor-front/src/pages/AiEditorPage.tsx\nimport { useState, useCallback } from \"react\";\nimport { Link } from \"react-router-dom\";\nimport { Button } from \"../components/Button\";\nimport { INSTRUCTION, ADDIONAL_INSTRUCTION_EXPECTED_OUTPUT } from \"../constants\"; // Import constants\nimport { extractJsonFromMarkdown, repairJsonBadEscapes, joinPaths } from \"../utils\"; // Import utility functions including joinPaths\nimport type {\n  FrontendProposedFileChange,\n  LLMOutput,\n} from \"../types\";\n\n// Backend DTO type for generate-text matching ../../full-stack/src/google/google-gemini/google-gemini-file/dto/generate-text.dto.ts\ninterface GenerateTextDto {\n  prompt: string;\n  systemInstruction?: string;\n  conversationId?: string;\n  // NEW: Add an optional field for directories to scan\n  scanDirectories?: string[];\n}\n\n// Define a type for the AI response that can be either structured LLMOutput or raw text\ntype AiResponseContent = LLMOutput | string | null;\n\n// Component for displaying a single proposed file change\ninterface FileChangeDisplayProps {\n  change: FrontendProposedFileChange;\n  onStatusChange: (\n    filePath: string,\n    status: \"pending\" | \"accepted\" | \"rejected\",\n  ) => void;\n}\n\nfunction FileChangeDisplay({ change, onStatusChange }: FileChangeDisplayProps) {\n  const {\n    filePath,\n    action,\n    newContent,\n    reason,\n    status,\n  } = change;\n\n  const statusClasses = {\n    pending: \"border-blue-400 text-blue-200\",\n    accepted: \"border-green-400 text-green-200\",\n    rejected: \"border-red-400 text-red-200\",\n  };\n\n  return (\n    <div\n      className={`p-4 mb-4 rounded-lg border ${statusClasses[status]} shadow-lg bg-gray-800`}\n    >\n      <div className=\"flex justify-between items-center mb-2 flex-wrap\">\n        <h3 className=\"text-xl font-semibold flex-grow min-w-0\">\n          <span className=\"font-mono text-indigo-300 break-all\">\n            {filePath}\n          </span>\n          <span\n            className={`ml-3 px-2 py-1 rounded-full text-xs font-bold ${\n              action === \"add\"\n                ? \"bg-green-600\"\n                : action === \"modify\"\n                  ? \"bg-yellow-600\"\n                  : \"bg-red-600\"\n            }`}\n          >\n            {action.toUpperCase()}\n          </span>\n        </h3>\n        <div className=\"flex space-x-2 mt-2 md:mt-0 flex-shrink-0\">\n          <Button\n            className={`text-sm px-3 py-1 ${status === \"accepted\" ? \"bg-green-700\" : \"bg-gray-700 hover:bg-green-600\"}`}\n            onClick={() => onStatusChange(filePath, \"accepted\")}\n            disabled={status === \"accepted\"}\n          >\n            Accept\n          </Button>\n          <Button\n            className={`text-sm px-3 py-1 ${status === \"rejected\" ? \"bg-red-700\" : \"bg-gray-700 hover:bg-red-600\"}`}\n            onClick={() => onStatusChange(filePath, \"rejected\")}\n            disabled={status === \"rejected\"}\n          >\n            Reject\n          </Button>\n          <Button\n            className={`text-sm px-3 py-1 ${status === \"pending\" ? \"bg-blue-700\" : \"bg-gray-700 hover:bg-blue-600\"}`}\n            onClick={() => onStatusChange(filePath, \"pending\")}\n            disabled={status === \"pending\"}\n          >\n            Reset\n          </Button>\n        </div>\n      </div>\n      {reason && <p className=\"text-sm text-gray-400 mb-2\">Reason: {reason}</p>}\n\n      {action === \"add\" && newContent && (\n        <div>\n          <h4 className=\"font-medium text-gray-300 mb-1\">New Content:</h4>\n          <pre className=\"bg-gray-900 p-3 rounded-md overflow-auto text-xs text-gray-200\">\n            <code>{newContent}</code>\n          </pre>\n        </div>\n      )}\n\n      {action === \"modify\" && (\n        <div className=\"flex flex-col md:flex-row gap-4\">\n          <div className=\"flex-1\">\n            {/* Original content cannot be displayed dynamically if not provided by the AI response */}\n            <h4 className=\"font-medium text-gray-300 mb-1\">\n              Original Content: (Not available from AI response)\n            </h4>\n            <pre className=\"bg-gray-900 p-3 rounded-md overflow-auto text-xs text-gray-200\">\n              <code>{/* Placeholder or fetch from backend if available */}\n              </code>\n            </pre>\n          </div>\n          <div className=\"flex-1\">\n            <h4 className=\"font-medium text-gray-300 mb-1\">New Content:</h4>\n            <pre className=\"bg-gray-900 p-3 rounded-md overflow-auto text-xs text-gray-200\">\n              <code>{newContent}</code>\n            </pre>\n          </div>\n        </div>\n      )}\n\n      {action === \"delete\" && (\n        <p className=\"text-red-300 italic\">This file will be deleted.</p>\n      )}\n    </div>\n  );\n}\n\nexport function AiEditorPage() {\n  const [prompt, setPrompt] = useState<string>(\n    // Initial user-facing prompt. The full instruction and output format will be combined later.\n    \"Generate TypeScript code to implement a simple React component that displays a welcome message. The component should be named WelcomeMessage.tsx and export a functional component.\",\n  );\n  // NEW: State for directories to scan\n  const [scanDirectories, setScanDirectories] = useState<string>(\n    \"apps/ai-editor-front/src\", // Default to the app's src directory\n  );\n  const [isLoading, setIsLoading] = useState(false);\n  const [aiResponseContent, setAiResponseContent] = useState<AiResponseContent>(null);\n  const [proposedChanges, setProposedChanges] = useState<FrontendProposedFileChange[]>(\n    [],\n  );\n\n  const handleGenerateClick = useCallback(async () => {\n    if (!prompt.trim()) {\n      alert(\"Please enter a prompt.\");\n      return;\n    }\n\n    setIsLoading(true);\n    setAiResponseContent(null);\n    setProposedChanges([]);\n\n    // NEW: Prepare scan directories\n    const directoriesToScan = scanDirectories\n      .split(\",\")\n      .map((dir) => dir.trim())\n      .filter((dir) => dir !== \"\");\n\n    try {\n      const generateTextDto: GenerateTextDto = {\n        prompt: `# User Request:\\n${prompt.trim()}`,\n        systemInstruction: `${INSTRUCTION}\\n\\n${ADDIONAL_INSTRUCTION_EXPECTED_OUTPUT}`,\n        // NEW: Include scanDirectories in the payload\n        scanDirectories: directoriesToScan.length > 0 ? directoriesToScan : undefined,\n      };\n\n      // Call the backend's generate-text endpoint\n      const response = await fetch(\"/api/gemini/file/generate-text\", {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify(generateTextDto),\n      });\n\n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(\n          errorData.message || `HTTP error! status: ${response.status}`,\n        );\n      }\n\n      const aiRawResponseText: string = await response.text(); // Renamed for clarity\n      console.log(\"Raw AI response:\", aiRawResponseText);\n\n      try {\n        // 1. Extract potential JSON from markdown block\n        const extractedJsonString = extractJsonFromMarkdown(aiRawResponseText);\n        console.log(\"Extracted JSON string:\", extractedJsonString);\n\n        // 2. Attempt to repair common bad escape sequences\n        const repairedJsonString = repairJsonBadEscapes(extractedJsonString);\n        console.log(\"Repaired JSON string:\", repairedJsonString);\n\n        let parsedResponse: LLMOutput;\n        try {\n          // Attempt to parse the repaired string as LLMOutput JSON\n          parsedResponse = JSON.parse(repairedJsonString);\n        } catch (parseError) {\n          // If parsing fails after repair, log and set as raw text\n          console.error(\"Failed to parse repaired AI response as JSON:\", parseError);\n          setAiResponseContent(aiRawResponseText); // Fallback to original raw text\n          return; // Exit early if parsing failed\n        }\n\n        // Basic validation to check if it looks like an LLMOutput\n        if (\n          parsedResponse &&\n          Array.isArray(parsedResponse.changes) &&\n          typeof parsedResponse.summary === \"string\"\n        ) {\n          setAiResponseContent(parsedResponse);\n          // Initialize proposed changes with 'pending' status\n          const initialChanges: FrontendProposedFileChange[] = parsedResponse.changes.map((change) => ({\n            ...change,\n            status: \"pending\",\n          }));\n          setProposedChanges(initialChanges);\n        } else {\n          // If parsing succeeded but didn't match LLMOutput structure\n          setAiResponseContent(\n            \"AI response was structured but not in the expected file change format.\\n\" + aiRawResponseText,\n          );\n        }\n      } catch (error) {\n        // Catch any errors from extraction or repair functions, or initial response processing\n        console.error(\"Error processing AI response (extraction/repair stage):\");\n        setAiResponseContent(aiRawResponseText); // Always fall back to raw text on any processing error\n      }\n    } catch (error) {\n      console.error(\"Error generating AI response:\", error);\n      alert(`Failed to generate response: ${(error as Error).message}`);\n    } finally {\n      setIsLoading(false);\n    }\n  }, [prompt, scanDirectories]); // Add scanDirectories to dependency array\n\n  const handleStatusChange = useCallback(\n    (filePath: string, status: \"pending\" | \"accepted\" | \"rejected\") => {\n      setProposedChanges((prevChanges) =>\n        prevChanges.map((change) =>\n          change.filePath === filePath ? { ...change, status } : change,\n        ),\n      );\n    },\n    [],\n  );\n\n  const handleApplyChanges = useCallback(async () => {\n    const acceptedChanges = proposedChanges.filter(\n      (change) => change.status === \"accepted\",\n    );\n    if (acceptedChanges.length === 0) {\n      alert(\"No changes accepted to apply.\");\n      return;\n    }\n\n    setIsLoading(true); // Indicate that changes are being applied\n\n    const projectRoot = import.meta.env.PROJECT_ROOT; // Get the project root from Vite's environment variables\n\n    // *** FIX: Robustness check for PROJECT_ROOT ***\n    if (!projectRoot || typeof projectRoot !== 'string' || projectRoot.trim() === '') {\n      alert(\n        \"Error: PROJECT_ROOT environment variable is not set or is empty. \" +\n        \"Please ensure your Vite configuration or .env file properly defines VITE_PROJECT_ROOT.\"\n      );\n      setIsLoading(false);\n      return; // Abort the operation\n    }\n\n    const operations: Promise<Response>[] = [];\n    const successfulChanges: string[] = [];\n    const failedChanges: { filePath: string; error: string }[] = [];\n\n    for (const change of acceptedChanges) {\n      let finalFilePath = change.filePath;\n\n      // Check if the filePath is already an absolute path (starts with / or Windows drive letter)\n      const isAbsolutePath = finalFilePath.startsWith('/') || /^[a-zA-Z]:[\\\\/]/.test(finalFilePath);\n\n      if (!isAbsolutePath) {\n        // Prepend projectRoot only if it's a relative path\n        finalFilePath = joinPaths(projectRoot, finalFilePath);\n      } else if (!finalFilePath.startsWith(projectRoot)) {\n        // If it's an absolute path but doesn't start with projectRoot, warn the user.\n        // This implies the AI might have proposed a path outside the project, which could be problematic.\n        console.warn(\n          `AI proposed an absolute path '${finalFilePath}' that does not start with the configured PROJECT_ROOT '${projectRoot}'. ` +\n          `Attempting to use this path as-is, but verify it's intended.`\n        );\n      }\n\n      let apiCall: Promise<Response>;\n      switch (change.action) {\n        case \"add\":\n          apiCall = fetch(\"/api/file/create\", {\n            method: \"POST\",\n            headers: { \"Content-Type\": \"application/json\" },\n            body: JSON.stringify({\n              filePath: finalFilePath,\n              isDirectory: false,\n              content: change.newContent || \"\", // Provide empty string if content is undefined\n            }),\n          });\n          break;\n        case \"modify\":\n          apiCall = fetch(\"/api/file/write\", {\n            method: \"POST\",\n            headers: { \"Content-Type\": \"application/json\" },\n            body: JSON.stringify({\n              filePath: finalFilePath,\n              content: change.newContent || \"\", // Provide empty string if content is undefined\n            }),\n          });\n          break;\n        case \"delete\":\n          apiCall = fetch(\"/api/file/delete\", {\n            method: \"POST\",\n            headers: { \"Content-Type\": \"application/json\" },\n            body: JSON.stringify({ filePath: finalFilePath }),\n          });\n          break;\n        default:\n          console.warn(`Unknown action type: ${change.action} for ${change.filePath}. Skipping.`);\n          continue; // Skip unknown actions\n      }\n\n      operations.push(apiCall.then(async (response) => {\n        if (!response.ok) {\n          const errorData = await response.json();\n          throw new Error(errorData.message || `HTTP error! status: ${response.status}`);\n        }\n        successfulChanges.push(change.filePath); // Track successful changes\n        return response;\n      }).catch(error => {\n        failedChanges.push({ filePath: change.filePath, error: error.message }); // Track failed changes\n        console.error(`Failed to apply change for ${change.filePath}:`, error);\n        // Do NOT re-throw here, as Promise.all should resolve even if some fail\n        // We're handling individual errors and collecting them.\n      }));\n    }\n\n    try {\n      await Promise.all(operations); // Wait for all promises to settle (even if some caught errors)\n\n      if (failedChanges.length === 0) {\n        alert(`Successfully applied ${successfulChanges.length} changes.`);\n      } else {\n        alert(\n          `Applied ${successfulChanges.length} changes, but ${failedChanges.length} failed.\\n` +\n          `Failed files:\\n${failedChanges.map(f => `  - ${f.filePath}: ${f.error}`).join('\\n')}`\n        );\n      }\n\n      // Reset state after attempting all applications\n      setAiResponseContent(null);\n      setProposedChanges([]);\n      setPrompt(\"\");\n\n    } catch (error) {\n      // This catch block would only be hit if one of the promises in 'operations'\n      // did not have its error caught and re-threw it, causing Promise.all to reject.\n      // With the individual .catch blocks, this specific catch might be less frequently hit,\n      // but it's good to keep for robustness.\n      console.error(\"An unexpected error occurred during application of changes:\", error);\n      alert(`An unexpected error occurred: ${(error as Error).message}`);\n    } finally {\n      setIsLoading(false);\n    }\n  }, [proposedChanges]);\n\n  const acceptedCount = proposedChanges.filter(\n    (c) => c.status === \"accepted\",\n  ).length;\n\n  const isLlmOutput = (content: AiResponseContent): content is LLMOutput => {\n    return (\n      content !== null &&\n      typeof content === \"object\" &&\n      \"changes\" in content &&\n      Array.isArray(content.changes) &&\n      \"summary\" in content &&\n      typeof content.summary === \"string\"\n    );\n  };\n\n  return (\n    <div className=\"flex flex-col flex-grow p-4 md:p-8 max-w-full lg:max-w-7xl mx-auto w-full\">\n      <h1 className=\"text-4xl font-bold text-white mb-6 text-center\">\n        AI Editor <span className=\"text-indigo-400\">Frontend</span>\n      </h1>\n\n      {/* Directory Scanning Input Section */}\n      <div className=\"p-6 bg-gray-800 rounded-lg shadow-xl border border-gray-700 mb-8\">\n        <h2 className=\"text-2xl font-semibold text-indigo-300 mb-4\">\n          Directories to Scan (for AI Context)\n        </h2>\n        <textarea\n          className=\"w-full p-3 rounded-md bg-gray-900 text-gray-100 border border-gray-700 focus:ring-2 focus:ring-indigo-500 focus:border-transparent outline-none\"\n          rows={3}\n          placeholder=\"Enter comma-separated paths to directories (e.g., src/components, src/utils)\"\n          value={scanDirectories}\n          onChange={(e) => setScanDirectories(e.target.value)}\n          disabled={isLoading}\n        ></textarea>\n        <p className=\"text-sm text-gray-400 mt-2\">\n          These directories will be scanned to provide context to the AI (e.g., file contents, project structure). Paths should be relative to the project root.\n        </p>\n      </div>\n\n      {/* Prompt Input Section */}\n      <div className=\"p-6 bg-gray-800 rounded-lg shadow-xl border border-gray-700 mb-8\">\n        <h2 className=\"text-2xl font-semibold text-indigo-300 mb-4\">\n          Your Request\n        </h2>\n        <textarea\n          className=\"w-full p-3 rounded-md bg-gray-900 text-gray-100 border border-gray-700 focus:ring-2 focus:ring-indigo-500 focus:border-transparent outline-none\"\n          rows={5}\n          placeholder=\"Describe the changes you want the AI to make (e.g., 'Add a new user authentication module', 'Refactor the data fetching logic in App.tsx to use React Query').\"\n          value={prompt}\n          onChange={(e) => setPrompt(e.target.value)}\n          disabled={isLoading}\n        ></textarea>\n        <div className=\"mt-4 flex justify-end\">\n          <Button\n            onClick={handleGenerateClick}\n            disabled={isLoading || !prompt.trim()}\n            className=\"bg-indigo-600 hover:bg-indigo-700 text-white\"\n          >\n            {isLoading ? \"Generating...\" : \"Generate AI Changes\"}\n          </Button>\n        </div>\n      </div>\n\n      {/* LLM Output and Proposed Changes */}\n      {isLoading && (\n        <div className=\"text-center text-indigo-400 text-xl py-8\">\n          Thinking and generating changes... (Expecting JSON output)\n        </div>\n      )}\n\n      {!isLoading && aiResponseContent && (\n        <div className=\"p-6 bg-gray-800 rounded-lg shadow-xl border border-gray-700 mb-8\">\n          <h2 className=\"text-2xl font-semibold text-indigo-300 mb-4\">\n            AI Proposed Solution\n          </h2>\n          {isLlmOutput(aiResponseContent) ? (\n            <>\n              <p className=\"text-lg text-gray-200 mb-4\">\n                <span className=\"font-bold\">Summary:</span> {aiResponseContent.summary}\n              </p>\n              {aiResponseContent.thoughtProcess && (\n                <div className=\"mb-4\">\n                  <h3 className=\"text-xl font-medium text-gray-300 mb-2\">\n                    Thought Process:\n                  </h3>\n                  <pre className=\"bg-gray-900 p-3 rounded-md whitespace-pre-wrap text-gray-400 leading-relaxed\">\n                    {aiResponseContent.thoughtProcess}\n                  </pre>\n                </div>\n              )}\n\n              <h3 className=\"text-xl font-medium text-gray-300 mb-4 mt-6\">\n                Review & Apply Changes ({acceptedCount} accepted)\n              </h3>\n              {proposedChanges.length > 0 ? (\n                <div className=\"space-y-4\">\n                  {proposedChanges.map((change) => (\n                    <FileChangeDisplay\n                      key={change.filePath} // Assuming filePath is unique and now relative\n                      change={change}\n                      onStatusChange={handleStatusChange}\n                    />\n                  ))}\n                </div>\n              ) : (\n                <p className=\"text-gray-400 italic\">\n                  No changes proposed by the AI for this request.\n                </p>\n              )}\n\n              {proposedChanges.length > 0 && (\n                <div className=\"mt-6 flex justify-end\">\n                  <Button\n                    onClick={handleApplyChanges}\n                    disabled={acceptedCount === 0 || isLoading} // Disable during application too\n                    className=\"bg-green-600 hover:bg-green-700 text-white\"\n                  >\n                    {isLoading\n                      ? \"Applying...\"\n                      : `Apply ${acceptedCount} Selected Changes`}\n                  </Button>\n                </div>\n              )}\n            </>\n          ) : (\n            <>\n              <h3 className=\"text-xl font-medium text-gray-300 mb-2\">\n                AI Response (Raw Text):\n              </h3>\n              <pre className=\"bg-gray-900 p-3 rounded-md overflow-auto text-xs text-gray-200 whitespace-pre-wrap\">\n                <code>{aiResponseContent}</code>\n              </pre>\n              <p className=\"text-gray-400 italic mt-2\">\n                The AI did not return a response in the expected structured JSON format for file changes.\n                Ensure your prompt explicitly asks for JSON matching the LLMOutput interface.\n              </p>\n            </>\n          )}\n        </div>\n      )}\n\n      {/* Go Back Home */}\n      <div className=\"mt-8 text-center\">\n        <Link\n          to=\"/\"\n          className=\"inline-flex items-center px-6 py-3 bg-gray-700 text-white font-semibold rounded-lg shadow-md hover:bg-gray-600 transition-colors\"\n        >\n          Go Back Home\n        </Link>\n      </div>\n    </div>\n  );\n}\n\n// File: apps/ai-editor-front/src/pages/AuthPage.tsx\nimport { useEffect, useState } from \"react\";\nimport { useNavigate, useLocation, Link } from \"react-router-dom\";\nimport { useAuth } from \"../hooks/useAuth\";\nimport { Button } from \"../components/Button\";\nimport { redirectToGoogleAuth, redirectToGitHubAuth } from \"../api/auth\";\n\nexport function AuthPage() {\n  // FIX: Add 'user' to the destructured properties from useAuth()\n  const { login, isAuthenticated, isLoading, checkAuthStatus, user } =\n    useAuth();\n  const navigate = useNavigate();\n  const location = useLocation();\n  const [message, setMessage] = useState(\"\");\n  const [error, setError] = useState(\"\");\n\n  useEffect(() => {\n    const params = new URLSearchParams(location.search);\n    const action = params.get(\"action\");\n    const accessToken = params.get(\"accessToken\");\n    const userId = params.get(\"userId\");\n    const userEmail = params.get(\"userEmail\");\n    const userName = params.get(\"userName\");\n    const userImage = params.get(\"userImage\");\n    const userRole = params.get(\"userRole\");\n    const username = params.get(\"username\"); // For GitHub username\n    const errorMessage = params.get(\"error\");\n\n    if (errorMessage) {\n      setError(decodeURIComponent(errorMessage));\n    }\n\n    if (action === \"success\" && accessToken && userId && userEmail) {\n      // The backend sets an HTTP-only cookie, so we primarily rely on\n      // the `/api/auth/me` endpoint to verify the session.\n      // We'll call checkAuthStatus to re-fetch the user details from the backend\n      // which will then update the AuthContext.\n      setMessage(\"Login successful! Redirecting...\");\n      // Delay checkAuthStatus slightly to allow browser to process cookie\n      setTimeout(() => {\n        checkAuthStatus();\n      }, 100); // Small delay\n    } else if (isAuthenticated && !isLoading) {\n      // Already authenticated and not loading, redirect to editor\n      navigate(\"/editor\", { replace: true });\n    } else if (!action && !accessToken && !isLoading) {\n      // No special action, not authenticated, not loading\n      setMessage(\"Please log in to continue.\");\n    }\n  }, [\n    location.search,\n    isAuthenticated,\n    isLoading,\n    navigate,\n    login,\n    checkAuthStatus,\n  ]);\n\n  useEffect(() => {\n    if (isAuthenticated && !isLoading) {\n      // Once authentication status is confirmed and user is logged in,\n      // redirect to the editor page\n      navigate(\"/editor\", { replace: true });\n    }\n  }, [isAuthenticated, isLoading, navigate]);\n\n  if (isLoading) {\n    return (\n      <div className=\"flex flex-col items-center justify-center min-h-screen text-white text-xl\">\n        <p>Loading authentication status...</p>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"flex flex-col items-center justify-center p-8 text-center max-w-xl mx-auto bg-gray-800 rounded-lg shadow-xl border border-gray-700\">\n      <h1 className=\"text-4xl font-bold text-white mb-6\">\n        {isAuthenticated ? \"Welcome Back!\" : \"Log In to AI Editor\"}\n      </h1>\n\n      {error && <p className=\"text-red-400 mb-4 text-lg\">Error: {error}</p>}\n\n      {message && <p className=\"text-indigo-300 mb-6 text-lg\">{message}</p>}\n\n      {!isAuthenticated && (\n        <div className=\"flex flex-col space-y-4 w-full max-w-sm\">\n          <Button\n            onClick={redirectToGoogleAuth}\n            className=\"w-full bg-blue-600 hover:bg-blue-700 text-white py-3 text-lg font-semibold\"\n          >\n            Login with Google\n          </Button>\n          <Button\n            onClick={redirectToGitHubAuth}\n            className=\"w-full bg-gray-600 hover:bg-gray-700 text-white py-3 text-lg font-semibold\"\n          >\n            Login with GitHub\n          </Button>\n          {/* Optionally, add local login/registration forms here */}\n          <p className=\"text-gray-400 mt-4\">\n            Or{\" \"}\n            <Link to=\"#\" className=\"text-indigo-400 hover:underline\">\n              register with email\n            </Link>\n          </p>\n        </div>\n      )}\n\n      {isAuthenticated && (\n        <div className=\"mt-8\">\n          <p className=\"text-lg text-gray-200 mb-4\">\n            You are logged in as{\" \"}\n            <span className=\"font-semibold text-indigo-300\">\n              {user?.name || user?.email || \"User\"}\n            </span>\n            .\n          </p>\n          <Link\n            to=\"/editor\"\n            className=\"px-6 py-3 bg-indigo-600 text-white font-semibold rounded-lg shadow-md hover:bg-indigo-700 transition-colors\"\n          >\n            Go to Editor\n          </Link>\n        </div>\n      )}\n    </div>\n  );\n}\n\n\n// File: apps/ai-editor-front/src/pages/LandingPage.tsx\nimport { Link } from \"react-router-dom\";\n\nexport function LandingPage() {\n  return (\n    <div className=\"flex flex-col items-center justify-center text-center max-w-4xl mx-auto p-4\">\n      <h1 className=\"text-6xl font-extrabold text-white mb-6 leading-tight\">\n        Unleash Your Creativity with{\" \"}\n        <span className=\"text-indigo-400\">AI-Powered Editing</span>\n      </h1>\n      <p className=\"text-xl text-gray-300 mb-8 max-w-2xl\">\n        Revolutionize your content creation with intelligent tools that assist,\n        enhance, and inspire. From text generation to image manipulation, your\n        creative process just got a powerful upgrade.\n      </p>\n      <div className=\"flex flex-col sm:flex-row gap-4\">\n        <Link\n          to=\"/editor\"\n          className=\"px-8 py-4 bg-indigo-600 text-white text-lg font-semibold rounded-lg shadow-lg hover:bg-indigo-700 transition-all duration-300 transform hover:scale-105\"\n        >\n          Start Editing Now\n        </Link>\n        <a\n          href=\"#\"\n          className=\"px-8 py-4 border border-indigo-500 text-indigo-300 text-lg font-semibold rounded-lg shadow-lg hover:bg-indigo-900 hover:border-indigo-400 transition-all duration-300 transform hover:scale-105\"\n        >\n          Learn More\n        </a>\n      </div>\n\n      <div className=\"mt-16 grid grid-cols-1 md:grid-cols-3 gap-8 w-full\">\n        <div className=\"bg-gray-800 p-6 rounded-lg shadow-xl border border-gray-700\">\n          <h3 className=\"text-2xl font-bold text-indigo-300 mb-3\">\n            Smart Text Assistance\n          </h3>\n          <p className=\"text-gray-400\">\n            Generate, rephrase, and perfect your writing with AI suggestions.\n          </p>\n        </div>\n        <div className=\"bg-gray-800 p-6 rounded-lg shadow-xl border border-gray-700\">\n          <h3 className=\"text-2xl font-bold text-indigo-300 mb-3\">\n            Intelligent Image Tools\n          </h3>\n          <p className=\"text-gray-400\">\n            Enhance, transform, and create stunning visuals effortlessly.\n          </p>\n        </div>\n        <div className=\"bg-gray-800 p-6 rounded-lg shadow-xl border border-gray-700\">\n          <h3 className=\"text-2xl font-bold text-indigo-300 mb-3\">\n            Streamlined Workflow\n          </h3>\n          <p className=\"text-gray-400\">\n            Boost your productivity with an intuitive and efficient interface.\n          </p>\n        </div>\n      </div>\n    </div>\n  );\n}\n\n\n// File: apps/ai-editor-front/src/routes/index.tsx\nimport { Routes, Route, Link, Outlet, Navigate } from \"react-router-dom\";\nimport { LandingPage } from \"../pages/LandingPage\";\nimport  { AiEditorPage }  from \"../pages/AiEditorPage\";\nimport { AuthPage } from \"../pages/AuthPage\"; // New: Import AuthPage\nimport { Layout } from \"../components/Layout\";\nimport { useAuth } from \"../hooks/useAuth\"; // New: Import useAuth\n\n// New: ProtectedRoute component\nfunction ProtectedRoute() {\n  const { isAuthenticated, isLoading } = useAuth();\n\n  if (isLoading) {\n    // Optionally show a loading spinner or null while checking auth status\n    return (\n      <div className=\"flex flex-col items-center justify-center h-full text-white text-xl\">\n        <p>Checking authentication...</p>\n      </div>\n    );\n  }\n\n  return isAuthenticated ? <Outlet /> : <Navigate to=\"/login\" replace />;\n}\n\nexport function AppRoutes() {\n  return (\n    <Layout>\n      <Routes>\n        <Route path=\"/\" element={<LandingPage />} />\n        <Route path=\"/login\" element={<AuthPage />} />{\" \"}\n        {/* New: AuthPage route */}\n        {/* Protected Route for AiEditorPage */}\n        <Route element={<ProtectedRoute />}>\n          <Route path=\"/editor\" element={<AiEditorPage />} />\n        </Route>\n        {/* Add more routes here as needed */}\n        <Route path=\"*\" element={<NoMatch />} />\n      </Routes>\n    </Layout>\n  );\n}\n\nfunction NoMatch() {\n  return (\n    <div className=\"text-center p-8\">\n      <h2 className=\"text-4xl font-bold text-red-400 mb-4\">\n        Oops! Nothing to see here.\n      </h2>\n      <p className=\"text-lg text-gray-300 mb-8\">\n        The page you are looking for does not exist.\n      </p>\n      <Link\n        to=\"/\"\n        className=\"px-6 py-3 bg-indigo-600 text-white font-semibold rounded-lg shadow-md hover:bg-indigo-700 transition-colors\"\n      >\n        Go to Home\n      </Link>\n    </div>\n  );\n}\n\n\n// File: apps/ai-editor-front/src/stores/aiEditorStore.ts\nimport { map } from \"nanostores\";\n\nexport interface AiEditorStoreType {\n  prompt: string;\n  systemInstruction: string;\n  response: {\n    newContent: string;\n    currentContent: string;\n    type: \"insert\" | \"replace\" | \"delete\";\n  } | null;\n  isLoading: boolean;\n  lastAppliedContent: string; // Added to simulate content application\n}\n\nexport const aiEditorStore = map<AiEditorStoreType>({\n  prompt: \"Refactor this code to be more concise.\",\n  systemInstruction:\n    \"You are an expert TypeScript/React developer. Provide concise and clean code.\",\n  response: null,\n  isLoading: false,\n  lastAppliedContent: \"\",\n});\n\nexport const generateResponse = async (\n  prompt: string,\n  systemInstruction: string,\n) => {\n  aiEditorStore.setKey(\"isLoading\", true);\n  aiEditorStore.setKey(\"prompt\", prompt);\n  aiEditorStore.setKey(\"systemInstruction\", systemInstruction);\n\n  // Simulate an API call\n  await new Promise((resolve) => setTimeout(resolve, 1500));\n\n  const mockResponseContent = `// Refactored code based on your prompt:\\nimport React from 'react';\\n\\ninterface Props {\\n  count: number;\\n}\\n\\nconst Counter: React.FC<Props> = ({ count }) => (\\n  <div className=\"text-xl font-bold\">Count: {count}</div>\\n);\\n\\nexport default Counter;\\n\\n// Added system instruction for context: \"${systemInstruction}\"`;\n\n  aiEditorStore.setKey(\"response\", {\n    newContent: mockResponseContent,\n    currentContent: `// Original content (for context/diff)\\ninterface Props { count: number; }\\nconst Counter = ({ count }: Props) => {\\n  return (\\n    <div>\\n      <p>Current Count: {count}</p>\\n    </div>\\n  );\\n};\\nexport default Counter;`,\n    type: \"replace\",\n  });\n  aiEditorStore.setKey(\"isLoading\", false);\n};\n\nexport const applyEditedContent = (content: string) => {\n  console.log(\"Applying edited content:\", content);\n  aiEditorStore.setKey(\"lastAppliedContent\", content);\n  // In a real application, this would update the actual file or editor content\n  // and potentially clear the response state if the changes are committed.\n  // For this example, we'll keep the response visible.\n  // aiEditorStore.setKey('response', null);\n};\n\n\n// File: apps/ai-editor-front/src/types/auth.ts\n/**\n * Represents a simplified user object for frontend consumption.\n * This should align with the data returned by the backend's /api/auth/me endpoint.\n */\nexport interface User {\n  id: string;\n  email: string;\n  name?: string;\n  role?: \"USER\" | \"ADMIN\" | \"MANAGER\" | \"SUPERADMIN\"; // Matching NestJS Role enum\n  image?: string;\n  phone_number?: string;\n  username?: string;\n  emailVerified?: Date | null;\n  createdAt?: Date;\n  updatedAt?: Date;\n}\n\n/**\n * Defines the shape of the authentication context.\n */\nexport interface AuthContextType {\n  user: User | null;\n  isAuthenticated: boolean;\n  isLoading: boolean;\n  login: (userData: User) => void;\n  logout: () => Promise<void>;\n  checkAuthStatus: () => Promise<void>;\n}\n\n\n// File: apps/ai-editor-front/src/types/index.ts\nexport interface ScannedFile {\n  filePath: string; // Absolute path to the file\n  relativePath: string; // Path relative to the project root (e.g., \"src/components/MyComponent.tsx\")\n  content: string;\n}\n\n/**\n * Represents a proposed change to a file.\n * This is the structured output we expect from the LLM.\n */\nexport interface ProposedFileChange {\n  filePath: string; // Path relative to the project root (e.g., \"src/components/MyComponent.tsx\")\n  action: \"add\" | \"modify\" | \"delete\";\n  /**\n   * For 'add' or 'modify' actions, this is the new content of the file.\n   * For 'delete' actions, this field is not used.\n   */\n  newContent?: string;\n  /**\n   * An optional human-readable reason or summary for the change.\n   */\n  reason?: string;\n}\n\n/**\n * Represents the structured input that will be sent to the LLM.\n */\nexport interface LLMInput {\n  userPrompt: string;\n  projectRoot: string;\n  projectStructure: string; // A high-level overview of the project directory (e.g., tree string)\n  relevantFiles: ScannedFile[];\n  additionalInstructions: string; // Specific behavioral instructions for the LLM\n  expectedOutputFormat: string; // Instructions on the JSON format for the LLM's response\n}\n\n/**\n * Represents the structured output received from the LLM.\n */\nexport interface LLMOutput {\n  changes: ProposedFileChange[];\n  summary: string; // A concise summary of all changes made/proposed\n  thoughtProcess?: string; // LLM's detailed reasoning for the changes\n}\n\n// Frontend specific types for UI state\nexport interface FrontendProposedFileChange extends ProposedFileChange {\n  status: \"pending\" | \"accepted\" | \"rejected\";\n  // relativePath is no longer needed here as ProposedFileChange.filePath is now relative\n}\n\n\n// File: apps/ai-editor-front/src/utils/index.ts\n// src/llm/jsonRepair.ts\n\n/**\n * Attempts to repair common bad escape sequences in a JSON string\n * that might be returned by an LLM.\n * This function primarily focuses on fixing lone backslashes within string values\n * that cause JSON parsing errors.\n *\n * It is assumed that the LLM, when instructed to return JSON (e.g., with responseMimeType: \"application/json\"),\n * generally handles standard string escapes like `\\n`, `\\t`, `\\\"` correctly.\n * This repair function is a fallback for common minor deviations, mainly malformed backslashes.\n *\n * @param jsonString The potentially malformed JSON string.\n * @returns A repaired JSON string, or the original string if no repairs were made.\n */\nexport function repairJsonBadEscapes(jsonString: string): string {\n  let repaired = jsonString;\n\n  // IMPORTANT: Removed the replacement for unescaped newlines/tabs/carriage returns.\n  // These replacements (e.g., `/(?<!\\\\)\\n/g, '\\\\n'`) were incorrectly converting\n  // structural newlines (used for JSON pretty-printing) into escaped newlines (`\\n` -> `\\\\n`),\n  // which makes the JSON invalid at the structural level.\n  // JSON parsers expect literal newlines/tabs for formatting outside of string literals.\n  // If a newline is inside a string value, the LLM should already be providing `\\\\n`.\n\n  // 1. Escape lone backslashes that are not part of a valid JSON escape sequence.\n  // This regex targets backslashes not followed by another backslash or a standard JSON escape char.\n  // Example: \"C:\\\\path\\\\to\\\\file\" should become \"C:\\\\\\\\path\\\\\\\\to\\\\\\\\file\"\n  // The `(?!...)` is a negative lookahead, ensuring the backslash is not followed by\n  // a valid JSON escape character (\", \\\\, /, b, f, n, r, t, u (for unicode escapes)).\n  // This is the most common and relatively safe repair for paths or other literal backslashes within string values.\n  repaired = repaired.replace(/\\\\(?![\"\\\\/bfnrtu])/g, \"\\\\\\\\\");\n\n  return repaired; // Return the repaired string\n}\n\nexport function extractJsonFromMarkdown(text: string): string {\n  const jsonBlockRegex = /```json\\n([\\s\\S]*?)\\n```/;\n  const match = text.match(jsonBlockRegex);\n  if (match && match[1]) {\n    return match[1].trim();\n  }\n  // If it's not wrapped in a JSON block, assume it's pure JSON and just trim it.\n  return text.trim();\n}\n\n/**\n * Joins base path and relative path, handling leading/trailing slashes correctly.\n * Ensures a clean, normalized path.\n * @param base The base path (e.g., project root).\n * @param relative The path relative to the base (e.g., 'src/component/file.ts').\n * @returns The joined, normalized path.\n */\nexport const joinPaths = (base: string, relative: string): string => {\n  // Normalize base path to not end with a slash unless it's just '/' (root)\n  const normalizedBase =\n    base.endsWith(\"/\") && base.length > 1 ? base.slice(0, -1) : base;\n  // Normalize relative path to not start with a slash\n  const normalizedRelative = relative.startsWith(\"/\")\n    ? relative.slice(1)\n    : relative;\n  return `${normalizedBase}/${normalizedRelative}`;\n};\n\n\n// File: .gitignore\n# Node.js modules\nnode_modules/\n\n# Build files\ndist/\n\n# Logs\n*.log\n\n# Environment variables\n.env\n\n# IDE specific files\n.idea/\n.vscode/\n\n# System files\n.DS_Store\nThumbs.db\n\n\n// File: CONTRIBUTING.md\n# Contributing\n\nContributions are welcome!\n\nTo contribute to this project, please follow these steps:\n\n1.  Fork the repository.\n2.  Create a new branch for your feature or bug fix.\n3.  Make your changes.\n4.  Test your changes thoroughly.\n5.  Submit a pull request.\n\n## Code Style\n\nPlease follow the existing code style in the project.\n\n## Commit Messages\n\nPlease use clear and concise commit messages.\n\n## License\n\nBy contributing to this project, you agree to license your contributions under the ISC License.\n\n// File: LICENSE\nISC License\n\nCopyright (c) 2025 Eddie Villanueva\n\nPermission to use, copy, modify, and/or distribute this software for any purpose with or without fee is hereby granted, provided that the above copyright notice and this permission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n// File: README.md\n# AI Editor\n\nAn AI-powered tool for editing and updating code files, designed as a monorepo containing both a CLI tool and a React-based frontend application.\n\n## Monorepo Structure\n\nThis project is organized as a monorepo:\n\n-   **`/` (Root):** Contains shared configurations, overall documentation, and the core AI-editing CLI tool.\n-   **`apps/ai-editor-front/`:** Houses the React/TypeScript/Tailwind CSS frontend application.\n-   **`docs/`:** Contains detailed documentation and setup guides.\n\n## Features (CLI Tool)\n\n-   Scans specified project directories for relevant code files.\n-   Prepares context for an LLM by structuring the user prompt, relevant files, and system instructions.\n-   Calls the LLM (Google Gemini) to generate proposed changes in a structured JSON format.\n-   Generates human-readable diffs between original and proposed content.\n-   Applies file changes (add, modify, delete) to the file system.\n-   Integrates with Git for automated branch creation and staging changes.\n\n## Getting Started\n\n### Prerequisites\n\n-   Node.js (version >= 18)\n-   npm or yarn\n-   A Google Gemini API key (set as `GOOGLE_GEMINI_API_KEY` environment variable for the CLI tool). See [Setting up Google Gemini API Key](docs/google-gemini-setup.md) for detailed instructions.\n\n### Installation\n\nNavigate to the root of the project and install dependencies:\n\n```bash\nnpm install\n# or yarn install\n```\n\n### Usage\n\n#### AI Editor CLI Tool\n\nRun the CLI tool from the project root:\n\n1.  **Scan files or directories:**\n\n    ```bash\nts-node src/index.ts scan [paths...]\n    ```\n\n    Examples:\n\n    ```bash\nts-node src/index.ts scan .                                 # Scans the current directory\nts-node src/index.ts scan apps/ai-editor-front/src/components # Scans a specific subdirectory\nts-node src/index.ts scan . --verbose                      # Scan with verbose output\nts-node src/index.ts scan src --show-content               # Show content snippets of scanned files\nts-node src/index.ts scan . --verbose --show-content       # Combine verbose and show-content\n    ```\n\n2.  **Generate code based on a prompt:**\n\n    ```bash\nts-node src/index.ts generate \"Your prompt here\"\n    ```\n\n    Examples:\n\n    ```bash\nts-node src/index.ts generate \"Add a user profile component\"                    # Basic generation\nts-node src/index.ts generate \"Implement a dark mode toggle\" --scan-dirs apps/ai-editor-front/src/ui # Target specific path for context\nts-node src/index.ts generate \"Add user authentication flow\" --yes             # Auto-confirm all changes (use with caution!)\nts-node src/index.ts generate \"Refactor old utility functions\" --no-git        # Skip Git operations\nts-node src/index.ts generate \"Create a new Dashboard component\" --branch feature/dashboard-v2 # Specify a new branch\n    ```\n\n##### CLI Options\n\n-   `-p, --path <path>`: (for `generate` command) Specify the project root directory (default: current working directory). This is where Git operations and file resolution will be based.\n-   `--scan-dirs <dirs...>`: (for `generate` command) Space-separated list of directories to scan within the project root (e.g., \"src apps/ai-editor-front/src\").\n-   `--scan-files <files...>`: (for `generate` command) Space-separated list of individual file paths to scan within the project root (e.g., \"src/App.tsx apps/ai-editor-front/src/main.tsx\").\n-   `-y, --yes`: (for `generate` command) Automatically confirm all proposed changes without prompting (USE WITH CAUTION!).\n-   `--no-git`: (for `generate` command) Skip all Git operations (branching, staging).\n-   `--branch <name>`: (for `generate` command) Specify a branch name to create/checkout. If not provided, a default is suggested.\n-   `-v, --verbose`: (for `scan` command) Output detailed information during scan.\n-   `-s, --show-content`: (for `scan` command) Show a snippet of file content for sample files.\n\n#### AI Editor Frontend Application\n\nTo run the interactive web application:\n\n```bash\ncd apps/ai-editor-front\nnpm run dev # or yarn dev\n```\n\nFor more details on the frontend application, refer to its dedicated README: [apps/ai-editor-front/README.md](apps/ai-editor-front/README.md)\n\n## Development\n\n### Running the project (CLI)\n\n```bash\nnpm start # Equivalent to ts-node src/index.ts\n```\n\n### Building the project (CLI)\n\n```bash\nnpm run build\n```\n\n## File Structure (Root)\n\n```\n.\n├── CONTRIBUTING.md\n├── README.md\n├── apps\n│   └── ai-editor-front\n│       └── README.md # Frontend-specific README\n├── docs\n│   ├── developer-guide.md\n│   └── google-gemini-setup.md\n├── eslint.config.ts\n├── package.json\n├── src # Core CLI Tool Source\n│   ├── file-operations\n│   ├── git-operations\n│   ├── index.ts\n│   ├── llm\n│   ├── scanner.ts\n│   └── types.ts\n└── tsconfig.json\n```\n\nFor a more detailed breakdown of the CLI tool's architecture, see the [Developer Guide](docs/developer-guide.md).\n\n## Dependencies\n\n(See `package.json` for full list)\n\n-   `@google/generative-ai`: Google Gemini API client.\n-   `chalk`: For colorful console output.\n-   `commander`: For building command-line interfaces.\n-   `diff`: For generating text diffs.\n-   `dotenv`: For loading environment variables.\n-   `inquirer`: For interactive command-line prompts.\n-   `simple-git`: For Git operations.\n\n## Contributing\n\nWe welcome contributions! Please see [CONTRIBUTING.md](CONTRIBUTING.md) for guidelines.\n\n## License\n\nThis project is licensed under the ISC License. See [LICENSE](LICENSE) for details.\n\n\n// File: eslint.config.ts\nimport globals from 'globals';\nimport pluginJs from '@eslint/js';\nimport tseslint from 'typescript-eslint';\nimport prettierPlugin from 'eslint-plugin-prettier';\nimport prettierConfig from 'eslint-config-prettier';\n\nexport default tseslint.config(\n  // Ignore patterns\n  {\n    ignores: [\n      'node_modules/',\n      'dist/',\n      'coverage/',\n      '*.config.js', // Exclude JS config files if they exist alongside TS config\n      '*.mjs', // Exclude ES module files if any special config needed\n      '*.cjs', // Exclude CommonJS files if any special config needed\n      'package-lock.json',\n    ],\n  },\n  // Global configuration for all files\n  {\n    languageOptions: {\n      ecmaVersion: 'latest',\n      sourceType: 'module',\n      globals: {\n        ...globals.node, // For Node.js environment\n        ...globals.browser, // Although it's a CLI tool, some browser globals might accidentally slip in via deps\n      },\n    },\n    linterOptions: {\n      reportUnusedDisableDirectives: 'error',\n    },\n  },\n  // JavaScript rules (builtin recommended)\n  pluginJs.configs.recommended,\n  // TypeScript rules\n  ...tseslint.configs.recommended, // Uses recommended rules from @typescript-eslint\n  {\n    files: ['**/*.ts', '**/*.tsx'],\n    rules: {\n      // Add or override specific TypeScript rules here\n      '@typescript-eslint/no-unused-vars': [\n        'warn',\n        { argsIgnorePattern: '^_', varsIgnorePattern: '^_' }, // Allow unused args/vars starting with _\n      ],\n      '@typescript-eslint/explicit-module-boundary-types': 'off', // Often too strict for simple functions\n      '@typescript-eslint/no-explicit-any': 'warn', // Warn on any, don't block\n      '@typescript-eslint/array-type': ['error', { default: 'array-simple' }],\n      '@typescript-eslint/consistent-type-definitions': ['error', 'interface'], // Prefer interfaces over types for object literals\n    },\n  },\n  // Prettier integration\n  {\n    plugins: {\n      prettier: prettierPlugin,\n    },\n    rules: {\n      ...prettierConfig.rules,\n      'prettier/prettier': 'error',\n    },\n  },\n);\n\n\n// File: package.json\n{\n  \"name\": \"ai-editor\",\n  \"version\": \"1.0.0\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"start\": \"ts-node src/index.ts\",\n    \"build\": \"tsc\",\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\n    \"lint\": \"eslint .\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"description\": \"\",\n  \"devDependencies\": {\n    \"@types/diff\": \"^7.0.2\",\n    \"ts-node\": \"^10.9.2\",\n    \"typescript\": \"^5.9.2\",\n    \"eslint\": \"^9.x.x\",\n    \"@eslint/js\": \"^9.x.x\",\n    \"typescript-eslint\": \"^8.x.x\",\n    \"eslint-plugin-prettier\": \"^5.x.x\",\n    \"eslint-config-prettier\": \"^9.x.x\",\n    \"globals\": \"^15.x.x\"\n  },\n  \"dependencies\": {\n    \"@google/generative-ai\": \"^0.24.1\",\n    \"chalk\": \"^4.1.2\",\n    \"commander\": \"^14.0.0\",\n    \"diff\": \"^8.0.2\",\n    \"dotenv\": \"^17.2.1\",\n    \"inquirer\": \"^12.9.1\",\n    \"simple-git\": \"^3.28.0\"\n  }\n}\n\n\n// File: tsconfig.json\n{\n  \"compilerOptions\": {\n    \"target\": \"ESNext\", \n    \"module\": \"CommonJS\",\n    \"lib\": [\"ES2021\"], \n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"moduleResolution\": \"node\"\n  },\n  \"include\": [\"src/**/*.ts\"],\n  \"exclude\": [\"node_modules\", \"dist\"]\n}\n\n\n// File: docs/developer-guide.md\n# Developer Guide\n\nThis guide provides an in-depth overview of the AI Editor project's architecture, core concepts, and module responsibilities, aimed at developers looking to understand and contribute to the CLI tool.\n\n## Project Overview\n\nAI Editor is a command-line tool that uses AI to automate code editing tasks. It scans project files, prepares a context for an LLM, generates proposed changes, and applies those changes to the file system.\n\n## Getting Started\n\nFor basic setup, installation, and usage instructions for both the CLI tool and the frontend application, please refer to the main [README.md](../README.md) in the project root.\n\n### Prerequisites (Specific to CLI Development)\n\n-   Node.js (version >= 18)\n-   npm or yarn\n-   A Google Gemini API key (set as `GOOGLE_GEMINI_API_KEY` environment variable). For detailed setup, refer to [Setting up Google Gemini API Key](google-gemini-setup.md).\n\n## Project Structure (CLI Tool Focus)\n\n```\n.\n├── src # Core CLI Tool Source\n│   ├── file-operations\n│   │   ├── diffGenerator.ts\n│   │   └── fileApplier.ts\n│   ├── git-operations\n│   │   └── gitManager.ts\n│   ├── index.ts\n│   ├── llm\n│   │   ├── contextPreparer.ts\n│   │   └── llmOrchestrator.ts\n│   ├── scanner.ts\n│   └── types.ts\n```\n\nThis section focuses on the `src/` directory, which contains the core logic for the AI Editor CLI.\n\n## Core Concepts\n\n### Scanning\n\nThe scanning process uses the `src/scanner.ts` module to identify and read relevant files within the project directory. The `scanProject` function recursively traverses the directory structure, filtering files based on their extensions and specified exclusions (defined in `RELEVANT_FILE_EXTENSIONS`, `EXCLUDE_DIR_NAMES`, etc.).\n\n### Context Preparation\n\nThe `src/llm/contextPreparer.ts` module prepares the context for the LLM by structuring the user prompt, relevant files, and system instructions. The `prepareContextForLLM` function constructs an `LLMInput` object that includes:\n\n-   The user prompt\n-   A representation of the project file structure\n-   The content of relevant files\n-   Additional instructions for the LLM (specific to the expert role and output format)\n\n### LLM Orchestration\n\nThe `src/llm/llmOrchestrator.ts` module handles the interaction with the Google Gemini API. The `callLLM` function:\n\n-   Builds a prompt using the `LLMInput` object (see `buildLLMPrompt` in `contextPreparer.ts`).\n-   Calls the Gemini API to generate code changes.\n-   Parses and repairs the JSON response from the LLM.\n-   Validates the structure of the LLM output.\n-   Logs raw LLM responses for debugging/auditing.\n\n### File Operations\n\nThe `src/file-operations` directory contains modules for generating diffs and applying file changes. The `diffGenerator.ts` module uses the `diff` library to create human-readable diffs between original and proposed content. The `fileApplier.ts` module applies file changes (add, modify, delete) to the file system, handling directory creation and cleanup.\n\n### Git Integration\n\nThe `src/git-operations` directory includes the `gitManager.ts` module, which provides functions for interacting with Git repositories. The tool can check if a directory is a Git repo, create branches, stage files, and retrieve the current branch name.\n\n## Modules (Detailed)\n\n### `src/file-operations/diffGenerator.ts`\n\nResponsible for generating human-readable diffs between two text contents using `diff` and `chalk` for colored output.\n\n### `src/file-operations/fileApplier.ts`\n\nHandles the application of proposed file changes (add, modify, delete) to the file system. Includes logic for creating parent directories for new files and cleaning up empty directories after deletions.\n\n### `src/git-operations/gitManager.ts`\n\nManages various Git operations, allowing the CLI to interact with the local repository. It leverages the `simple-git` library to create branches, stage files, and check repository status.\n\n### `src/index.ts`\n\nThe main entry point of the CLI application. It uses `commander` to parse command-line arguments and `inquirer` for interactive prompts. It orchestrates the entire workflow: scanning, context preparation, LLM invocation, user review, and application of changes.\n\n### `src/llm/contextPreparer.ts`\n\nPrepares the comprehensive prompt structure (`LLMInput`) that is sent to the LLM. It consolidates the user's request, project file structure, relevant file contents, and detailed instructions for the AI's behavior and expected output format.\n\n### `src/llm/jsonRepair.ts`\n\nProvides utility functions to extract JSON from markdown blocks and repair common JSON escape sequence issues that might arise from LLM outputs, ensuring the response is reliably parsable.\n\n### `src/llm/llmOrchestrator.ts`\n\nManages the direct communication with the Google Gemini API. It sends the constructed prompt, handles the API response, attempts to parse and validate the JSON output, and logs the raw responses for auditing and debugging.\n\n### `src/scanner.ts`\n\nPerforms the recursive file system scanning. It identifies relevant files based on predefined extensions and exclusion lists, reads their content, and returns them as `ScannedFile` objects with both absolute and project-relative paths.\n\n### `src/types.ts`\n\nDefines the core TypeScript interfaces and types used across the CLI tool, including `ScannedFile`, `ProposedFileChange`, `LLMInput`, and `LLMOutput`, ensuring strong type safety and clarity in data structures.\n\n\n// File: docs/google-gemini-setup.md\n# Setting up Google Gemini API Key\n\nThis guide explains how to obtain a Google Gemini API key, which is required to run the AI Editor. By default, the AI Editor uses the `gemini-1.5-pro-latest` model.\n\n## 1. Go to Google AI Studio or Google Cloud Console\n\nYou have two main options to get an API key:\n\n*   **Google AI Studio (Recommended for quick start):** This is the easiest way to get an API key for development and experimenting with generative AI models. Go to [Google AI Studio](https://aistudio.google.com/app/apikey).\n*   **Google Cloud Console:** If you need more control, project management, or intend to use other Google Cloud services, use the [Google Cloud Console](https://console.cloud.google.com/).\n\n### Option A: Using Google AI Studio\n\n1.  Navigate to [Google AI Studio API Key page](https://aistudio.google.com/app/apikey).\n2.  Sign in with your Google account.\n3.  If this is your first time, you might be prompted to create a new project. Follow the on-screen instructions.\n4.  Once on the API Key page, click **\"Get API key in new project\"** or **\"Create API key in existing project\"**.\n5.  A new API key will be generated. Copy this key immediately as you won't be able to see it again.\n\n### Option B: Using Google Cloud Console\n\n1.  Go to the [Google Cloud Console](https://console.cloud.google.com/).\n2.  **Create a new project (if you don't have one):**\n    *   Click on the project selector dropdown at the top.\n    *   Click **\"New Project\"**.\n    *   Give your project a name (e.g., \"AI Editor Project\") and click **\"Create\"**.\n    *   Select your newly created project.\n3.  **Enable the Gemini API:**\n    *   In the search bar at the top, type \"Generative Language API\" and select it.\n    *   Click the **\"Enable\"** button if it's not already enabled.\n4.  **Create an API key:**\n    *   In the Cloud Console, navigate to **\"APIs & Services\" > \"Credentials\"** (or use the search bar to find \"Credentials\").\n    *   Click **\"+ CREATE CREDENTIALS\"** at the top and select **\"API key\"**.\n    *   A new API key will be generated and displayed. Copy this key immediately.\n    *   **Important:** Restrict your API key for security best practices. You can restrict it by API (Generative Language API) and by IP address or HTTP referrer if this is for a specific server-side application. For local development, this might not be strictly necessary but is good practice.\n\n## 2. Set the API Key as an Environment Variable\n\nThe AI Editor tool expects your Google Gemini API key to be available as an environment variable named `GOOGLE_GEMINI_API_KEY`.\n\n### On macOS/Linux:\n\nAdd the following line to your `~/.bashrc`, `~/.zshrc`, or `~/.profile` file:\n\n```bash\nexport GOOGLE_GEMINI_API_KEY=\"YOUR_API_KEY_HERE\"\n```\n\nReplace `\"YOUR_API_KEY_HERE\"` with the actual API key you obtained. After saving the file, apply the changes by running:\n\n```bash\nsource ~/.bashrc  # or ~/.zshrc, ~/.profile\n```\n\n### On Windows (Command Prompt):\n\nTo set it temporarily for the current session:\n\n```cmd\nset GOOGLE_GEMINI_API_KEY=\"YOUR_API_KEY_HERE\"\n```\n\nTo set it permanently:\n\n1.  Search for \"Environment Variables\" in the Windows search bar and select \"Edit the system environment variables\".\n2.  Click the \"Environment Variables...\" button.\n3.  Under \"User variables\" (for your user only) or \"System variables\" (for all users), click \"New...\" .\n4.  Enter `GOOGLE_GEMINI_API_KEY` as the variable name and your API key as the variable value.\n5.  Click \"OK\" on all dialogs.\n6.  You may need to restart your terminal or IDE for the changes to take effect.\n\n### Using a `.env` file (Recommended for local development):\n\nThe project is configured to use `dotenv`. You can create a file named `.env` in the root directory of the `ai-editor` project (the same directory as `package.json`) and add your API key there:\n\n```\nGOOGLE_GEMINI_API_KEY=\"YOUR_API_KEY_HERE\"\n```\n\nThis method is convenient for local development as it keeps your API key out of version control (if `.env` is in `.gitignore`, which it should be by default).\n\n---\n\nNow, the `ai-editor` tool should be able to access your Google Gemini API key.\n\n\n// File: src/index.ts\nimport dotenv from 'dotenv';\ndotenv.config();\nimport { Command } from 'commander';\nimport inquirer from 'inquirer';\nimport { scanProject } from './scanner';\nimport { prepareContextForLLM, buildLLMPrompt } from './llm/contextPreparer';\nimport { callLLM } from './llm/llmOrchestrator';\nimport { generateUnifiedDiff } from './file-operations/diffGenerator';\nimport { applyFileChange } from './file-operations/fileApplier';\nimport {\n  isGitRepository,\n  createBranch,\n  stageFiles,\n  getCurrentBranch,\n} from './git-operations/gitManager';\nimport { ScannedFile, LLMInput, LLMOutput, ProposedFileChange } from './types';\nimport simpleGit, { SimpleGit } from 'simple-git';\nimport * as path from 'path';\n\nconst program = new Command();\n\nprogram\n  .name('ai-editor')\n  .description('An AI-powered tool for editing and updating code files.')\n  .version('0.1.0');\n\nprogram\n  .command('scan [paths...]') // Changed to accept multiple paths (files or directories)\n  .description('Scans one or more files or directories for relevant code files and reads their content.')\n  .option('-v, --verbose', 'Output detailed information during scan.')\n  .option('-s, --show-content', 'Show a snippet of file content for sample files.')\n  .action(async (paths: string[], options: { verbose?: boolean; showContent?: boolean }) => {\n    // If no paths are provided, default to current working directory\n    const targetPaths = paths.length > 0 ? paths : ['.'];\n    const projectRoot = process.cwd(); // For 'scan' command, assume CWD is the project root\n\n    console.log(`Scanning paths: ${targetPaths.map(p => path.resolve(projectRoot, p)).join(', ')}`);\n    if (options.verbose) {\n      console.log('Verbose mode enabled.');\n    }\n\n    try {\n      // Pass the array of targetPaths and the projectRoot to scanProject\n      const scannedFiles: ScannedFile[] = await scanProject(targetPaths, projectRoot, options.verbose);\n      console.log('\\n--- Scan Complete ---');\n      console.log(`Found ${scannedFiles.length} files.`);\n\n      if (scannedFiles.length > 0) {\n        console.log('Sample files found:');\n        scannedFiles.slice(0, 5).forEach((file) => {\n          // Display path relative to CWD for user clarity\n          const displayPath = path.relative(process.cwd(), file.filePath);\n          console.log(`  - ${displayPath}`);\n          if (options.showContent) {\n            const contentSnippet =\n              file.content.substring(0, 200) + (file.content.length > 200 ? '...' : '');\n            console.log(\n              `    Content snippet:\\n${contentSnippet\n                .split('\\n')\n                .map((line) => `      ${line}`)\n                .join('\\n')}\\n`,\n            );\n          }\n        });\n        if (scannedFiles.length > 5) {\n          console.log(`  ... and ${scannedFiles.length - 5} more.`);\n        }\n      }\n    } catch (error) {\n      console.error(`Error during scan: ${(error as Error).message}`);\n      process.exit(1);\n    }\n  });\n\nprogram\n  .command('generate <prompt>')\n  .description('Generates or modifies code based on a natural language prompt.')\n  .option(\n    '-p, --path <path>',\n    'Specify the project root directory (default: current directory). This is where Git operations and file resolution will be based.',\n    '.',\n  )\n  .option(\n    '--scan-dirs <dirs...>',\n    'Space-separated list of directories to scan within the project root (e.g., \"src tests\").',\n  )\n  .option(\n    '--scan-files <files...>', // NEW option for individual files\n    'Space-separated list of individual file paths to scan within the project root (e.g., \"src/App.tsx tests/my-test.ts\").',\n  )\n  .option(\n    '-y, --yes',\n    'Automatically confirm all proposed changes without prompting (USE WITH CAUTION!).',\n    false,\n  )\n  .option('--no-git', 'Skip all Git operations (branching, staging).', false)\n  .option(\n    '--branch <name>',\n    'Specify a branch name to create/checkout. If not provided, a default is suggested.',\n  )\n  .action(\n    async (\n      prompt: string,\n      options: {\n        path: string; // This is the project root\n        scanDirs?: string[]; // Commander.js will pass as array or undefined\n        scanFiles?: string[]; // NEW: Commander.js will pass as array or undefined\n        yes: boolean;\n        noGit: boolean;\n        branch?: string;\n      },\n    ) => {\n      const projectRoot = path.resolve(process.cwd(), options.path);\n      \n      let allScanPaths: string[] = [];\n\n      if (options.scanDirs && options.scanDirs.length > 0) {\n          allScanPaths = allScanPaths.concat(options.scanDirs);\n      }\n      if (options.scanFiles && options.scanFiles.length > 0) {\n          allScanPaths = allScanPaths.concat(options.scanFiles);\n      }\n\n      // If neither --scan-dirs nor --scan-files are provided, default to scanning the entire project root.\n      if (allScanPaths.length === 0) {\n          allScanPaths = ['.'];\n      }\n\n      const autoConfirm = options.yes;\n      const skipGit = options.noGit;\n      const customBranchName = options.branch;\n\n      console.log(`AI Code Generation Request: \"${prompt}\"`);\n      console.log(`Project root: ${projectRoot}`);\n      console.log(`Scanning paths (relative to project root): ${allScanPaths.join(', ')}`);\n\n      try {\n        let isGitRepo = false;\n        let originalBranch: string | null = null;\n        if (!skipGit) {\n          // Git operations should always be relative to the project root\n          isGitRepo = await isGitRepository(projectRoot);\n          if (isGitRepo) {\n            originalBranch = await getCurrentBranch(projectRoot);\n            console.log(\n              `\\n--- Git: Detected Git repository. Current branch: ${originalBranch} ---`,\n            );\n            if (!autoConfirm) {\n              const defaultBranchSuggestion =\n                `ai-feature/${prompt.toLowerCase().replace(/[^a-z0-9]+/g, '-')}`.substring(0, 50);\n              const { proceedGit } = await inquirer.prompt([\n                {\n                  type: 'confirm',\n                  name: 'proceedGit',\n                  message: `Proceed with Git operations (create new branch, stage changes)? Recommended.`,\n                  default: true,\n                },\n              ]);\n              if (!proceedGit) {\n                options.noGit = true;\n              } else {\n                if (!customBranchName) {\n                  const { branchNameInput } = await inquirer.prompt([\n                    {\n                      type: 'input',\n                      name: 'branchNameInput',\n                      message: `Enter new branch name (default: ${defaultBranchSuggestion}):`,\n                      default: defaultBranchSuggestion,\n                    },\n                  ]);\n                  options.branch = branchNameInput;\n                }\n                await createBranch(projectRoot, options.branch!);\n              }\n            } else {\n              if (!options.noGit && !customBranchName) {\n                options.branch =\n                  `ai-feature/${prompt.toLowerCase().replace(/[^a-z0-9]+/g, '-')}`.substring(0, 50);\n                console.log(`Auto-creating branch: ${options.branch}`);\n              }\n              if (!options.noGit && options.branch) {\n                await createBranch(projectRoot, options.branch);\n              }\n            }\n          } else {\n            console.log(`\\n--- Git: Not a Git repository. Skipping Git operations. ---`);\n            options.noGit = true;\n          }\n        } else {\n          console.log(`\\n--- Git: Skipping Git operations as requested. ---`);\n        }\n\n        console.log('\\n--- Step 1: Scanning project files ---');\n        // Pass the array of allScanPaths, and the projectRoot for context.\n        const scannedFiles: ScannedFile[] = await scanProject(allScanPaths, projectRoot);\n        console.log(`Found ${scannedFiles.length} files.`);\n\n        const originalFileContents = new Map<string, string>();\n        scannedFiles.forEach((file) => originalFileContents.set(file.filePath, file.content));\n\n        console.log('\\n--- Step 2: Preparing LLM context ---');\n        // Generate a simple project structure string from the scanned files\n        const projectStructure = generateProjectStructureString(scannedFiles);\n\n        const llmInput: LLMInput = {\n          userPrompt: prompt,\n          projectRoot: projectRoot,\n          projectStructure: projectStructure,\n          relevantFiles: scannedFiles,\n          additionalInstructions: `\n            You are an expert TypeScript/React/Tailwind developer.\n            Focus on creating clean, idiomatic code. Ensure all generated code is fully type-safe.\n            When modifying existing files, preserve existing formatting and code style as much as possible.\n            If adding new components or modules, place them in logical, idiomatic locations within the project structure.\n            Consider common best practices for React (hooks, functional components, state management with nanostores if applicable) and Tailwind CSS v4 (utility-first, responsive design).\n            If a new file is created, ensure it follows the correct naming conventions and is properly imported/exported where necessary.\n            Always consider the full context of the project when making changes.\n            For 'modify' actions, provide only the *entire new content* of the file, not just a diff.\n            For 'add' actions, provide the *entire content* of the new file.\n            For 'delete' actions, no newContent is required.\n            If you need to add a new dependency, mention it in the summary or thought process, but do NOT include 'npm install' or 'yarn add' commands in the file changes.\n          `.replace(/^\\s+/gm, ''), // Clean up leading whitespace\n          expectedOutputFormat: `\n            Your response must be a JSON object with two top-level keys: 'summary' (string) and 'changes' (array of objects).\n            The 'changes' array should contain objects, each representing a file operation:\n            {\n              \"filePath\": \"path/to/file.tsx\", // Absolute path (use path.join(projectRoot, relativePath) to construct)\n              \"action\": \"add\" | \"modify\" | \"delete\",\n              \"newContent\"?: \"...\", // Required for 'add'/'modify', omit for 'delete'\n              \"reason\"?: \"...\" // Optional, short explanation for this specific file change\n            }\n            Example:\n            {\n              \"summary\": \"Implemented user authentication and updated Navbar component.\",\n              \"thoughtProcess\": \"Created new components for login and signup, updated navigation to include auth links, and added a basic auth context.\",\n              \"changes\": [\n                {\n                  \"filePath\": \"/path/to/project/src/auth/Login.tsx\",\n                  \"action\": \"add\",\n                  \"newContent\": \"import React from 'react';\\\\nimport { useStore } from '@nanostores/react';\\\\nimport { authStore } from './authStore';\\\\n\\\\nfunction Login() {\\\\n  const $auth = useStore(authStore);\\n  // ... login form logic\\n  return <div className='p-4'>Login Form</div>;\\\\n}\\\\nexport default Login;\",\n                  \"reason\": \"New login component for user authentication.\"\n                },\n                {\n                  \"filePath\": \"/path/to/project/src/components/Navbar.tsx\",\n                  \"action\": \"modify\",\n                  \"newContent\": \"import React from 'react';\\\\nimport { Link } from 'react-router-dom';\\\\nimport { useStore } from '@nanostores/react';\\\\nimport { authStore } from '../auth/authStore';\\\\n\\\\nfunction Navbar() {\\\\n  const $auth = useStore(authStore);\\n  return (\\\\n    <nav className='bg-blue-500 p-4 text-white flex justify-between'>\\\\n      <Link to='/' className='font-bold text-lg'>My App</Link>\\\\n      <div>\\\\n        {$auth.isLoggedIn ? (\\\\n          <button onClick={() => authStore.setKey('isLoggedIn', false)} className='ml-4'>Logout</button>\\\\n        ) : (\\\\n          <>\n            <Link to='/login' className='ml-4'>Login</Link>\\\\n            <Link to='/signup' className='ml-4'>Signup</Link>\\\\n          </>\\\\n        )}\\n      </div>\\\\n    </nav>\\\\n  );\\n}\\nexport default Navbar;\",\n                  \"reason\": \"Added login/logout links to Navbar based on authentication status.\"\n                },\n                {\n                  \"filePath\": \"/path/to/project/src/old/DeprecatedComponent.ts\",\n                  \"action\": \"delete\",\n                  \"reason\": \"Removed unused component as part of refactor.\"\n                }\n              ]\n            }\n          `.replace(/^\\s+/gm, ''), // Clean up leading whitespace\n        };\n\n        console.log('\\n--- Step 3: Calling LLM ---');\n        const llmOutput: LLMOutput = await callLLM(llmInput, projectRoot); // Pass projectRoot for potential LLM calls that need it\n\n        console.log('\\n--- Step 4: LLM Proposed Changes ---');\n        console.log(`Summary: ${llmOutput.summary}`);\n        if (llmOutput.thoughtProcess) {\n          console.log(`Thought Process:\\n${llmOutput.thoughtProcess}`);\n        }\n\n        if (llmOutput.changes.length === 0) {\n          console.log('No changes proposed by the LLM. Exiting.');\n          return;\n        }\n\n        console.log('\\nReviewing Proposed File Changes:');\n        const changesToApply: ProposedFileChange[] = [];\n        const filesModifiedOrAdded: string[] = [];\n\n        for (const change of llmOutput.changes) {\n          // Paths displayed to user should be relative to project root (or CWD)\n          const relativePathForDisplay = path.relative(projectRoot, change.filePath);\n          console.log(\n            `\\n--- Proposed Change for: ${relativePathForDisplay} (${change.action.toUpperCase()}) ---`,\n          );\n          if (change.reason) {\n            console.log(`Reason: ${change.reason}`);\n          }\n\n          if (change.action === 'add') {\n            console.log('This will create a NEW file.');\n            console.log('New Content Preview (first 20 lines):');\n            console.log('```typescript'); // Assuming TypeScript for code preview\n            console.log(change.newContent?.split('\\n').slice(0, 20).join('\\n'));\n            if (change.newContent && change.newContent.split('\\n').length > 20) {\n              console.log('...');\n            }\n            console.log('```');\n          } else if (change.action === 'modify') {\n            const originalContent = originalFileContents.get(change.filePath) || '';\n            const diff = generateUnifiedDiff(originalContent, change.newContent || '');\n            if (diff) {\n              console.log('Changes (diff):');\n              console.log(diff);\n            } else {\n              console.log(\n                'No effective changes detected (content is identical). Skipping this modification.',\n              );\n              continue;\n            }\n          } else if (change.action === 'delete') {\n            console.log('This will DELETE the file.');\n          }\n\n          if (autoConfirm) {\n            console.log('Auto-confirming this change (--yes flag).');\n            changesToApply.push(change);\n            filesModifiedOrAdded.push(change.filePath);\n          } else {\n            const { confirm } = await inquirer.prompt([\n              {\n                type: 'list',\n                name: 'confirm',\n                message: `Apply this change to ${relativePathForDisplay}?`,\n                choices: [\n                  { name: 'Yes (apply this change)', value: 'yes' },\n                  { name: 'No (skip this change)', value: 'no' },\n                  { name: 'Apply All (apply this and all subsequent changes)', value: 'all' },\n                  { name: 'Abort (stop entirely)', value: 'abort' },\n                ],\n              },\n            ]);\n\n            if (confirm === 'yes') {\n              changesToApply.push(change);\n              filesModifiedOrAdded.push(change.filePath);\n            } else if (confirm === 'all') {\n              changesToApply.push(change);\n              filesModifiedOrAdded.push(change.filePath);\n              options.yes = true; // Set autoConfirm for subsequent loops\n            } else if (confirm === 'abort') {\n              console.log('Aborting changes. No files modified.');\n              if (isGitRepo && !options.noGit && options.branch && originalBranch) {\n                console.log(`Reverting to original branch: ${originalBranch}`);\n\n                await getGit(projectRoot).checkout(originalBranch);\n              }\n              return;\n            } else {\n              console.log(`Skipping change for ${relativePathForDisplay}.`);\n            }\n          }\n        }\n\n        if (changesToApply.length === 0) {\n          console.log('\\nNo changes were confirmed. Exiting.');\n          if (isGitRepo && !options.noGit && options.branch && originalBranch) {\n            console.log(`Reverting to original branch: ${originalBranch}`);\n            await getGit(projectRoot).checkout(originalBranch);\n          }\n          return;\n        }\n\n        console.log('\\n--- Applying Confirmed Changes ---');\n        for (const change of changesToApply) {\n          try {\n            await applyFileChange(projectRoot, change); // applyFileChange needs projectRoot or baseDir\n          } catch (fileError) {\n            console.error(\n              `Failed to apply change for ${change.filePath}: ${(fileError as Error).message}`,\n            );\n          }\n        }\n\n        console.log('\\n--- Changes Applied Successfully! ---');\n\n        if (isGitRepo && !options.noGit) {\n          console.log('\\n--- Git: Staging changes ---');\n          await stageFiles(projectRoot, filesModifiedOrAdded);\n\n          console.log('\\nNext Steps:');\n          console.log(\n            `1. Your changes have been applied and staged on branch '${options.branch || originalBranch}'.`,\n          );\n          console.log(`2. Review the changes using 'git diff --staged'.`);\n          console.log(`3. Commit your changes:`);\n          console.log(`   git commit -m \"${llmOutput.summary}\"`);\n          console.log(`4. Run your tests to ensure everything still works as expected.`);\n          console.log(\n            `5. If you want to revert to the previous branch: git checkout ${originalBranch}`,\n          );\n        } else {\n          console.log('\\nNext Steps:');\n          console.log(`1. It's highly recommended to review the changes in your editor.`);\n          if (isGitRepo) {\n            console.log(`2. You skipped Git operations. To commit, you'll need to manually:`);\n            console.log(`   git add .`);\n            console.log(`   git commit -m \"${llmOutput.summary}\"`);\n          } else {\n            console.log(\n              `2. This is not a Git repository. Consider initializing one if this is a project:`,\n            );\n            console.log(`   git init`);\n            console.log(`   git add .`);\n            console.log(`   git commit -m \"Initial commit by AI Editor\"`);\n          }\n          console.log(`3. Run your tests to ensure everything still works as expected.`);\n        }\n      } catch (error) {\n        console.error(`Error during generation: ${(error as Error).message}`);\n        process.exit(1);\n      }\n    },\n  );\n\nprogram.parse(process.argv);\n\nfunction getGit(baseDir: string): SimpleGit {\n  return simpleGit(baseDir, { binary: 'git' });\n}\n\n/**\n * Generates a simple tree-like string representing the project structure\n * based on the relative paths of scanned files.\n * This structure is intended to provide high-level context to the LLM.\n *\n * @param scannedFiles An array of ScannedFile objects.\n * @returns A string representing the project structure.\n */\nfunction generateProjectStructureString(scannedFiles: ScannedFile[]): string {\n  const structurePaths: Set<string> = new Set();\n  const sortedRelativePaths = scannedFiles.map(f => f.relativePath).sort(); // Sort for consistent output\n\n  // Add all file paths and their parent directories to the set\n  for (const relPath of sortedRelativePaths) {\n    let currentSegment = '';\n    const parts = relPath.split(path.sep);\n    for (let i = 0; i < parts.length; i++) {\n      currentSegment = path.join(currentSegment, parts[i]);\n      if (i === parts.length - 1) { // It's a file\n        structurePaths.add(currentSegment);\n      } else { // It's a directory\n        structurePaths.add(currentSegment + path.sep); // Add trailing slash for directories\n      }\n    }\n  }\n\n  // Convert the set to a sorted array for consistent output\n  const items = Array.from(structurePaths).sort();\n\n  const structuredLines: string[] = [];\n  items.forEach(item => {\n    // Determine depth for indentation. Count path separators.\n    // For directories (ending with sep), count parts-1. For files, count parts.\n    const depth = item.split(path.sep).length - (item.endsWith(path.sep) ? 1 : 0);\n    const indent = '  '.repeat(Math.max(0, depth)); // Ensure non-negative depth\n    structuredLines.push(`${indent}- ${item}`);\n  });\n\n  return structuredLines.join('\\n');\n}\n\n\n// File: src/scanner.ts\nimport { promises as fs } from 'fs';\nimport * as path from 'path';\nimport { ScannedFile } from './types'; // Import our updated type\n\n/**\n * Defines file extensions relevant to frontend development and general code.\n */\nconst RELEVANT_FILE_EXTENSIONS = new Set([\n  '.ts', '.tsx', '.js', '.jsx', '.json', '.md', '.yml', '.html', '.css', '.scss', '.less',\n  '.cjs', '.mjs', '.toml', '.xml', // config and module types\n  '.jsonc', // JSON with comments\n  '.vue', '.svelte', // Frontend frameworks\n  '.graphql', '.gql', // GraphQL schema/queries\n  '.sql', // Database schemas\n  '.py', '.rb', '.go', '.java', '.c', '.cpp', '.cs', '.php', // Backend/other languages\n  '.sh', '.bash', '.zsh', // Shell scripts\n  '.env', // Environment files\n  '.txt', // Plain text\n]);\n\n/**\n * Directories to always exclude from scanning, regardless of depth.\n * These are matched by their exact name (basename).\n */\nconst EXCLUDE_DIR_NAMES = new Set([\n  'node_modules', '.git', '.vscode', '.idea', 'dist', 'build', 'out', 'coverage',\n  '__pycache__', 'venv', 'target', 'vendor', '.ai-editor-logs'// common for other languages\n]);\n\n/**\n * Specific file names to always exclude from scanning, regardless of depth.\n * These are matched by their exact name (basename).\n */\nconst EXCLUDE_FILE_NAMES = new Set([\n  'package-lock.json', 'yarn.lock', 'pnpm-lock.yaml', '.DS_Store', // Lock files and system files\n]);\n\n/**\n * Specific file names that should always be included, even if their extension is not in RELEVANT_FILE_EXTENSIONS,\n * or if they are common dotfiles (e.g., config files).\n */\nconst RELEVANT_CONFIG_FILENAMES = new Set([\n  'package.json', 'tsconfig.json', 'vite.config.ts', 'webpack.config.js',\n  'rollup.config.js', 'tailwind.config.ts', '.gitignore', '.eslintrc.js',\n  '.prettierrc.js', 'Dockerfile', 'Makefile', 'LICENSE', 'README.md', 'README.txt',\n  'biome.json', 'jest.config.ts',\n  '.env.local', '.env.development', '.env.production', // Specific .env files\n]);\n\n\n/**\n * Scans specified paths (which can be directories or individual files) recursively for relevant code files\n * and reads their content. Ensures file paths are absolute and also provides a path relative to the project root.\n * Handles multiple scan paths and deduplicates files.\n *\n * @param scanPaths An array of paths (relative or absolute) to scan. Each path can be a directory or a file.\n * @param projectRoot The root directory of the project, used for calculating relative paths.\n * @param verbose If true, logs detailed information during scanning.\n * @returns A promise that resolves to an array of ScannedFile objects.\n */\nexport async function scanProject(\n  scanPaths: string[],\n  projectRoot: string,\n  verbose: boolean = false\n): Promise<ScannedFile[]> {\n  const allScannedFiles: ScannedFile[] = [];\n  const processedAbsolutePaths = new Set<string>(); // To deduplicate files if multiple scan paths overlap\n\n  // Process each path in the input array\n  for (const currentPath of scanPaths) {\n    const absolutePath = path.resolve(projectRoot, currentPath);\n\n    if (processedAbsolutePaths.has(absolutePath)) {\n      if (verbose) {\n        console.log(`  Skipping '${absolutePath}' (already processed).`);\n      }\n      continue;\n    }\n\n    let stats;\n    try {\n      stats = await fs.stat(absolutePath);\n    } catch (error) {\n      console.error(`Error accessing path '${absolutePath}': ${(error as Error).message}. Skipping.`);\n      continue;\n    }\n\n    if (stats.isFile()) {\n      // If the path is an explicit file, include it directly\n      try {\n        const content = await fs.readFile(absolutePath, 'utf-8');\n        const relativeToProjectRoot = path.relative(projectRoot, absolutePath);\n        allScannedFiles.push({\n          filePath: absolutePath,\n          relativePath: relativeToProjectRoot,\n          content: content,\n        });\n        processedAbsolutePaths.add(absolutePath);\n        if (verbose) {\n          console.log(`  Included explicit file: ${relativeToProjectRoot}`);\n        }\n      } catch (readError) {\n        console.warn(`Warning: Could not read explicit file '${absolutePath}': ${(readError as Error).message}`);\n      }\n    } else if (stats.isDirectory()) {\n      // If the path is a directory, use the recursive scanning logic\n      if (verbose) {\n        console.log(`  Initiating recursive scan for directory: ${absolutePath}`);\n      }\n      const queue: string[] = [absolutePath];\n\n      while (queue.length > 0) {\n        const currentDir = queue.shift()!;\n        let entries;\n        try {\n          entries = await fs.readdir(currentDir, { withFileTypes: true });\n        } catch (error) {\n          console.error(`Error reading directory '${currentDir}': ${(error as Error).message}. Skipping.`);\n          continue;\n        }\n\n        for (const entry of entries) {\n          const entryFullPath = path.join(currentDir, entry.name);\n          const relativeToProjectRoot = path.relative(projectRoot, entryFullPath);\n\n          // --- Exclusion Logic for recursive directory scanning ---\n          // 1. Exclude specific directory names (e.g., node_modules, .git)\n          if (entry.isDirectory() && EXCLUDE_DIR_NAMES.has(entry.name)) {\n            if (verbose) {\n              console.log(`    Excluding directory: ${relativeToProjectRoot}`);\n            }\n            continue;\n          }\n\n          // 2. Exclude specific file names (e.g., package-lock.json, .DS_Store)\n          if (entry.isFile() && EXCLUDE_FILE_NAMES.has(entry.name)) {\n            if (verbose) {\n              console.log(`    Excluding file: ${relativeToProjectRoot}`);\n            }\n            continue;\n          }\n\n          if (entry.isDirectory()) {\n            queue.push(entryFullPath);\n          } else if (entry.isFile()) {\n            const ext = path.extname(entry.name).toLowerCase();\n\n            // Determine if the file should be included based on extension or explicit filename\n            const isIncluded = RELEVANT_FILE_EXTENSIONS.has(ext) || RELEVANT_CONFIG_FILENAMES.has(entry.name);\n\n            if (isIncluded) {\n              // Add file only if its absolute path hasn't been processed yet (for deduplication)\n              if (!processedAbsolutePaths.has(entryFullPath)) {\n                try {\n                  const content = await fs.readFile(entryFullPath, 'utf-8');\n                  allScannedFiles.push({\n                    filePath: entryFullPath, // Absolute path\n                    relativePath: relativeToProjectRoot, // Path relative to project root\n                    content: content,\n                  });\n                  processedAbsolutePaths.add(entryFullPath); // Mark as processed\n                  if (verbose) {\n                    console.log(`    Included: ${relativeToProjectRoot}`);\n                  }\n                } catch (readError) {\n                  console.warn(`Warning: Could not read file '${entryFullPath}': ${(readError as Error).message}`);\n                }\n              } else if (verbose) {\n                console.log(`    Skipping (already processed): ${relativeToProjectRoot}`);\n              }\n            } else {\n              if (verbose) {\n                console.log(`    Skipping file: ${relativeToProjectRoot} (unsupported type)`);\n              }\n            }\n          }\n        }\n      }\n    } else {\n      console.warn(`Warning: '${absolutePath}' is neither a file nor a directory. Skipping.`);\n    }\n  }\n\n  return allScannedFiles;\n}\n\n\n// File: src/types.ts\n// src/types.ts\n\n/**\n * Represents a file that has been scanned from the project,\n * including its absolute path, its path relative to the project root, and its textual content.\n */\nexport interface ScannedFile {\n  filePath: string; // Absolute path to the file\n  relativePath: string; // Path relative to the project root (e.g., \"src/components/MyComponent.tsx\")\n  content: string;\n}\n\n/**\n * Represents a proposed change to a file.\n * This is the structured output we expect from the LLM.\n */\nexport interface ProposedFileChange {\n  filePath: string; // Absolute path to the file to be changed\n  action: 'add' | 'modify' | 'delete';\n  /**\n   * For 'add' or 'modify' actions, this is the new content of the file.\n   * For 'delete' actions, this field is not used.\n   */\n  newContent?: string;\n  /**\n   * An optional human-readable reason or summary for the change.\n   */\n  reason?: string;\n}\n\n/**\n * Represents the structured input that will be sent to the LLM.\n */\nexport interface LLMInput {\n  userPrompt: string;\n  projectRoot: string;\n  projectStructure: string; // A high-level overview of the project directory (e.g., tree string)\n  relevantFiles: ScannedFile[];\n  additionalInstructions: string; // Specific behavioral instructions for the LLM\n  expectedOutputFormat: string; // Instructions on the JSON format for the LLM's response\n}\n\n/**\n * Represents the structured output received from the LLM.\n */\nexport interface LLMOutput {\n  changes: ProposedFileChange[];\n  summary: string; // A concise summary of all changes made/proposed\n  thoughtProcess?: string; // LLM's detailed reasoning for the changes\n}\n\n\n\n// File: src/file-operations/diffGenerator.ts\n // src/file-operations/diffGenerator.ts\nimport * as Diff from 'diff';\nimport chalk from 'chalk'; // For colorful console output (install if you don't have it: npm i chalk)\n\n// Ensure chalk is installed: npm install chalk@4.1.2 (or latest version)\n// Note: chalk v5+ is ESM only, so using v4 for CommonJS compatibility with ts-node without extra config.\n// If you want to use chalk v5+, you might need to adjust tsconfig.json to \"module\": \"ESNext\" and add \"type\": \"module\" to package.json.\n\n/**\n * Generates a human-readable diff string between two text contents.\n * @param originalContent The original content of the file.\n * @param newContent The proposed new content of the file.\n * @returns A string representing the unified diff, or an empty string if contents are identical.\n */\nexport function generateUnifiedDiff(originalContent: string, newContent: string): string {\n  // Use Diff.createPatch for a standard unified diff format\n  // For simpler line-by-line diffs without patch headers, Diff.diffLines is also an option.\n  const diff = Diff.diffLines(originalContent, newContent);\n\n  if (diff.length === 1 && diff[0].added === undefined && diff[0].removed === undefined) {\n    return ''; // No changes\n  }\n\n  let diffString = '';\n  diff.forEach(part => {\n    // green for additions, red for deletions, white for common parts\n    const color = part.added ? chalk.green :\n                  part.removed ? chalk.red :\n                  chalk.grey; // Changed to grey for context lines\n    const prefix = part.added ? '+ ' :\n                   part.removed ? '- ' :\n                   '  '; // Indent common lines\n    // Add prefix to each line\n    diffString += color(part.value.split('\\n').map(line => prefix + line).join('\\n'));\n  });\n\n  return diffString;\n}\n\n\n// File: src/file-operations/fileApplier.ts\n// src/file-operations/fileApplier.ts\nimport { promises as fs } from 'fs';\nimport * as path from 'path';\nimport { ProposedFileChange } from '../types';\n\n/**\n * Applies a single proposed file change (add, modify, or delete) to the file system.\n * Ensures parent directories exist for 'add' actions.\n * @param projectRoot The absolute path to the root of the target project.\n * @param change The ProposedFileChange object.\n * @returns A Promise that resolves when the operation is complete.\n */\nexport async function applyFileChange(projectRoot: string, change: ProposedFileChange): Promise<void> {\n  // Resolve the absolute path using the provided projectRoot\n  const absolutePath = path.resolve(projectRoot, change.filePath);\n\n  switch (change.action) {\n    case 'add':\n      // Ensure the directory exists before writing the file\n      const dir = path.dirname(absolutePath);\n      await fs.mkdir(dir, { recursive: true });\n      if (change.newContent === undefined) {\n        throw new Error(`Cannot add file '${change.filePath}': newContent is undefined.`);\n      }\n      await fs.writeFile(absolutePath, change.newContent, 'utf-8');\n      console.log(`  ➕ Created: ${path.relative(projectRoot, absolutePath)}`); // Log path relative to project\n      break;\n\n    case 'modify':\n      // Check if the file exists before attempting to modify\n      try {\n        await fs.access(absolutePath); // Throws if file doesn't exist\n      } catch {\n        throw new Error(`Cannot modify file '${change.filePath}': File does not exist in target project.`);\n      }\n      if (change.newContent === undefined) {\n        throw new Error(`Cannot modify file '${change.filePath}': newContent is undefined.`);\n      }\n      await fs.writeFile(absolutePath, change.newContent, 'utf-8');\n      console.log(`  ✏️ Modified: ${path.relative(projectRoot, absolutePath)}`); // Log path relative to project\n      break;\n\n    case 'delete':\n      // Check if the file exists before attempting to delete\n      try {\n        await fs.access(absolutePath);\n      } catch {\n        throw new Error(`Cannot delete file '${change.filePath}': File does not exist in target project.`);\n      }\n      await fs.unlink(absolutePath);\n      console.log(`  🗑️ Deleted: ${path.relative(projectRoot, absolutePath)}`); // Log path relative to project\n      // Optional: Recursively delete empty parent directories\n      await cleanupEmptyParentDirectories(projectRoot, absolutePath); // Pass projectRoot here\n      break;\n\n    default:\n      throw new Error(`Unknown action type: ${(change as any).action}`);\n  }\n}\n\n/**\n * Attempts to delete empty parent directories after a file is deleted.\n * Stops at the first non-empty or non-existent directory.\n * @param projectRoot The absolute path to the root of the target project.\n * @param filePath The path of the file that was deleted (absolute path).\n */\nasync function cleanupEmptyParentDirectories(projectRoot: string, filePath: string): Promise<void> {\n  let currentDir = path.dirname(filePath); // This filePath is already absolute\n  // const projectRoot = process.cwd(); // This line is now removed or changed\n\n  // Walk up the directory tree\n  // Stop when currentDir reaches the projectRoot or the system root\n  while (currentDir !== projectRoot && currentDir !== path.parse(currentDir).root) {\n    try {\n      const entries = await fs.readdir(currentDir);\n      if (entries.length === 0) {\n        // Directory is empty, delete it\n        await fs.rmdir(currentDir);\n        console.log(`  🧹 Cleaned up empty directory: ${path.relative(projectRoot, currentDir)}`);\n        currentDir = path.dirname(currentDir); // Move up to parent\n      } else {\n        // Directory is not empty, stop\n        break;\n      }\n    } catch (error) {\n      // If directory doesn't exist or other error, stop\n      break;\n    }\n  }\n}\n\n\n// File: src/git-operations/gitManager.ts\n // src/git-operations/gitManager.ts\nimport simpleGit, { SimpleGit, CleanOptions, CheckRepoActions } from 'simple-git'; \nimport * as path from 'path';\n\n/**\n * Initializes a simple-git instance for the given directory.\n * @param baseDir The base directory of the Git repository.\n * @returns A SimpleGit instance.\n */\nfunction getGit(baseDir: string): SimpleGit {\n  return simpleGit(baseDir, { binary: 'git' });\n}\n\n/**\n * Checks if the given directory is a Git repository.\n * @param dirPath The path to check.\n * @returns True if it's a Git repo, false otherwise.\n */\nexport async function isGitRepository(dirPath: string): Promise<boolean> {\n  try {\n    const git = getGit(dirPath);\n    // Correct usage: CheckRepoActions.IS_GIT_REPO checks if the path is inside any Git repo\n    // or CheckRepoActions.IS_REPO_ROOT if you only want to verify it's the .git directory root.\n    await git.checkIsRepo(CheckRepoActions.IS_REPO_ROOT ); // <-- CHANGE THIS LINE\n    return true;\n  } catch (error) {\n    // This typically throws if it's not a repo.\n    return false;\n  }\n}\n\n/**\n * Creates a new Git branch.\n * @param repoPath The path to the Git repository.\n * @param branchName The name of the new branch to create.\n */\nexport async function createBranch(repoPath: string, branchName: string): Promise<void> {\n  const git = getGit(repoPath);\n  try {\n    await git.branch([branchName]);\n    await git.checkout(branchName);\n    console.log(`  ✅ Git: Created and checked out new branch: ${branchName}`);\n  } catch (error) {\n    console.warn(`  ⚠️ Git: Could not create or checkout branch '${branchName}': ${(error as Error).message}`);\n    // If branch already exists, it might just checkout. If it's a fatal error, rethrow.\n    if ((error as Error).message.includes('A branch named') && (error as Error).message.includes('already exists')) {\n        console.warn(`  ⚠️ Git: Branch '${branchName}' already exists. Checking it out instead.`);\n        await git.checkout(branchName);\n    } else {\n        throw error; // Re-throw unhandled errors\n    }\n  }\n}\n\n/**\n * Stages (adds) specified files to the Git index.\n * @param repoPath The path to the Git repository.\n * @param filePaths An array of file paths (relative to repoPath) to stage.\n */\nexport async function stageFiles(repoPath: string, filePaths: string[]): Promise<void> {\n  const git = getGit(repoPath);\n  try {\n    // Convert absolute paths to paths relative to the repo root for git add\n    const relativePaths = filePaths.map(filePath => path.relative(repoPath, filePath));\n    await git.add(relativePaths);\n    console.log(`  ✅ Git: Staged ${filePaths.length} files.`);\n  } catch (error) {\n    console.error(`  ❌ Git: Failed to stage files: ${(error as Error).message}`);\n    throw error;\n  }\n}\n\n/**\n * Gets the current branch name.\n * @param repoPath The path to the Git repository.\n * @returns The name of the current branch, or null if not in a branch.\n */\nexport async function getCurrentBranch(repoPath: string): Promise<string | null> {\n    const git = getGit(repoPath);\n    try {\n        const branchSummary = await git.branchLocal();\n        return branchSummary.current;\n    } catch (error) {\n        // Not a git repo, or other error\n        return null;\n    }\n}\n\n\n// File: src/llm/contextPreparer.ts\n// src/llm/contextPreparer.ts\nimport * as path from 'path';\nimport { ScannedFile, LLMInput } from '../types';\n\n/**\n * Prepares the context for the LLM by structuring the user prompt,\n * relevant files, and system instructions into a single LLMInput object.\n *\n * @param userPrompt The natural language request from the user.\n * @param scannedFiles An array of all files scanned from the project.\n * @param projectRoot The absolute path to the project's root directory.\n * @returns An LLMInput object ready to be sent to the LLM.\n */\nexport function prepareContextForLLM(userPrompt: string, scannedFiles: ScannedFile[], projectRoot: string): LLMInput {\n\n  // 1. Generate a simplified project structure string using relative paths\n  const projectStructureLines = scannedFiles\n    .map(file => file.relativePath) // Use the relativePath from ScannedFile\n    .sort()\n    .map(relPath => `- ${relPath}`);\n\n  const projectStructure = `Project File Structure (relative to root):\\n${projectStructureLines.join('\\n')}\\n`;\n\n  // 2. Define the expected output format for the LLM\n  const outputSchema = `\n            Your response must be a JSON object with two top-level keys: 'summary' (string) and 'changes' (array of objects).\n            The 'changes' array should contain objects, each representing a file operation:\n            {\n              \"filePath\": \"path/to/file.tsx\", // Absolute path (use path.join(projectRoot, relativePath) to construct)\n              \"action\": \"add\" | \"modify\" | \"delete\",\n              \"newContent\"?: \"...\", // Required for 'add'/'modify', omit for 'delete'\n              \"reason\"?: \"...\" // Optional, short explanation for this specific file change\n            }\n            Example:\n            {\n              \"summary\": \"Implemented user authentication and updated Navbar component.\",\n              \"thoughtProcess\": \"Created new components for login and signup, updated navigation to include auth links, and added a basic auth context.\",\n              \"changes\": [\n                {\n                  \"filePath\": \"/path/to/project/src/auth/Login.tsx\",\n                  \"action\": \"add\",\n                  \"newContent\": \"import React from 'react';\\\\nimport { useStore } from '@nanostores/react';\\\\nimport { authStore } from './authStore';\\\\n\\\\nfunction Login() {\\\\n  const $auth = useStore(authStore);\\\\n  // ... login form logic\\\\n  return <div className='p-4'>Login Form</div>;\\\\n}\\\\nexport default Login;\",\n                  \"reason\": \"New login component for user authentication.\"\n                },\n                {\n                  \"filePath\": \"/path/to/project/src/components/Navbar.tsx\",\n                  \"action\": \"modify\",\n                  \"newContent\": \"import React from 'react';\\\\nimport { Link } from 'react-router-dom';\\\\nimport { useStore } from '@nanostores/react';\\\\nimport { authStore } from '../auth/authStore';\\\\n\\\\nfunction Navbar() {\\\\n  const $auth = useStore(authStore);\\\\n  return (\\\\n    <nav className='bg-blue-500 p-4 text-white flex justify-between'>\\\\n      <Link to='/' className='font-bold text-lg'>My App</Link>\\\\n      <div>\\\\n        {$auth.isLoggedIn ? (\\\\n          <button onClick={() => authStore.setKey('isLoggedIn', false)} className='ml-4'>Logout</button>\\\\n        ) : (\\\\n          <>\\\\n            <Link to='/login' className='ml-4'>Login</Link>\\\\n            <Link to='/signup' className='ml-4'>Signup</Link>\\\\n          </>\\\\n        )}\\\\n      </div>\\\\n    </nav>\\\\n  );\\\\n}\\\\nexport default Navbar;\",\n                  \"reason\": \"Added login/logout links to Navbar based on authentication status.\"\n                },\n                {\n                  \"filePath\": \"/path/to/project/src/old/DeprecatedComponent.ts\",\n                  \"action\": \"delete\",\n                  \"reason\": \"Removed unused component as part of refactor.\"\n                }\n              ]\n            }\n          `.replace(/^\\s+/gm, '');\n\n  // 3. Construct additional instructions for the LLM\n  const additionalInstructions = `\nYou are an elite TypeSafe UI Architect. Your goal is to generate or modify code to fulfill the user's request, strictly adhering to modern frontend best practices.\nFocus on TypeScript, React (with Hooks and nanostores where applicable), and Tailwind CSS v4.\nGenerate clean, idiomatic, production-ready code.\nAlways propose a clear, refactored, and logically separated file and folder structure.\nConsider type safety paramount.\nIf the request involves new components, ensure they are well-structured, reusable, and include necessary imports and typings.\nIf modifying existing components, ensure backward compatibility where reasonable, or clearly state breaking changes.\nWhen generating new code, ensure it aligns with the existing project's style (indentation, semicolons, etc.).\nDo not make assumptions about external APIs unless specified.\nIf you need to add a new file, propose the full content of that new file.\nIf you need to modify an existing file, propose the full new content of that file.\nIf you need to delete a file, specify its path and action 'delete'.\n`;\n\n  return {\n    userPrompt: userPrompt,\n    projectRoot: projectRoot,\n    projectStructure: projectStructure,\n    relevantFiles: scannedFiles,\n    additionalInstructions: additionalInstructions,\n    expectedOutputFormat: outputSchema,\n  };\n}\n\n/**\n * This function will construct the final prompt string that is sent to the LLM.\n * This combines all parts of the LLMInput into a single markdown-formatted string.\n * @param llmInput The structured input object.\n * @param projectRoot The project root (passed to ensure consistency, but `llmInput.projectRoot` is the primary source).\n * @returns A string representing the full prompt for the LLM.\n */\nexport function buildLLMPrompt(llmInput: LLMInput, projectRoot: string): string {\n  // Use `file.relativePath` from `scannedFiles` for the prompt, as it's cleaner for LLM context.\n  const formattedRelevantFiles = llmInput.relevantFiles.map(file => {\n    return `// File: ${file.relativePath}\\n${file.content}`;\n  }).join('\\n\\n'); // Separate files with double newlines\n\n  return `\n# AI Code Generation Request\n\n${llmInput.additionalInstructions}\n\n## User Request\n\\`\\`\\`text\n${llmInput.userPrompt}\n\\`\\`\\`\n\n## Project Context\n${llmInput.projectStructure}\n\n### Relevant Files (for analysis)\n\\`\\`\\`files\n${formattedRelevantFiles}\n\\`\\`\\`\n\n## Expected Output Format\n${llmInput.expectedOutputFormat}\n`;\n}\n\n\n// File: src/llm/jsonRepair.ts\n// src/llm/jsonRepair.ts\n\n/**\n * Attempts to repair common bad escape sequences in a JSON string\n * that might be returned by an LLM.\n * This function primarily focuses on fixing lone backslashes within string values\n * that cause JSON parsing errors.\n *\n * It is assumed that the LLM, when instructed to return JSON (e.g., with responseMimeType: \"application/json\"),\n * generally handles standard string escapes like `\\n`, `\\t`, `\\\"` correctly.\n * This repair function is a fallback for common minor deviations, mainly malformed backslashes.\n *\n * @param jsonString The potentially malformed JSON string.\n * @returns A repaired JSON string, or the original string if no repairs were made.\n */\nexport function repairJsonBadEscapes(jsonString: string): string {\n  let repaired = jsonString;\n\n  // IMPORTANT: Removed the replacement for unescaped newlines/tabs/carriage returns.\n  // These replacements (e.g., `/(?<!\\\\)\\n/g, '\\\\n'`) were incorrectly converting\n  // structural newlines (used for JSON pretty-printing) into escaped newlines (`\\n` -> `\\\\n`),\n  // which makes the JSON invalid at the structural level.\n  // JSON parsers expect literal newlines/tabs for formatting outside of string literals.\n  // If a newline is inside a string value, the LLM should already be providing `\\\\n`.\n\n  // 1. Escape lone backslashes that are not part of a valid JSON escape sequence.\n  // This regex targets backslashes not followed by another backslash or a standard JSON escape char.\n  // Example: \"C:\\path\\to\\file\" should become \"C:\\\\path\\\\to\\\\file\"\n  // The `(?!...)` is a negative lookahead, ensuring the backslash is not followed by\n  // a valid JSON escape character (\", \\, /, b, f, n, r, t, u (for unicode escapes)).\n  // This is the most common and relatively safe repair for paths or other literal backslashes within string values.\n  repaired = repaired.replace(/\\\\(?![\"\\\\/bfnrtu])/g, '\\\\\\\\');\n\n  return repaired; // Return the repaired string\n}\n\n\n// File: src/llm/llmOrchestrator.ts\n// src/llm/llmOrchestrator.ts\nimport { promises as fs } from 'fs';\nimport * as path from 'path';\nimport { GoogleGenerativeAI, HarmCategory, HarmBlockThreshold } from '@google/generative-ai';\nimport { LLMInput, LLMOutput, ProposedFileChange } from '../types';\nimport { buildLLMPrompt } from './contextPreparer';\nimport { repairJsonBadEscapes } from './jsonRepair';\n\n// Access your API key (ensure dotenv is configured in index.ts)\nconst API_KEY = process.env.GOOGLE_GEMINI_API_KEY;\nconst MODEL = process.env.GOOGLE_GEMINI_MODEL || 'gemini-1.5-pro-latest'; // Added a default model for robustness\n\nif (!API_KEY) {\n  console.error('Error: GOOGLE_GEMINI_API_KEY environment variable not set.');\n  console.error('Please create a .env file in the project root with GOOGLE_GEMINI_API_KEY=\"YOUR_API_KEY\".');\n  process.exit(1);\n}\n\nconst genAI = new GoogleGenerativeAI(API_KEY);\n\n// Choose a model. Gemini 1.5 Pro is generally good for coding.\nconst model = genAI.getGenerativeModel({ model: MODEL });\n\n// Safety settings to ensure generated content is appropriate\nconst safetySettings = [\n  {\n    category: HarmCategory.HARM_CATEGORY_HARASSMENT,\n    threshold: HarmBlockThreshold.BLOCK_NONE, // Adjust as needed, BLOCK_NONE can lead to more candid responses, but potentially harmful ones. BLOCK_LOW_AND_ABOVE is safer default.\n  },\n  {\n    category: HarmCategory.HARM_CATEGORY_HATE_SPEECH,\n    threshold: HarmBlockThreshold.BLOCK_NONE,\n  },\n  {\n    category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT,\n    threshold: HarmBlockThreshold.BLOCK_NONE,\n  },\n  {\n    category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT,\n    threshold: HarmBlockThreshold.BLOCK_NONE,\n  },\n];\nconst LOGS_DIR = path.join(process.cwd(), '.ai-editor-logs'); // Logs directory at project root\n\n/**\n * Saves the raw text response from the LLM to a timestamped JSON file.\n * The file is saved in a `.ai-editor-logs` directory at the project root.\n * @param rawText The raw string response from the LLM.\n * @param prompt The original prompt sent to the LLM (for context in the log file).\n */\nasync function saveRawLLMResponse(rawText: string, prompt: string): Promise<void> {\n  try {\n    await fs.mkdir(LOGS_DIR, { recursive: true }); // Ensure log directory exists\n\n    const timestamp = new Date().toISOString().replace(/[:.]/g, '-'); // YYYY-MM-DDTHH-MM-SS-MSZ\n    const fileName = `llm-response-${timestamp}.json`; // Using .json as it's expected to be JSON\n    const filePath = path.join(LOGS_DIR, fileName);\n\n    const logContent = {\n      timestamp: new Date().toISOString(),\n      prompt: prompt,\n      rawLLMResponse: rawText,\n    };\n\n    await fs.writeFile(filePath, JSON.stringify(logContent, null, 2), 'utf-8');\n    console.log(`  📝 Saved raw LLM response to: ${path.relative(process.cwd(), filePath)}`);\n  } catch (error) {\n    console.error(`  ❌ Error saving raw LLM response to file: ${(error as Error).message}`);\n  }\n}\n/**\n * Extracts a JSON string from text that might be wrapped in markdown code blocks.\n * This makes parsing more robust against LLM formatting variations.\n * @param text The raw text from the LLM.\n * @returns The extracted JSON string, or the original text if no JSON block is found.\n */\nfunction extractJsonFromMarkdown(text: string): string {\n    const jsonBlockRegex = /```json\\n([\\s\\S]*?)\\n```/;\n    const match = text.match(jsonBlockRegex);\n    if (match && match[1]) {\n        return match[1].trim();\n    }\n    // If it's not wrapped in a JSON block, assume it's pure JSON and just trim it.\n    return text.trim();\n}\n\n/**\n * Calls the Google Gemini LLM API and processes the structured JSON response.\n *\n * @param input The structured LLMInput object.\n * @returns A promise that resolves to the LLMOutput.\n */\nexport async function callLLM(input: LLMInput, projectRoot: string): Promise<LLMOutput> {\n  const fullPrompt = buildLLMPrompt(input, projectRoot);\n\n  console.log('\\n--- Prompt sent to LLM ---');\n  // console.log(fullPrompt); // Uncomment for debugging the full prompt\n  console.log(`Prompt size: ${fullPrompt.length} characters.`);\n  console.log('--------------------------\\n');\n\n  try {\n    const result = await model.generateContent({\n      contents: [{ role: \"user\", parts: [{ text: fullPrompt }] }],\n      safetySettings,\n      generationConfig: {\n        responseMimeType: \"application/json\",\n      },\n    });\n\n    const response = result.response;\n    let rawText = response.text();\n\n    // Save raw LLM response for debugging and auditing\n    await saveRawLLMResponse(rawText, fullPrompt);\n\n    console.log('\\n--- Raw LLM Response ---');\n    console.log(rawText);\n    console.log('------------------------\\n');\n\n    let cleanedJsonString = extractJsonFromMarkdown(rawText);\n\n    let parsedResult: any; // Use 'any' initially as the top-level structure might vary\n    try {\n      parsedResult = JSON.parse(cleanedJsonString);\n    } catch (jsonError) {\n      console.warn('Warning: Initial JSON parsing failed. Attempting to repair bad escaped characters.');\n      try {\n        const repairedJsonString = repairJsonBadEscapes(cleanedJsonString);\n        parsedResult = JSON.parse(repairedJsonString);\n        console.log('JSON parsing succeeded after repair.');\n      } catch (repairError) {\n        // This is the error path you were seeing due to jsonRepair.ts's previous bug\n        console.error('Error parsing LLM response as JSON even after repair attempt.');\n        console.error('Raw LLM Response before cleaning:', rawText);\n        console.error('Cleaned JSON string attempt:', cleanedJsonString);\n        console.error('Repaired JSON string attempt (which also failed):', (repairError as Error).message);\n        throw new Error(`Invalid JSON response from LLM: ${(jsonError as Error).message}. Repair attempt failed: ${(repairError as Error).message}`);\n      }\n    }\n\n    let llmOutput: LLMOutput;\n\n    // --- Logic to handle array or object structure (already correct) ---\n    if (Array.isArray(parsedResult)) {\n      // If LLM returned an array, assume it's the 'changes' array\n      console.warn(\"LLM returned an array directly instead of the full LLMOutput object. Wrapping it as 'changes'.\");\n      llmOutput = {\n        changes: parsedResult as ProposedFileChange[], // Cast to the expected array type\n        summary: \"Changes proposed by AI (summary not provided by LLM).\", // Default summary\n        thoughtProcess: \"LLM returned only the changes array, so a default summary and thought process are provided.\"\n      };\n    } else if (typeof parsedResult === 'object' && parsedResult !== null) {\n      // If LLM returned an object, validate its structure\n      if (Array.isArray(parsedResult.changes) && typeof parsedResult.summary === 'string') {\n        llmOutput = parsedResult as LLMOutput; // It matches the expected LLMOutput interface\n      } else {\n        // Object, but missing required properties like 'changes' or 'summary'\n        console.error('Parsed LLM output object is missing expected \"changes\" array or \"summary\" string.');\n        console.error('Received object (stringified):', JSON.stringify(parsedResult, null, 2));\n        throw new Error('LLM response object missing expected \"changes\" array or \"summary\" string.');\n      }\n    } else {\n      // Neither an array nor an object, or null\n      console.error('Parsed LLM output is neither an array nor an object, or null:', typeof parsedResult, parsedResult);\n      throw new Error('Invalid top-level JSON structure from LLM. Expected an object or an array.');\n    }\n    // --- End Logic ---\n\n    // Now, `llmOutput` is guaranteed to be an LLMOutput object, proceed with detailed validation of its contents\n    llmOutput.changes.forEach(change => {\n        if (!change.filePath || !['add', 'modify', 'delete'].includes(change.action)) {\n            throw new Error(`Invalid change object found: ${JSON.stringify(change)}. Missing filePath or invalid action.`);\n        }\n        // Warn if newContent is missing for add/modify, but don't stop execution\n        if ((change.action === 'add' || change.action === 'modify') && change.newContent === undefined) {\n             console.warn(`Warning: Change for ${change.filePath} (action: ${change.action}) has undefined newContent. This might be an issue and could lead to empty files.`);\n        }\n    });\n\n    return llmOutput;\n\n  } catch (error: any) {\n    if (error.response && error.response.error) {\n      console.error(`Gemini API Error: ${error.response.error.message}`);\n      if (error.response.error.details) {\n        console.error('Details:', error.response.error.details);\n      }\n      if (error.response.error.status) {\n        console.error('Status:', error.response.error.status);\n      }\n    } else {\n      console.error(`Error calling LLM: ${(error as Error).message}`);\n    }\n    throw new Error(`Failed to get response from LLM: ${(error as Error).message}`);\n  }\n}\n\n```\n\n## Expected Output Format\nYour response must be a JSON object with two top-level keys: 'summary' (string) and 'changes' (array of objects).\nThe 'changes' array should contain objects, each representing a file operation:\n{\n\"filePath\": \"path/to/file.tsx\", // Absolute path (use path.join(projectRoot, relativePath) to construct)\n\"action\": \"add\" | \"modify\" | \"delete\",\n\"newContent\"?: \"...\", // Required for 'add'/'modify', omit for 'delete'\n\"reason\"?: \"...\" // Optional, short explanation for this specific file change\n}\nExample:\n{\n\"summary\": \"Implemented user authentication and updated Navbar component.\",\n\"thoughtProcess\": \"Created new components for login and signup, updated navigation to include auth links, and added a basic auth context.\",\n\"changes\": [\n{\n\"filePath\": \"/path/to/project/src/auth/Login.tsx\",\n\"action\": \"add\",\n\"newContent\": \"import React from 'react';\\nimport { useStore } from '@nanostores/react';\\nimport { authStore } from './authStore';\\n\\nfunction Login() {\\n  const $auth = useStore(authStore);\n// ... login form logic\nreturn <div className='p-4'>Login Form</div>;\\n}\\nexport default Login;\",\n\"reason\": \"New login component for user authentication.\"\n},\n{\n\"filePath\": \"/path/to/project/src/components/Navbar.tsx\",\n\"action\": \"modify\",\n\"newContent\": \"import React from 'react';\\nimport { Link } from 'react-router-dom';\\nimport { useStore } from '@nanostores/react';\\nimport { authStore } from '../auth/authStore';\\n\\nfunction Navbar() {\\n  const $auth = useStore(authStore);\nreturn (\\n    <nav className='bg-blue-500 p-4 text-white flex justify-between'>\\n      <Link to='/' className='font-bold text-lg'>My App</Link>\\n      <div>\\n        {$auth.isLoggedIn ? (\\n          <button onClick={() => authStore.setKey('isLoggedIn', false)} className='ml-4'>Logout</button>\\n        ) : (\\n          <>\n<Link to='/login' className='ml-4'>Login</Link>\\n            <Link to='/signup' className='ml-4'>Signup</Link>\\n          </>\\n        )}\n</div>\\n    </nav>\\n  );\n}\nexport default Navbar;\",\n\"reason\": \"Added login/logout links to Navbar based on authentication status.\"\n},\n{\n\"filePath\": \"/path/to/project/src/old/DeprecatedComponent.ts\",\n\"action\": \"delete\",\n\"reason\": \"Removed unused component as part of refactor.\"\n}\n]\n}\n\n",
  "rawLLMResponse": "[\n  {\n    \"filePath\": \"apps/ai-editor-api/.gitignore\",\n    \"action\": \"add\",\n    \"newContent\": \"node_modules/\\ndist/\\n.env\\n*.log\\n\"\n  },\n  {\n    \"filePath\": \"apps/ai-editor-api/package.json\",\n    \"action\": \"add\",\n    \"newContent\": \"{\\n  \\\"name\\\": \\\"ai-editor-api\\\",\\n  \\\"version\\\": \\\"1.0.0\\\",\\n  \\\"main\\\": \\\"dist/main.js\\\",\\n  \\\"type\\\": \\\"module\\\",\\n  \\\"scripts\\\": {\\n    \\\"dev\\\": \\\"vite dev\\\",\\n    \\\"build\\\": \\\"tsc && vite build\\\",\\    \\\"start\\\": \\\"node dist/main.js\\\"\\n  },\\n  \\\"keywords\\\": [],\\n  \\\"author\\\": \\\"\\\",\\n  \\\"license\\\": \\\"ISC\\\",\\n  \\\"description\\\": \\\"Backend API for AI Editor, powered by Vite and Express.\\\",\\n  \\\"dependencies\\\": {\\n    \\\"@google/generative-ai\\\": \\\"^0.24.1\\\",\\n    \\\"chalk\\\": \\\"^4.1.2\\\",\\n    \\\"commander\\\": \\\"^14.0.0\\\",\\n    \\\"diff\\\": \\\"^8.0.2\\\",\\n    \\\"dotenv\\\": \\\"^17.2.1\\\",\\n    \\\"express\\\": \\\"^4.19.2\\\",\\n    \\\"inquirer\\\": \\\"^12.9.1\\\",\\n    \\\"simple-git\\\": \\\"^3.28.0\\\"\\n  },\\n  \\\"devDependencies\\\": {\\n    \\\"@types/express\\\": \\\"^4.17.21\\\",\\n    \\\"@types/node\\\": \\\"^20.14.11\\\",\\n    \\\"@types/diff\\\": \\\"^7.0.2\\\",\\n    \\\"@types/inquirer\\\": \\\"^9.0.7\\\",\\n    \\\"vite\\\": \\\"^7.1.2\\\",\\n    \\\"typescript\\\": \\\"^5.5.3\\\"\\n  }\\n}\"\n  },\n  {\n    \"filePath\": \"apps/ai-editor-api/tsconfig.json\",\n    \"action\": \"add\",\n    \"newContent\": \"{\\n  \\\"compilerOptions\\\": {\\n    \\\"target\\\": \\\"ES2022\\\",\\n    \\\"lib\\\": [\\\"ES2022\\\"],\\n    \\\"module\\\": \\\"NodeNext\\\",\\n    \\\"moduleResolution\\\": \\\"NodeNext\\\",\\n    \\\"outDir\\\": \\\"./dist\\\",\\n    \\\"rootDir\\\": \\\"./src\\\",\\n    \\\"strict\\\": true,\\n    \\\"esModuleInterop\\\": true,\\n    \\\"skipLibCheck\\\": true,\\n    \\\"forceConsistentCasingInFileNames\\\": true,\\n    \\\"noEmit\\\": false // Allow emit for server builds\\n  },\\n  \\\"include\\\": [\\\"src/**/*.ts\\\"],\\n  \\\"exclude\\\": [\\\"node_modules\\\", \\\"dist\\\"]\\n}\"\n  },\n  {\n    \"filePath\": \"apps/ai-editor-api/vite.config.ts\",\n    \"action\": \"add\",\n    \"newContent\": \"import { defineConfig } from 'vite';\\nimport { resolve } from 'path';\\n\\nexport default defineConfig({\\n  build: {\\n    // Configure Vite to build for Node.js environment\\n    lib: {\\n      entry: resolve(__dirname, 'src/main.ts'),\\n      fileName: 'main',\\n      formats: ['es'] // CommonJS ('cjs') or ES Module ('es')\\n    },\\n    rollupOptions: {\\n      // Externalize Node.js built-in modules and dependencies to avoid bundling them\\n      external: ['express', 'dotenv', 'simple-git', 'inquirer', '@google/generative-ai', 'commander', 'chalk', 'diff', 'fs', 'path', 'url'], // Added 'fs', 'path', 'url' for built-ins\\n    },\\n    // Output directory for the server build\\n    outDir: 'dist',\\n    emptyOutDir: true,\\n  },\\n  // Configure Vite's dev server if needed, though typically Node.js server runs separately\\n  server: {\\n    port: 3001, // Default port for the API server\\n  }\\n});\"\n  },\n  {\n    \"filePath\": \"apps/ai-editor-api/src/main.ts\",\n    \"action\": \"add\",\n    \"newContent\": \"import 'dotenv/config'; // Load environment variables from .env\\nimport express from 'express';\\nimport { fileURLToPath } from 'url';\\nimport { dirname, resolve as pathResolve } from 'path';\\nimport { scanProject } from '../../src/scanner';\\nimport { prepareContextForLLM } from '../../src/llm/contextPreparer'; // buildLLMPrompt is internal to callLLM now\\nimport { callLLM } from '../../src/llm/llmOrchestrator';\\nimport { applyFileChange } from '../../src/file-operations/fileApplier';\\nimport type { ProposedFileChange, LLMInput } from '../../src/types';\\n\\nconst __filename = fileURLToPath(import.meta.url);\\nconst __dirname = dirname(__filename);\\n\\n// Determine the project root from the API server's perspective\\n// Assuming the API server is run from the monorepo root (or its build output is there)\\nconst PROJECT_ROOT = pathResolve(__dirname, '../..'); \\n\\nconst app = express();\\nconst PORT = process.env.PORT || 3001;\\n\\napp.use(express.json()); // Middleware to parse JSON request bodies\\n\\n// Log incoming requests for debugging\\napp.use((req, res, next) => {\\n  console.log(`[API] ${req.method} ${req.path}`);\\n  next();\\n});\\n\\n// Health check endpoint\\napp.get('/health', (req, res) => {\\n  res.status(200).send('API is healthy');\\n});\\n\\n// --- API Endpoints for AI Editor Functionality ---\\n\\n// Endpoint to generate text/code using LLM\\napp.post('/gemini/file/generate-text', async (req, res) => {\\n  const { prompt, scanDirectories, scanFiles } = req.body; // Removed systemInstruction, conversationId as they are not used directly in this flow\\n\\n  if (!prompt) {\\n    return res.status(400).json({ message: 'Prompt is required.' });\\n  }\\n\\n  console.log(`[API] Received generate-text request for prompt: \\\"${prompt.substring(0, 50)}...\\\"`);\\n\\n  try {\\n    let allScanPaths: string[] = [];\\n\\n    // If scanDirectories or scanFiles are provided, use them\\n    if (scanDirectories && Array.isArray(scanDirectories) && scanDirectories.length > 0) {\\n        allScanPaths = allScanPaths.concat(scanDirectories);\\n    }\\n    if (scanFiles && Array.isArray(scanFiles) && scanFiles.length > 0) {\\n        allScanPaths = allScanPaths.concat(scanFiles);\\n    }\\n\\n    // If no specific scan paths are provided (empty arrays after concat), default to scanning the whole project root\\n    if (allScanPaths.length === 0) {\\n        allScanPaths = ['.']; \\n    }\\n\\n    console.log(`[API] Scanning project with paths: ${allScanPaths.join(', ')} (relative to ${PROJECT_ROOT})`);\\n    const scannedFiles = await scanProject(allScanPaths, PROJECT_ROOT);\\n    console.log(`[API] Scanned ${scannedFiles.length} files for context.`);\\n\\n    const llmInput: LLMInput = prepareContextForLLM(prompt, scannedFiles, PROJECT_ROOT);\\n\\n    const llmOutput = await callLLM(llmInput, PROJECT_ROOT); // Pass projectRoot to LLM orchestrator\\n    res.json(llmOutput);\\n  } catch (error: any) {\\n    console.error('[API] Error generating text:', error);\\n    res.status(500).json({ message: 'Failed to generate text.', error: error.message });\\n  }\\n});\\n\\n// Endpoint to create a file\\napp.post('/file/create', async (req, res) => {\\n  const { filePath, isDirectory, content } = req.body; // isDirectory is ignored as we only create files here\\n\\n  if (!filePath || content === undefined) { // content can be empty string\\n    return res.status(400).json({ message: 'filePath and content are required for file creation.' });\\n  }\\n\\n  const change: ProposedFileChange = {\\n    filePath: filePath, // This filePath is expected to be relative from the frontend\\n    action: 'add',\\n    newContent: content,\\n  };\\n\\n  try {\\n    await applyFileChange(PROJECT_ROOT, change);\\n    res.status(200).json({ message: `File ${filePath} created successfully.` });\\n  } catch (error: any) {\\n    console.error('[API] Error creating file:', error);\\n    res.status(500).json({ message: 'Failed to create file.', error: error.message });\\n  }\\n});\\n\\n// Endpoint to write (modify) a file\\napp.post('/file/write', async (req, res) => {\\n  const { filePath, content } = req.body;\\n\\n  if (!filePath || content === undefined) { // content can be empty string\\n    return res.status(400).json({ message: 'filePath and content are required for file modification.' });\\n  }\\n\\n  const change: ProposedFileChange = {\\n    filePath: filePath, // This filePath is expected to be relative from the frontend\\n    action: 'modify',\\n    newContent: content,\\n  };\\n\\n  try {\\n    await applyFileChange(PROJECT_ROOT, change);\\n    res.status(200).json({ message: `File ${filePath} modified successfully.` });\\n  } catch (error: any) {\\n    console.error('[API] Error modifying file:', error);\\n    res.status(500).json({ message: 'Failed to modify file.', error: error.message });\\n  }\\n});\\n\\n// Endpoint to delete a file\\napp.post('/file/delete', async (req, res) => {\\n  const { filePath } = req.body;\\n\\n  if (!filePath) {\\n    return res.status(400).json({ message: 'filePath is required for file deletion.' });\\n  }\\n\\n  const change: ProposedFileChange = {\\n    filePath: filePath, // This filePath is expected to be relative from the frontend\\n    action: 'delete',\\n  };\\n\\n  try {\\n    await applyFileChange(PROJECT_ROOT, change);\\n    res.status(200).json({ message: `File ${filePath} deleted successfully.` });\\n  } catch (error: any) {\\n    console.error('[API] Error deleting file:', error);\\n    res.status(500).json({ message: 'Failed to delete file.', error: error.message });\\n  }\\n});\\n\\napp.listen(PORT, () => {\\n  console.log(`AI Editor API server listening on port ${PORT} with PROJECT_ROOT: ${PROJECT_ROOT}`);\\n  console.log('Ensure GOOGLE_GEMINI_API_KEY is set in your .env file in the monorepo root.');\\n});\"\n  },\n  {\n    \"filePath\": \"package.json\",\n    \"action\": \"modify\",\n    \"newContent\": \"{\\n  \\\"name\\\": \\\"ai-editor\\\",\\n  \\\"version\\\": \\\"1.0.0\\\",\\n  \\\"main\\\": \\\"index.js\\\",\\n  \\\"scripts\\\": {\\n    \\\"start\\\": \\\"ts-node src/index.ts\\\",\\n    \\\"build\\\": \\\"tsc\\\",\\n    \\\"test\\\": \\\"echo \\\\\\\"Error: no test specified\\\\\\\" && exit 1\\\",\\n    \\\"lint\\\": \\\"eslint .\\\",\\n    \\\"dev:front\\\": \\\"npm run dev --workspace apps/ai-editor-front\\\",\\n    \\\"build:front\\\": \\\"npm run build --workspace apps/ai-editor-front\\\",\\n    \\\"preview:front\\\": \\\"npm run preview --workspace apps/ai-editor-front\\\",\\n    \\\"dev:api\\\": \\\"npm run dev --workspace apps/ai-editor-api\\\",\\n    \\\"build:api\\\": \\\"npm run build --workspace apps/ai-editor-api\\\",\\n    \\\"start:api\\\": \\\"npm run start --workspace apps/ai-editor-api\\\"\\n  },\\n  \\\"keywords\\\": [],\\n  \\\"author\\\": \\\"\\\",\\n  \\\"license\\\": \\\"ISC\\\",\\n  \\\"description\\\": \\\"\\\",\\n  \\\"devDependencies\\\": {\\n    \\\"@types/diff\\\": \\\"^7.0.2\\\",\\n    \\\"ts-node\\\": \\\"^10.9.2\\\",\\n    \\\"typescript\\\": \\\"^5.9.2\\\",\\n    \\\"eslint\\\": \\\"^9.x.x\\\",\\n    \\\"@eslint/js\\\": \\\"^9.x.x\\\",\\n    \\\"typescript-eslint\\\": \\\"^8.x.x\\\",\\n    \\\"eslint-plugin-prettier\\\": \\\"^5.x.x\\\",\\n    \\\"eslint-config-prettier\\\": \\\"^9.x.x\\\",\\n    \\\"globals\\\": \\\"^15.x.x\\\"\\n  },\\n  \\\"dependencies\\\": {\\n    \\\"@google/generative-ai\\\": \\\"^0.24.1\\\",\\n    \\\"chalk\\\": \\\"^4.1.2\\\",\\n    \\\"commander\\\": \\\"^14.0.0\\\",\\n    \\\"diff\\\": \\\"^8.0.2\\\",\\n    \\\"dotenv\\\": \\\"^17.2.1\\\",\\n    \\\"inquirer\\\": \\\"^12.9.1\\\",\\n    \\\"simple-git\\\": \\\"^3.28.0\\\"\\n  },\\n  \\\"workspaces\\\": [\\n    \\\"apps/*\\\"\\n  ]\\n}\"\n  },\n  {\n    \"filePath\": \"README.md\",\n    \"action\": \"modify\",\n    \"newContent\": \"# AI Editor\\n\\nAn AI-powered tool for editing and updating code files, designed as a monorepo containing both a CLI tool and a React-based frontend application.\\n\\n## Monorepo Structure\\n\\nThis project is organized as a monorepo:\\n\\n-   **`/` (Root):** Contains shared configurations, overall documentation, and the core AI-editing CLI tool.\\n-   **`apps/ai-editor-front/`:** Houses the React/TypeScript/Tailwind CSS frontend application.\\n-   **`apps/ai-editor-api/`:** Houses the Node.js API server for AI editor functionality.\\n-   **`docs/`:** Contains detailed documentation and setup guides.\\n\\n## Features (CLI Tool)\\n\\n-   Scans specified project directories for relevant code files.\\n-   Prepares context for an LLM by structuring the user prompt, relevant files, and system instructions.\\n-   Calls the LLM (Google Gemini) to generate proposed changes in a structured JSON format.\\n-   Generates human-readable diffs between original and proposed content.\\n-   Applies file changes (add, modify, delete) to the file system.\\n-   Integrates with Git for automated branch creation and staging changes.\\n\\n## Getting Started\\n\\n### Prerequisites\\n\\n-   Node.js (version >= 18)\\n-   npm or yarn\\n-   A Google Gemini API key (set as `GOOGLE_GEMINI_API_KEY` environment variable). See [Setting up Google Gemini API Key](docs/google-gemini-setup.md) for detailed instructions.\\n\\n### Installation\\n\\nNavigate to the root of the project and install dependencies:\\n\\n```bash\\nnpm install\\n# or yarn install\\n```\\n\\n### Usage\\n\\n#### AI Editor CLI Tool\\n\\nRun the CLI tool from the project root:\\n\\n1.  **Scan files or directories:**\\n\\n    ```bash\\nts-node src/index.ts scan [paths...]\\n    ```\\n\\n    Examples:\\n\\n    ```bash\\nts-node src/index.ts scan .\\nts-node src/index.ts scan apps/ai-editor-front/src/components\\nts-node src/index.ts scan . --verbose\\nts-node src/index.ts scan src --show-content\\nts-node src/index.ts scan . --verbose --show-content\\n    ```\\n\\n2.  **Generate code based on a prompt:**\\n\\n    ```bash\\nts-node src/index.ts generate \\\"Your prompt here\\\"\\n    ```\\n\\n    Examples:\\n\\n    ```bash\\nts-node src/index.ts generate \\\"Add a user profile component\\\"\\nts-node src/index.ts generate \\\"Implement a dark mode toggle\\\" --scan-dirs apps/ai-editor-front/src/ui\\nts-node src/index.ts generate \\\"Add user authentication flow\\\" --yes\\nts-node src/index.ts generate \\\"Refactor old utility functions\\\" --no-git\\nts-node src/index.ts generate \\\"Create a new Dashboard component\\\" --branch feature/dashboard-v2\\n    ```\\n\\n##### CLI Options\\n\\n-   `-p, --path <path>`: (for `generate` command) Specify the project root directory (default: current working directory). This is where Git operations and file resolution will be based.\\n-   `--scan-dirs <dirs...>`: (for `generate` command) Space-separated list of directories to scan within the project root (e.g., \\\"src apps/ai-editor-front/src\\\").\\n-   `--scan-files <files...>`: (for `generate` command) Space-separated list of individual file paths to scan within the project root (e.g., \\\"src/App.tsx apps/ai-editor-front/src/main.tsx\\\").\\n-   `-y, --yes`: (for `generate` command) Automatically confirm all proposed changes without prompting (USE WITH CAUTION!).\\n-   `--no-git`: (for `generate` command) Skip all Git operations (branching, staging).\\n-   `--branch <name>`: (for `generate` command) Specify a branch name to create/checkout. If not provided, a default is suggested.\\n-   `-v, --verbose`: (for `scan` command) Output detailed information during scan.\\n-   `-s, --show-content`: (for `scan` command) Show a snippet of file content for sample files.\\n\\n#### AI Editor Frontend Application\\n\\nTo run the interactive web application:\\n\\n```bash\\n# From the monorepo root\\nnpm run dev:front\\n# or from within the app directory\\n# cd apps/ai-editor-front\\n# npm run dev\\n```\\n\\nFor more details on the frontend application, refer to its dedicated README: [apps/ai-editor-front/README.md](apps/ai-editor-front/README.md)\\n\\n#### AI Editor API Server\\n\\nThis is a Node.js Express server that exposes the core AI editing functionalities (scanning, LLM generation, file operations) via REST API endpoints.\\n\\nTo run the API server:\\n\\n1.  **Set up environment variables:** Create a `.env` file in the monorepo root (where `package.json` is located) and define your `GOOGLE_GEMINI_API_KEY` and optionally `PORT`:\\n    ```dotenv\\n    GOOGLE_GEMINI_API_KEY=\\\"YOUR_GEMINI_API_KEY\\\"\\n    PORT=3001 # Optional, defaults to 3001\\n    ```\\n2.  **Start the server:**\\n    ```bash\\n    # From the monorepo root\\n    npm run dev:api\\n    # In a separate terminal, start the frontend as well\\n    npm run dev:front\\n    ```\\n\\nFor more details on the API server, refer to its dedicated README: [apps/ai-editor-api/README.md](apps/ai-editor-api/README.md)\\n\\n## Development\\n\\n### Running the project (CLI)\\n\\n```bash\\nnpm start # Equivalent to ts-node src/index.ts\\n```\\n\\n### Building the project (CLI)\\n\\n```bash\\nnpm run build\\n```\\n\\n## File Structure (Root)\\n\\n```\\n.\\n├── CONTRIBUTING.md\\n├── README.md\\n├── apps\\n│   ├── ai-editor-api\\n│   │   └── README.md # API server-specific README (will be created)\\n│   └── ai-editor-front\\n│       └── README.md # Frontend-specific README\\n├── docs\\n│   ├── developer-guide.md\\n│   └── google-gemini-setup.md\\n├── eslint.config.ts\\n├── package.json\\n├── src # Core CLI Tool Source\\n│   ├── file-operations\\n│   ├── git-operations\\n│   ├── index.ts\\n│   ├── llm\\n│   ├── scanner.ts\\n│   └── types.ts\\n└── tsconfig.json\\n```\\n\\nFor a more detailed breakdown of the CLI tool's architecture, see the [Developer Guide](docs/developer-guide.md).\\n\\n## Dependencies\\n\\n(See `package.json` for full list)\\n\\n-   `@google/generative-ai`: Google Gemini API client.\\n-   `chalk`: For colorful console output.\\n-   `commander`: For building command-line interfaces.\\n-   `diff`: For generating text diffs.\\n-   `dotenv`: For loading environment variables.\\n-   `inquirer`: For interactive command-line prompts.\\n-   `simple-git`: For Git operations.\\n-   `express`: (For API server) Fast, unopinionated, minimalist web framework for Node.js.\\n\\n## Contributing\\n\\nWe welcome contributions! Please see [CONTRIBUTING.md](CONTRIBUTING.md) for guidelines.\\n\\n## License\\n\\nThis project is licensed under the ISC License. See [LICENSE](LICENSE) for details.\\n\"\n  },\n  {\n    \"filePath\": \"apps/ai-editor-front/vite.config.ts\",\n    \"action\": \"modify\",\n    \"newContent\": \"import { defineConfig, loadEnv } from \\\"vite\\\";\\nimport react from \\\"@vitejs/plugin-react\\\";\\nimport tailwindcss from \\\"@tailwindcss/vite\\\";\\nimport path from \\\"path\\\";\\n\\nexport default defineConfig(({ mode }) => {\\n  const env = loadEnv(mode, process.cwd());\\n\\n  return {\\n    plugins: [react(), tailwindcss()],\\n    resolve: {\\n      alias: {\\n        \\\"@\\\": path.resolve(__dirname, \\\"src\\\"),\\n        \\\"@components\\\": path.resolve(__dirname, \\\"src/components\\\"),\\n        \\\"@contexts\\\": path.resolve(__dirname, \\\"src/contexts\\\"),\\n        \\\"@hooks\\\": path.resolve(__dirname, \\\"src/hooks\\\"),\\n        \\\"@utils\\\": path.resolve(__dirname, \\\"src/utils\\\"),\\n        \\\"@services\\\": path.resolve(__dirname, \\\"src/services\\\"),\\n        \\\"@stores\\\": path.resolve(__dirname, \\\"src/stores\\\"),\\n        \\\"@providers\\\": path.resolve(__dirname, \\\"src/providers\\\"),\\n        \\\"@types\\\": path.resolve(__dirname, \\\"src/types\\\"),\\n        \\\"@styles\\\": path.resolve(__dirname, \\\"src/styles\\\"),\\n        \\\"@libs\\\": path.resolve(__dirname, \\\"src/libs\\\"),\\n        \\\"@routes\\\": path.resolve(__dirname, \\\"src/routes\\\"),\\n        \\\"@themes\\\": path.resolve(__dirname, \\\"src/themes\\\"),\\n        \\\"@constants\\\": path.resolve(__dirname, \\\"src/constants\\\"),\\n      },\\n    },\\n    build: {\\n      chunkSizeWarningLimit: 1000,\\n    },\\n    server: {\\n      port: 5173,\\n      proxy: {\\n        \\\"/api\\\": {\\n          target: env.VITE_API_URL || 'http://localhost:3001', // Default to new API port\\n          changeOrigin: true,\\n          rewrite: (path) => path.replace(/^\\\\/api/, \\\"\\\"),\\n        },\\n\\n        \\\"/socket.io\\\": {\\n          target: env.VITE_API_URL || 'http://localhost:3001',\\n          changeOrigin: true,\\n          ws: true,\\n        },\\n      },\\n      cors: {\\n        origin: [\\\"*\\\"],\\n        methods: [\\\"GET\\\", \\\"POST\\\", \\\"OPTIONS\\\"],\\n        allowedHeaders: [\\\"Content-Type\\\", \\\"Authorization\\\"],\\n        credentials: true,\\n      },\\n      allowedHosts: [\\\"board-api.duckdns.org\\\", \\\"localhost\\\"],\\n    },\\n    define: {\\n      \\\"process.env.NODE_ENV\\\": JSON.stringify(mode),\\n      \\\"import.meta.env.BASE_URL_API\\\": JSON.stringify(env.BASE_URL),\\n      // Removed PROJECT_ROOT as it's now handled by the API server\\n      \\\"import.meta.env.GITHUB_CALLBACK_URL\\\": JSON.stringify(\\n        env.GITHUB_CALLBACK_URL,\\n      ),\\n      \\\"import.meta.env.GOOGLE_CALLBACK_URL\\\": JSON.stringify(\\n        env.GOOGLE_CALLBACK_URL,\\n      ),\\n    },\\n  };\\n});\"\n  },\n  {\n    \"filePath\": \"apps/ai-editor-front/src/vite-env.d.ts\",\n    \"action\": \"modify\",\n    \"newContent\": \"/// <reference types=\\\"vite/client\\\" />\\n\\ninterface ImportMetaEnv {\\n  readonly VITE_API_URL: string;\\n  readonly GITHUB_CALLBACK_URL: string;\\n  readonly GOOGLE_CALLBACK_URL: string;\\n}\\n\\ninterface ImportMeta {\\n  readonly env: ImportMetaEnv;\\n}\"\n  },\n  {\n    \"filePath\": \"apps/ai-editor-front/src/pages/AiEditorPage.tsx\",\n    \"action\": \"modify\",\n    \"newContent\": \"import { useState, useCallback } from \\\"react\\\";\\nimport { Link } from \\\"react-router-dom\\\";\\nimport { Button } from \\\"../components/Button\\\";\\nimport { INSTRUCTION, ADDIONAL_INSTRUCTION_EXPECTED_OUTPUT } from \\\"../constants\\\"; // Import constants\\nimport { extractJsonFromMarkdown, repairJsonBadEscapes } from \\\"../utils\\\"; // Import utility functions. joinPaths is no longer needed here.\\nimport type {\\n  FrontendProposedFileChange,\\n  LLMOutput,\\n} from \\\"../types\\\";\\n\\n// Backend DTO type for generate-text matching ../../full-stack/src/google/google-gemini/google-gemini-file/dto/generate-text.dto.ts\\ninterface GenerateTextDto {\\n  prompt: string;\\n  systemInstruction?: string;\\n  conversationId?: string;\\n  scanDirectories?: string[];\\n  scanFiles?: string[]; // NEW: Add an optional field for specific files to scan\\n}\\n\\n// Define a type for the AI response that can be either structured LLMOutput or raw text\\ntype AiResponseContent = LLMOutput | string | null;\\n\\n// Component for displaying a single proposed file change\\ninterface FileChangeDisplayProps {\\n  change: FrontendProposedFileChange;\\n  onStatusChange: (\\n    filePath: string,\\n    status: \\\"pending\\\" | \\\"accepted\\\" | \\\"rejected\\\",\\n  ) => void;\\n}\\n\\nfunction FileChangeDisplay({ change, onStatusChange }: FileChangeDisplayProps) {\\n  const {\\n    filePath,\\n    action,\\n    newContent,\\n    reason,\\n    status,\\n  } = change;\\n\\n  const statusClasses = {\\n    pending: \\\"border-blue-400 text-blue-200\\\",\\n    accepted: \\\"border-green-400 text-green-200\\\",\\n    rejected: \\\"border-red-400 text-red-200\\\",\\n  };\\n\\n  return (\\n    <div\\n      className={`p-4 mb-4 rounded-lg border ${statusClasses[status]} shadow-lg bg-gray-800`}\\n    >\\n      <div className=\\\"flex justify-between items-center mb-2 flex-wrap\\\">\\n        <h3 className=\\\"text-xl font-semibold flex-grow min-w-0\\\">\\n          <span className=\\\"font-mono text-indigo-300 break-all\\\">\\n            {filePath}\\n          </span>\\n          <span\\n            className={`ml-3 px-2 py-1 rounded-full text-xs font-bold ${\\n              action === \\\"add\\\"\\n                ? \\\"bg-green-600\\\"\\n                : action === \\\"modify\\\"\\n                  ? \\\"bg-yellow-600\\\"\\n                  : \\\"bg-red-600\\\"\\n            }`}\\n          >\\n            {action.toUpperCase()}\\n          </span>\\n        </h3>\\n        <div className=\\\"flex space-x-2 mt-2 md:mt-0 flex-shrink-0\\\">\\n          <Button\\n            className={`text-sm px-3 py-1 ${status === \\\"accepted\\\" ? \\\"bg-green-700\\\" : \\\"bg-gray-700 hover:bg-green-600\\\"}`}\\n            onClick={() => onStatusChange(filePath, \\\"accepted\\\")}\\n            disabled={status === \\\"accepted\\\"}\\n          >\\n            Accept\\n          </Button>\\n          <Button\\n            className={`text-sm px-3 py-1 ${status === \\\"rejected\\\" ? \\\"bg-red-700\\\" : \\\"bg-gray-700 hover:bg-red-600\\\"}`}\\n            onClick={() => onStatusChange(filePath, \\\"rejected\\\")}\\n            disabled={status === \\\"rejected\\\"}\\n          >\\n            Reject\\n          </Button>\\n          <Button\\n            className={`text-sm px-3 py-1 ${status === \\\"pending\\\" ? \\\"bg-blue-700\\\" : \\\"bg-gray-700 hover:bg-blue-600\\\"}`}\\n            onClick={() => onStatusChange(filePath, \\\"pending\\\")}\\n            disabled={status === \\\"pending\\\"}\\n          >\\n            Reset\\n          </Button>\\n        </div>\\n      </div>\\n      {reason && <p className=\\\"text-sm text-gray-400 mb-2\\\">Reason: {reason}</p>}\\n\\n      {action === \\\"add\\\" && newContent && (\\n        <div>\\n          <h4 className=\\\"font-medium text-gray-300 mb-1\\\">New Content:</h4>\\n          <pre className=\\\"bg-gray-900 p-3 rounded-md overflow-auto text-xs text-gray-200\\\">\\n            <code>{newContent}</code>\\n          </pre>\\n        </div>\\n      )}\\n\\n      {action === \\\"modify\\\" && (\\n        <div className=\\\"flex flex-col md:flex-row gap-4\\\">\\n          <div className=\\\"flex-1\\\">\\n            {/* Original content cannot be displayed dynamically if not provided by the AI response */}\\n            <h4 className=\\\"font-medium text-gray-300 mb-1\\\">\\n              Original Content: (Not available from AI response)\\n            </h4>\\n            <pre className=\\\"bg-gray-900 p-3 rounded-md overflow-auto text-xs text-gray-200\\\">\\n              <code>{/* Placeholder or fetch from backend if available */}\\n              </code>\\n            </pre>\\n          </div>\\n          <div className=\\\"flex-1\\\">\\n            <h4 className=\\\"font-medium text-gray-300 mb-1\\\">New Content:</h4>\\n            <pre className=\\\"bg-gray-900 p-3 rounded-md overflow-auto text-xs text-gray-200\\\">\\n              <code>{newContent}</code>\\n            </pre>\\n          </div>\\n        </div>\\n      )}\\n\\n      {action === \\\"delete\\\" && (\\n        <p className=\\\"text-red-300 italic\\\">This file will be deleted.</p>\\n      )}\\n    </div>\\n  );\\n}\\n\\nexport function AiEditorPage() {\\n  const [prompt, setPrompt] = useState<string>(\\n    // Initial user-facing prompt. The full instruction and output format will be combined later.\\n    \\\"Generate TypeScript code to implement a simple React component that displays a welcome message. The component should be named WelcomeMessage.tsx and export a functional component.\\\",\\n  );\\n  // State for directories to scan\\n  const [scanDirectories, setScanDirectories] = useState<string>(\\n    \\\"apps/ai-editor-front/src\\\", // Default to the app's src directory\\n  );\\n  // NEW: State for individual files to scan\\n  const [scanFiles, setScanFiles] = useState<string>(\\\"\\\");\\n\\n  const [isLoading, setIsLoading] = useState(false);\\n  const [aiResponseContent, setAiResponseContent] = useState<AiResponseContent>(null);\\n  const [proposedChanges, setProposedChanges] = useState<FrontendProposedFileChange[]>(\\n    [],\\n  );\\n\\n  const handleGenerateClick = useCallback(async () => {\\n    if (!prompt.trim()) {\\n      alert(\\\"Please enter a prompt.\\\");\\n      return;\\n    }\\n\\n    setIsLoading(true);\\n    setAiResponseContent(null);\\n    setProposedChanges([]);\\n\\n    // Prepare scan directories and files from comma-separated strings\\n    const directoriesToScan = scanDirectories\\n      .split(\\\",\\\")\\n      .map((dir) => dir.trim())\\n      .filter((dir) => dir !== \\\"\\\");\\n\\n    const filesToScan = scanFiles\\n      .split(\\\",\\\")\\n      .map((file) => file.trim())\\n      .filter((file) => file !== \\\"\\\");\\n\\n    try {\\n      const generateTextDto: GenerateTextDto = {\\n        prompt: `# User Request:\\\\n${prompt.trim()}`,\\n        systemInstruction: `${INSTRUCTION}\\\\n\\\\n${ADDIONAL_INSTRUCTION_EXPECTED_OUTPUT}`,\\n        scanDirectories: directoriesToScan.length > 0 ? directoriesToScan : undefined,\\n        scanFiles: filesToScan.length > 0 ? filesToScan : undefined,\\n      };\\n\\n      // Call the backend's generate-text endpoint\\n      const response = await fetch(\\\"/api/gemini/file/generate-text\\\", {\\n        method: \\\"POST\\\",\\n        headers: {\\n          \\\"Content-Type\\\": \\\"application/json\\\",\\n        },\\n        body: JSON.stringify(generateTextDto),\\n      });\\n\\n      if (!response.ok) {\\n        const errorData = await response.json();\\n        throw new Error(\\n          errorData.message || `HTTP error! status: ${response.status}`,\\n        );\\n      }\\n\\n      const aiRawResponseText: string = await response.text(); // Renamed for clarity\\n      console.log(\\\"Raw AI response:\\\", aiRawResponseText);\\n\\n      try {\\n        // 1. Extract potential JSON from markdown block\\n        const extractedJsonString = extractJsonFromMarkdown(aiRawResponseText);\\n        console.log(\\\"Extracted JSON string:\\\", extractedJsonString);\\n\\n        // 2. Attempt to repair common bad escape sequences\\n        const repairedJsonString = repairJsonBadEscapes(extractedJsonString);\\n        console.log(\\\"Repaired JSON string:\\\", repairedJsonString);\\n\\n        let parsedResponse: LLMOutput;\\n        try {\\n          // Attempt to parse the repaired string as LLMOutput JSON\\n          parsedResponse = JSON.parse(repairedJsonString);\\n        } catch (parseError) {\\n          // If parsing fails after repair, log and set as raw text\\n          console.error(\\\"Failed to parse repaired AI response as JSON:\\\", parseError);\\n          setAiResponseContent(aiRawResponseText); // Fallback to original raw text\\n          return; // Exit early if parsing failed\\n        }\\n\\n        // Basic validation to check if it looks like an LLMOutput\\n        if (\\n          parsedResponse &&\\n          Array.isArray(parsedResponse.changes) &&\\n          typeof parsedResponse.summary === \\\"string\\\"\\n        ) {\\n          setAiResponseContent(parsedResponse);\\n          // Initialize proposed changes with 'pending' status\\n          const initialChanges: FrontendProposedFileChange[] = parsedResponse.changes.map((change) => ({\\n            ...change,\\n            status: \\\"pending\\\",\\n          }));\\n          setProposedChanges(initialChanges);\\n        } else {\\n          // If parsing succeeded but didn't match LLMOutput structure\\n          setAiResponseContent(\\n            \\\"AI response was structured but not in the expected file change format.\\\\n\\\" + aiRawResponseText,\\n          );\\n        }\\n      } catch (error) {\\n        // Catch any errors from extraction or repair functions, or initial response processing\\n        console.error(\\\"Error processing AI response (extraction/repair stage):\\\");\\n        setAiResponseContent(aiRawResponseText); // Always fall back to raw text on any processing error\\n      }\\n    } catch (error) {\\n      console.error(\\\"Error generating AI response:\\\", error);\\n      alert(`Failed to generate response: ${(error as Error).message}`);\\n    } finally {\\n      setIsLoading(false);\\n    }\\n  }, [prompt, scanDirectories, scanFiles]); // Add scanFiles to dependency array\\n\\n  const handleStatusChange = useCallback(\\n    (filePath: string, status: \\\"pending\\\" | \\\"accepted\\\" | \\\"rejected\\\") => {\\n      setProposedChanges((prevChanges) =>\\n        prevChanges.map((change) =>\\n          change.filePath === filePath ? { ...change, status } : change,\\n        ),\\n      );\\n    },\\n    [],\\n  );\\n\\n  const handleApplyChanges = useCallback(async () => {\\n    const acceptedChanges = proposedChanges.filter(\\n      (change) => change.status === \\\"accepted\\\",\\n    );\\n    if (acceptedChanges.length === 0) {\\n      alert(\\\"No changes accepted to apply.\\\");\\n      return;\\n    }\\n\\n    setIsLoading(true); // Indicate that changes are being applied\\n\\n    // The frontend sends relative paths, the backend handles resolving them to absolute paths.\\n\\n    const operations: Promise<Response>[] = [];\\n    const successfulChanges: string[] = [];\\n    const failedChanges: { filePath: string; error: string }[] = [];\\n\\n    for (const change of acceptedChanges) {\\n      // change.filePath is already relative, as per LLMOutput type\\n      const filePathToSend = change.filePath;\\n\\n      let apiCall: Promise<Response>;\\n      switch (change.action) {\\n        case \\\"add\\\":\\n          apiCall = fetch(\\\"/api/file/create\\\", {\\n            method: \\\"POST\\\",\\n            headers: { \\\"Content-Type\\\": \\\"application/json\\\" },\\n            body: JSON.stringify({\\n              filePath: filePathToSend,\\n              isDirectory: false,\\n              content: change.newContent || \\\"\\\", // Provide empty string if content is undefined\\n            }),\\n          });\\n          break;\\n        case \\\"modify\\\":\\n          apiCall = fetch(\\\"/api/file/write\\\", {\\n            method: \\\"POST\\\",\\n            headers: { \\\"Content-Type\\\": \\\"application/json\\\" },\\n            body: JSON.stringify({\\n              filePath: filePathToSend,\\n              content: change.newContent || \\\"\\\", // Provide empty string if content is undefined\\n            }),\\n          });\\n          break;\\n        case \\\"delete\\\":\\n          apiCall = fetch(\\\"/api/file/delete\\\", {\\n            method: \\\"POST\\\",\\n            headers: { \\\"Content-Type\\\": \\\"application/json\\\" },\\n            body: JSON.stringify({ filePath: filePathToSend }),\\n          });\\n          break;\\n        default:\\n          console.warn(`Unknown action type: ${change.action} for ${change.filePath}. Skipping.`);\\n          continue; // Skip unknown actions\\n      }\\n\\n      operations.push(apiCall.then(async (response) => {\\n        if (!response.ok) {\\n          const errorData = await response.json();\\n          throw new Error(errorData.message || `HTTP error! status: ${response.status}`);\\n        }\\n        successfulChanges.push(change.filePath); // Track successful changes\\n        return response;\\n      }).catch(error => {\\n        failedChanges.push({ filePath: change.filePath, error: error.message }); // Track failed changes\\n        console.error(`Failed to apply change for ${change.filePath}:`, error);\\n        // Do NOT re-throw here, as Promise.all should resolve even if some fail\\n        // We're handling individual errors and collecting them.\\n      }));\\n    }\\n\\n    try {\\n      await Promise.all(operations); // Wait for all promises to settle (even if some caught errors)\\n\\n      if (failedChanges.length === 0) {\\n        alert(`Successfully applied ${successfulChanges.length} changes.`);\\n      } else {\\n        alert(\\n          `Applied ${successfulChanges.length} changes, but ${failedChanges.length} failed.\\\\n` +\\n          `Failed files:\\\\n${failedChanges.map(f => `  - ${f.filePath}: ${f.error}`).join('\\\\n')}`\\n        );\\n      }\\n\\n      // Reset state after attempting all applications\\n      setAiResponseContent(null);\\n      setProposedChanges([]);\\n      setPrompt(\\\"\\\");\\n\\n    } catch (error) {\\n      // This catch block would only be hit if one of the promises in 'operations'\\n      // did not have its error caught and re-threw it, causing Promise.all to reject.\\n      // With the individual .catch blocks, this specific catch might be less frequently hit,\\n      // but it's good to keep for robustness.\\n      console.error(\\\"An unexpected error occurred during application of changes:\\\", error);\\n      alert(`An unexpected error occurred: ${(error as Error).message}`);\\n    } finally {\\n      setIsLoading(false);\\n    }\\n  }, [proposedChanges]);\\n\\n  const acceptedCount = proposedChanges.filter(\\n    (c) => c.status === \\\"accepted\\\",\\n  ).length;\\n\\n  const isLlmOutput = (content: AiResponseContent): content is LLMOutput => {\\n    return (\\n      content !== null &&\\n      typeof content === \\\"object\\\" &&\\n      \\\"changes\\\" in content &&\\n      Array.isArray(content.changes) &&\\n      \\\"summary\\\" in content &&\\n      typeof content.summary === \\\"string\\\"\\n    );\\n  };\\n\\n  return (\\n    <div className=\\\"flex flex-col flex-grow p-4 md:p-8 max-w-full lg:max-w-7xl mx-auto w-full\\\">\\n      <h1 className=\\\"text-4xl font-bold text-white mb-6 text-center\\\">\\n        AI Editor <span className=\\\"text-indigo-400\\\">Frontend</span>\\n      </h1>\\n\\n      {/* Directory/File Scanning Input Section */}\\n      <div className=\\\"p-6 bg-gray-800 rounded-lg shadow-xl border border-gray-700 mb-8\\\">\\n        <h2 className=\\\"text-2xl font-semibold text-indigo-300 mb-4\\\">\\n          Context Files for AI (Optional)\\n        </h2>\\n        <label htmlFor=\\\"scanDirectories\\\" className=\\\"block text-gray-300 text-sm font-bold mb-1\\\">Scan Directories:</label>\\n        <textarea\\n          id=\\\"scanDirectories\\\"\\n          className=\\\"w-full p-3 rounded-md bg-gray-900 text-gray-100 border border-gray-700 focus:ring-2 focus:ring-indigo-500 focus:border-transparent outline-none mb-4\\\"\\n          rows={2}\\n          placeholder=\\\"Enter comma-separated paths to directories (e.g., src/components, src/utils)\\\"\\n          value={scanDirectories}\\n          onChange={(e) => setScanDirectories(e.target.value)}\\n          disabled={isLoading}\\n        ></textarea>\\n\\n        <label htmlFor=\\\"scanFiles\\\" className=\\\"block text-gray-300 text-sm font-bold mb-1\\\">Scan Individual Files:</label>\\n        <textarea\\n          id=\\\"scanFiles\\\"\\n          className=\\\"w-full p-3 rounded-md bg-gray-900 text-gray-100 border border-gray-700 focus:ring-2 focus:ring-indigo-500 focus:border-transparent outline-none\\\"\\n          rows={2}\\n          placeholder=\\\"Enter comma-separated paths to individual files (e.g., src/main.tsx, apps/ai-editor-front/package.json)\\\"\\n          value={scanFiles}\\n          onChange={(e) => setScanFiles(e.target.value)}\\n          disabled={isLoading}\\n        ></textarea>\\n        <p className=\\\"text-sm text-gray-400 mt-2\\\">\\n          These paths (relative to the monorepo root) will be scanned to provide context to the AI (e.g., file contents, project structure). Leave empty to scan the entire monorepo.\\n        </p>\\n      </div>\\n\\n      {/* Prompt Input Section */}\\n      <div className=\\\"p-6 bg-gray-800 rounded-lg shadow-xl border border-gray-700 mb-8\\\">\\n        <h2 className=\\\"text-2xl font-semibold text-indigo-300 mb-4\\\">\\n          Your Request\\n        </h2>\\n        <textarea\\n          className=\\\"w-full p-3 rounded-md bg-gray-900 text-gray-100 border border-gray-700 focus:ring-2 focus:ring-indigo-500 focus:border-transparent outline-none\\\"\\n          rows={5}\\n          placeholder=\\\"Describe the changes you want the AI to make (e.g., 'Add a new user authentication module', 'Refactor the data fetching logic in App.tsx to use React Query').\\\"\\n          value={prompt}\\n          onChange={(e) => setPrompt(e.target.value)}\\n          disabled={isLoading}\\n        ></textarea>\\n        <div className=\\\"mt-4 flex justify-end\\\">\\n          <Button\\n            onClick={handleGenerateClick}\\n            disabled={isLoading || !prompt.trim()}\\n            className=\\\"bg-indigo-600 hover:bg-indigo-700 text-white\\\"\\n          >\\n            {isLoading ? \\\"Generating...\\\" : \\\"Generate AI Changes\\\"}\\n          </Button>\\n        </div>\\n      }\\n\\n      {/* LLM Output and Proposed Changes */}\\n      {isLoading && (\\n        <div className=\\\"text-center text-indigo-400 text-xl py-8\\\">\\n          Thinking and generating changes... (Expecting JSON output)\\n        </div>\\n      )}\\n\\n      {!isLoading && aiResponseContent && (\\n        <div className=\\\"p-6 bg-gray-800 rounded-lg shadow-xl border border-gray-700 mb-8\\\">\\n          <h2 className=\\\"text-2xl font-semibold text-indigo-300 mb-4\\\">\\n            AI Proposed Solution\\n          </h2>\\n          {isLlmOutput(aiResponseContent) ? (\\n            <>\\n              <p className=\\\"text-lg text-gray-200 mb-4\\\">\\n                <span className=\\\"font-bold\\\">Summary:</span> {aiResponseContent.summary}\\n              </p>\\n              {aiResponseContent.thoughtProcess && (\\n                <div className=\\\"mb-4\\\">\\n                  <h3 className=\\\"text-xl font-medium text-gray-300 mb-2\\\">\\n                    Thought Process:\\n                  </h3>\\n                  <pre className=\\\"bg-gray-900 p-3 rounded-md whitespace-pre-wrap text-gray-400 leading-relaxed\\\">\\n                    {aiResponseContent.thoughtProcess}\\n                  </pre>\\n                </div>\\n              )}\\n\\n              <h3 className=\\\"text-xl font-medium text-gray-300 mb-4 mt-6\\\">\\n                Review & Apply Changes ({acceptedCount} accepted)\\n              </h3>\\n              {proposedChanges.length > 0 ? (\\n                <div className=\\\"space-y-4\\\">\\n                  {proposedChanges.map((change) => (\\n                    <FileChangeDisplay\\n                      key={change.filePath}\\n                      change={change}\\n                      onStatusChange={handleStatusChange}\\n                    />\\n                  ))}\\n                </div>\\n              ) : (\\n                <p className=\\\"text-gray-400 italic\\\">\\n                  No changes proposed by the AI for this request.\\n                </p>\\n              )}\\n\\n              {proposedChanges.length > 0 && (\\n                <div className=\\\"mt-6 flex justify-end\\\">\\n                  <Button\\n                    onClick={handleApplyChanges}\\n                    disabled={acceptedCount === 0 || isLoading} // Disable during application too\\n                    className=\\\"bg-green-600 hover:bg-green-700 text-white\\\"\\n                  >\\n                    {isLoading\\n                      ? \\\"Applying...\\\"\\n                      : `Apply ${acceptedCount} Selected Changes`}\\n                  </Button>\\n                </div>\\n              )}\\n            </>\\n          ) : (\\n            <>\\n              <h3 className=\\\"text-xl font-medium text-gray-300 mb-2\\\">\\n                AI Response (Raw Text):\\n              </h3>\\n              <pre className=\\\"bg-gray-900 p-3 rounded-md overflow-auto text-xs text-gray-200 whitespace-pre-wrap\\\">\\n                <code>{aiResponseContent}</code>\\n              </pre>\\n              <p className=\\\"text-gray-400 italic mt-2\\\">\\n                The AI did not return a response in the expected structured JSON format for file changes.\\n                Ensure your prompt explicitly asks for JSON matching the LLMOutput interface.\\n              </p>\\n            </>\\n          )}\\n        </div>\\n      )}\\n\\n      {/* Go Back Home */}\\n      <div className=\\\"mt-8 text-center\\\">\\n        <Link\\n          to=\\\"/\\\"\\n          className=\\\"inline-flex items-center px-6 py-3 bg-gray-700 text-white font-semibold rounded-lg shadow-md hover:bg-gray-600 transition-colors\\\"\\n        >\\n          Go Back Home\\n        </Link>\\n      </div>\\n    </div>\\n  );\\n}\"\n  },\n  {\n    \"filePath\": \"src/types.ts\",\n    \"action\": \"modify\",\n    \"newContent\": \"// src/types.ts\\n\\n/**\\n * Represents a file that has been scanned from the project,\\n * including its absolute path, its path relative to the project root, and its textual content.\\n */\\nexport interface ScannedFile {\\n  filePath: string; // Absolute path to the file\\n  relativePath: string; // Path relative to the project root (e.g., \\\"src/components/MyComponent.tsx\\\")\\n  content: string;\\n}\\n\\n/**\\n * Represents a proposed change to a file.\\n * This is the structured output we expect from the LLM.\\n */\\nexport interface ProposedFileChange {\\n  filePath: string; // Path relative to the project root (e.g., \\\"src/components/MyComponent.tsx\\\")\\n  action: 'add' | 'modify' | 'delete';\\n  /**\\n   * For 'add' or 'modify' actions, this is the new content of the file.\\n   * For 'delete' actions, this field is not used.\\n   */\\n  newContent?: string;\\n  /**\\n   * An optional human-readable reason or summary for the change.\\n   */\\n  reason?: string;\\n}\\n\\n/**\\n * Represents the structured input that will be sent to the LLM.\\n */\\nexport interface LLMInput {\\n  userPrompt: string;\\n  projectRoot: string; // Absolute path of the project root on the server\\n  projectStructure: string; // A high-level overview of the project directory (e.g., tree string)\\n  relevantFiles: ScannedFile[];\\n  additionalInstructions: string; // Specific behavioral instructions for the LLM\\n  expectedOutputFormat: string; // Instructions on the JSON format for the LLM's response\\n}\\n\\n/**\\n * Represents the structured output received from the LLM.\\n */\\nexport interface LLMOutput {\\n  changes: ProposedFileChange[];\\n  summary: string; // A concise summary of all changes made/proposed\\n  thoughtProcess?: string; // LLM's detailed reasoning for the changes\\n}\\n\"\n  },\n  {\n    \"filePath\": \"src/llm/contextPreparer.ts\",\n    \"action\": \"modify\",\n    \"newContent\": \"// src/llm/contextPreparer.ts\\nimport * as path from 'path';\\nimport { ScannedFile, LLMInput } from '../types';\\n\\n/**\\n * Prepares the context for the LLM by structuring the user prompt,\\n * relevant files, and system instructions into a single LLMInput object.\\n *\\n * @param userPrompt The natural language request from the user.\\n * @param scannedFiles An array of all files scanned from the project.\\n * @param projectRoot The absolute path to the project's root directory.\\n * @returns An LLMInput object ready to be sent to the LLM.\\n */\\nexport function prepareContextForLLM(userPrompt: string, scannedFiles: ScannedFile[], projectRoot: string): LLMInput {\\n\\n  // 1. Generate a simplified project structure string using relative paths\\n  const projectStructureLines = scannedFiles\\n    .map(file => file.relativePath) // Use the relativePath from ScannedFile\\n    .sort()\\n    .map(relPath => `- ${relPath}`);\\n\\n  const projectStructure = `Project File Structure (relative to root):\\\\n${projectStructureLines.join('\\\\n')}\\\\n`;\\n\\n  // 2. Define the expected output format for the LLM\\n  const outputSchema = `\\n            Your response must be a JSON object with two top-level keys: 'summary' (string) and 'changes' (array of objects).\\n            The 'changes' array should contain objects, each representing a file operation:\\n            {\\n              \\\"filePath\\\": \\\"path/to/file.tsx\\\", // Path relative to the project root (e.g., \\\"src/components/MyComponent.tsx\\\")\\n              \\\"action\\\": \\\"add\\\" | \\\"modify\\\" | \\\"delete\\\",\\n              \\\"newContent\\\"?: \\\"...\\\", // Required for 'add'/'modify', omit for 'delete'\\n              \\\"reason\\\"?: \\\"...\\\" // Optional, short explanation for this specific file change\\n            }\\n            Example:\\n            {\\n              \\\"summary\\\": \\\"Implemented user authentication and updated Navbar component.\\\",\\n              \\\"thoughtProcess\\\": \\\"Created new components for login and signup, updated navigation to include auth links, and added a basic auth context.\\\",\\n              \\\"changes\\\": [\\n                {\\n                  \\\"filePath\\\": \\\"src/auth/Login.tsx\\\",\\n                  \\\"action\\\": \\\"add\\\",\\n                  \\\"newContent\\\": \\\"import React from 'react';\\\\\\\\nimport { useStore } from '@nanostores/react';\\\\\\\\nimport { authStore } from './authStore';\\\\\\\\n\\\\\\\\nfunction Login() {\\\\\\\\n  const $auth = useStore(authStore);\\\\\\\\n  // ... login form logic\\\\\\\\n  return <div className='p-4'>Login Form</div>;\\\\\\\\n}\\\\\\\\nexport default Login;\\\",\\n                  \\\"reason\\\": \\\"New login component for user authentication.\\\"\\n                },\\n                {\\n                  \\\"filePath\\\": \\\"src/components/Navbar.tsx\\\",\\n                  \\\"action\\\": \\\"modify\\\",\\n                  \\\"newContent\\\": \\\"import React from 'react';\\\\\\\\nimport { Link } from 'react-router-dom';\\\\\\\\nimport { useStore } from '@nanostores/react';\\\\\\\\nimport { authStore } from '../auth/authStore';\\\\\\\\n\\\\\\\\nfunction Navbar() {\\\\\\\\n  const $auth = useStore(authStore);\\\\\\\\n  return (\\\\\\\\n    <nav className='bg-blue-500 p-4 text-white flex justify-between'>\\\\\\\\n      <Link to='/' className='font-bold text-lg'>My App</Link>\\\\\\\\n      <div>\\\\\\\\n        {$auth.isLoggedIn ? (\\\\\\\\n          <button onClick={() => authStore.setKey('isLoggedIn', false)} className='ml-4'>Logout</button>\\\\\\\\n        ) : (\\\\\\\\n          <>\\\\\\\\n            <Link to='/login' className='ml-4'>Login</Link>\\\\\\\\n            <Link to='/signup' className='ml-4'>Signup</Link>\\\\\\\\n          </>\\\\\\\\n        )}\\\\\\\\n      </div>\\\\\\\\n    </nav>\\\\\\\\n  );\\\\\\\\n}\\\\\\\\nexport default Navbar;\\\",\\n                  \\\"reason\\\": \\\"Added login/logout links to Navbar based on authentication status.\\\"\\n                },\\n                {\\n                  \\\"filePath\\\": \\\"src/old/DeprecatedComponent.ts\\\",\\n                  \\\"action\\\": \\\"delete\\\",\\n                  \\\"reason\\\": \\\"Removed unused component as part of refactor.\\\"\\n                }\\n              ]\\n            }\\n          `.replace(/^\\\\s+/gm, '');\\n\\n  // 3. Construct additional instructions for the LLM\\n  const additionalInstructions = `\\nYou are an elite TypeSafe UI Architect. Your goal is to generate or modify code to fulfill the user's request, strictly adhering to modern frontend best practices.\\nFocus on TypeScript, React (with Hooks and nanostores where applicable), and Tailwind CSS v4.\\nGenerate clean, idiomatic, production-ready code.\\nAlways propose a clear, refactored, and logically separated file and folder structure.\\nConsider type safety paramount.\\nIf the request involves new components, ensure they are well-structured, reusable, and include necessary imports and typings.\\nIf modifying existing components, ensure backward compatibility where reasonable, or clearly state breaking changes.\\nWhen generating new code, ensure it aligns with the existing project's style (indentation, semicolons, etc.).\\nDo not make assumptions about external APIs unless specified.\\nIf you need to add a new file, propose the full content of that new file.\\nIf you need to modify an existing file, propose the full new content of that file.\\nIf you need to delete a file, specify its path and action 'delete'.\\n`;\\n\\n  return {\\n    userPrompt: userPrompt,\\n    projectRoot: projectRoot,\\n    projectStructure: projectStructure,\\n    relevantFiles: scannedFiles,\\n    additionalInstructions: additionalInstructions,\\n    expectedOutputFormat: outputSchema,\\n  };\\n}\\n\\n/**\\n * This function will construct the final prompt string that is sent to the LLM.\\n * This combines all parts of the LLMInput into a single markdown-formatted string.\\n * @param llmInput The structured input object.\\n * @param projectRoot The project root (passed to ensure consistency, but \\`llmInput.projectRoot\\` is the primary source).\\n * @returns A string representing the full prompt for the LLM.\\n */\\nexport function buildLLMPrompt(llmInput: LLMInput, projectRoot: string): string {\\n  // Use \\`file.relativePath\\` from \\`scannedFiles\\` for the prompt, as it's cleaner for LLM context.\\n  const formattedRelevantFiles = llmInput.relevantFiles.map(file => {\\n    return `// File: ${file.relativePath}\\\\n${file.content}`;\\n  }).join('\\\\n\\\\n'); // Separate files with double newlines\\n\\n  return `\\n# AI Code Generation Request\\\\n\\\\n${llmInput.additionalInstructions}\\\\n\\\\n## User Request\\\\n\\`\\`\\`text\\\\n${llmInput.userPrompt}\\\\n\\`\\`\\`\\\\n\\\\n## Project Context\\\\n${llmInput.projectStructure}\\\\n\\\\n### Relevant Files (for analysis)\\\\n\\`\\`\\`files\\\\n${formattedRelevantFiles}\\\\n\\`\\`\\`\\\\n\\\\n## Expected Output Format\\\\n${llmInput.expectedOutputFormat}\\\\n`;\\n}\"\n  }\n]"
}